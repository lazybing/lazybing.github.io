
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>FFMpeg 实现视频编码、解码、封装、解封装、转码、缩放 - 懒人李冰</title>
  <meta name="author" content="李冰">

  
  <meta name="description" content="FFMpeg 编码实现 FFMpeg 解码实现 FFMpeg 封装实现 FFMpeg 解封装实现 FFMpeg 转码的实现 FFMpeg 视频缩放实现 FFMpeg 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理，本文主要利用 FFMpeg 官方提供的 SDK &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="懒人李冰" type="application/atom+xml">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-77812244-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">懒人李冰</a></h1>
  
    <h2>记录我的生活、学习</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="订阅RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="lazybing.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="搜索"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="/photography/">摄影作品</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">FFMpeg 实现视频编码、解码、封装、解封装、转码、缩放</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-01T08:17:10-07:00'><span class='date'>2017 年 01 月 01 日</span> <span class='time'>8:17 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><ul id="markdown-toc">
  <li><a href="#ffmpeg-" id="markdown-toc-ffmpeg-">FFMpeg 编码实现</a></li>
  <li><a href="#ffmpeg--1" id="markdown-toc-ffmpeg--1">FFMpeg 解码实现</a></li>
  <li><a href="#ffmpeg--2" id="markdown-toc-ffmpeg--2">FFMpeg 封装实现</a></li>
  <li><a href="#ffmpeg--3" id="markdown-toc-ffmpeg--3">FFMpeg 解封装实现</a></li>
  <li><a href="#ffmpeg--4" id="markdown-toc-ffmpeg--4">FFMpeg 转码的实现</a></li>
  <li><a href="#ffmpeg--5" id="markdown-toc-ffmpeg--5">FFMpeg 视频缩放实现</a></li>
</ul>

<p><a href="https://ffmpeg.org/">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理，本文主要利用 FFMpeg 官方提供的 SDK 实现音视频最简单的几个实例：编码、解码、封装、解封装、转码、缩放以及添加水印。</p>

<!--more-->
<p>接下来会由发现问题－＞分析问题－＞解决问题－＞实现方案，循序渐进的完成。</p>

<p>参考代码:<a href="https://github.com/lazybing/ffmpeg-study-recording">ffmpeg_sdk</a></p>

<h2 id="ffmpeg-">FFMpeg 编码实现</h2>

<p>本例子实现的是将视频域 YUV 数据编码为压缩域的帧数据，编码格式包含了 H.264/H.265/MPEG1/MPEG2 四种 CODEC 类型。
实现的过程，可以大致用如下图表示:</p>

<p><img src="/images/ffmpeg_sdk/encoder.png" /></p>

<p>从图中可以大致看出视频编码的流程:</p>

<ul>
  <li>首先要有未压缩的 YUV 原始数据。</li>
  <li>其次要根据想要编码的格式选择特定的编码器。</li>
  <li>最后编码器的输出即为编码后的视频帧。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>存放待压缩的 YUV 原始数据。此时可以利用 FFMpeg 提供的 AVFrame 结构体，并根据 YUV 数据来填充 AVFrame　结构的视频宽高、像素格式；根据视频宽高、像素格式可以分配存放数据的内存大小，以及字节对齐情况。</li>
  <li>获取编码器。利用想要压缩的格式，比如　H.264/H.265/MPEG1/MPEG2 等，来获取注册的编解码器，编解码器在 FFMpeg 中用 AVCodec 结构体表示，对于编解码器，肯定要对其进行配置，包括待压缩视频的宽高、像素格式、比特率等等信息，这些信息，FFMpeg 提供了一个专门的结构体 AVCodecContext 结构体。</li>
  <li>存放编码后压缩域的视频帧。FFMpeg 中用来存放压缩编码数据相关信息的结构体为 AVPacket。最后将 AVPacket 存储的压缩数据写入文件即可。</li>
</ul>

<hr />

<p>AVFrame 结构体的分配使用<code>av_frame_alloc()</code>函数，该函数会对 AVFrame 结构体的某些字段设置默认值，它会返回一个指向 AVFrame 的指针或 NULL指针(失败)。AVFrame 结构体的释放只能通过<code>av_frame_free()</code>来完成。注意，该函数只能分配 AVFrame 结构体本身，不能分配它的 data buffers 字段指向的内容，该字段的指向要根据视频的宽高、像素格式信息手动分配，本例使用的是<code>av_image_alloc()</code>函数。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//allocate AVFrame struct</span>
</span><span class="line"><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Frame Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//fill AVFrame struct fields</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">AV_PIX_FMT_YUV420P</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//allocate AVFrame data buffers field point</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//write input file data to frame-&gt;data buffer</span>
</span><span class="line"><span class="n">fread</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">width</span><span class="o">*</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">av_frame_free</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>编解码器相关的 AVCodec 结构体的分配使用<code>avcodec_find_encoder(enum AVCodecID id)</code>完成，该函数的作用是找到一个与 AVCodecID 匹配的已注册过得编码器；成功则返回一个指向 AVCodec ID 的指针，失败返回 NULL 指针。该函数的作用是确定系统中是否有该编码器，只是能够使用编码器进行特定格式编码的最基本的条件，要想使用它，至少要完成两个步骤：</p>

<ol>
  <li>根据特定的视频数据，对该编码器进行特定的配置；</li>
  <li>打开该编码器。</li>
</ol>

<p>针对第一步中关于编解码器的特定参数，FFMpeg 提供了一个专门用来存放 AVCodec 所需要的配置参数的结构体 AVCodecContext 结构。它的分配使用<code>avcodec_alloc_context3(const AVCodec *codec)</code>完成，该函数根据特定的 CODEC 分配一个 AVCodecContext 结构体，并设置一些字段为默认参数，成功则返回指向 AVCodecContext 结构体的指针，失败则返回 NULL 指针。分配完成后，根据视频特性，手动指定与编码器相关的一些参数，比如视频宽高、像素格式、比特率、GOP 大小等。最后根据参数信息，打开找到的编码器，此处使用<code>avcodec_open2()</code>函数完成。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//register all encoder and decoder</span>
</span><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line">
</span><span class="line"><span class="c1">//find the encoder</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_encoder</span><span class="p">(</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could Not Find the Encoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//allocate the AVCodecContext and fill it&#39;s fields</span>
</span><span class="line"><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecCtx Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="mi">4000000</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">width</span>    <span class="o">=</span> <span class="n">frameWidth</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">height</span>   <span class="o">=</span> <span class="n">frameHeight</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="o">=</span> <span class="p">(</span><span class="n">AVRational</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="c1">//open the encoder</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Encoder Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>存放编码数据的结构体为 AVPacket，使用之前要对该结构体进行初始化，初始化函数为<code>av_init_packet(AVPacket *pkt)</code>，该函数会初始化 AVPacket 结构体中一些字段为默认值，但它不会设置其中的 data 和 size 字段，需要单独初始化,如果此处将 data 设为 NULL、size 设为 0，编码器会自动填充这两个字段。</p>

<p>有了存放编码数据的结构体后，我们就可以利用编码器进行编码了。FFMpeg 提供的用于视频编码的函数为<code>avcodec_encode_video2</code>,它作用是编码一帧视频数据，该函数比较复杂，单独列出如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avcodec_encode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_packet_ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>它会接收来自 AVFrame-&gt;data 的视频数据，并将编码数据放到 AVPacket-&gt;data 指向的位置，编码数据大小为 AVPacket-&gt;size。</p>

<p>其参数和返回值的意义：</p>

<ul>
  <li>avctx: AVCodecContext 结构，指定了编码的一些参数；</li>
  <li>avPkt: AVPacket对象的指针，用于保存输出的码流；</li>
  <li>frame：AVFrame结构，用于传入原始的像素数据；</li>
  <li>got_packet_ptr:输出参数，用于标识是否已经有了完整的一帧；</li>
  <li>返回值：编码成功返回 0， 失败返回负的错误码；</li>
</ul>

<p>编码完成后就可将AVPacket-&gt;data内的编码数据写到输出文件中；代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//init AVPacket</span>
</span><span class="line"><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//encode the image</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_encode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">got_output</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Encode Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="err">｝</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">got_output</span><span class="p">){</span>
</span><span class="line">	<span class="n">fwrite</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/encoder.c">编码实现</a>。</p>

<h2 id="ffmpeg--1">FFMpeg 解码实现</h2>

<p>解码实现的是将压缩域的视频数据解码为像素域的 YUV 数据。实现的过程，可以大致用如下图所示。</p>

<p><img src="/images/ffmpeg_sdk/decoder.png" /></p>

<p>从图中可以看出，大致可以分为下面三个步骤：</p>

<ul>
  <li>首先要有待解码的压缩域的视频。</li>
  <li>其次根据压缩域的压缩格式获得解码器。</li>
  <li>最后解码器的输出即为像素域的 YUV 数据。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>关于输入数据。首先，要分配一块内存，用于存放压缩域的视频数据；之后，对内存中的数据进行预处理，使其分为一个一个的 AVPacket 结构（AVPacket 结构的简单介绍如上面的编码实现）。最后，将 AVPacket 结构中的 data 数据给到解码器。</li>
  <li>关于解码器。首先，利用 CODEC_ID 来获取注册的解码器；之后，将预处理过得视频数据给到解码器进行解码。</li>
  <li>关于输出。FFMpeg 中，解码后的数据存放在 AVFrame 中；之后就将 AVFrame 中的 data 字段的数据存放到输出文件中。</li>
</ul>

<hr />

<p>对于输入数据，首先，通过 fread 函数实现将固定长度的输入文件的数据存放到一块 buffer 内。H.264中一个包的长度是不定的，读取固定长度的码流通常不可能刚好读出一个包的长度；对此，FFMpeg 提供了一个 AVCoderParserContext 结构用于解析读到 buffer 内的码流信息，直到能够取出一个完整的 H.264 包。为此，FFMpeg 提供的函数为<code>av_parser_parse2</code>，该函数比较复杂，定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">av_parser_parse2</span><span class="p">(</span><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
</span><span class="line">                     <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">poutbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">poutbuf_size</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_size</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">int64_t</span> <span class="n">pts</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dts</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>函数的参数和返回值含义如下：</p>

<ul>
  <li>AVCodecParserContext *s:初始化过的 AVCodecParserContext 对象，决定了码流该以怎样的标准进行解析；</li>
  <li>AVCodecContext *avctx：预先定义好的 AVCodecContext 对象；</li>
  <li>uint8_t **poutbuf：AVPacket：：data 的地址，保存解析完成的包数据。</li>
  <li>int *poutbuf_size：AVPacket 的实际数据长度，如果没有解析出完整的一个包，该值为 0；</li>
  <li>const uint8_t *but:待解码的码流的地址；</li>
  <li>int buf_size:待解码的码流的长度；</li>
  <li>int64_t pts, int64_t dts:显示和解码的时间戳；</li>
  <li>int64_t pos:码流中的位置；</li>
  <li>返回值为解析所使用的比特位的长度；</li>
</ul>

<p>FFMpeg 中为我们提供的该函数常用的使用方式为：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">in_len</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">myparser</span><span class="p">.</span> <span class="n">AVCodecContext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">in</span> <span class="n">len</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">dts</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">	<span class="n">in_data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">in_len</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
</span><span class="line">		<span class="n">decode_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。</p>

<p>因此，关于输入数据的处理，代码大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//open input file</span>
</span><span class="line"><span class="kt">FILE</span> <span class="o">*</span><span class="n">pInput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Input_FileName</span><span class="p">,</span> <span class="s">&quot;rb+&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInput_File</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Input File Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class="line"><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class="line">							<span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class="line">							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class="line">	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="n">decode_frame</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意，上面提到的<code>av_parser_parse2</code>函数用的几个参数，其实是与具体的编码格式有关的，它们应该在之前已经分配好了，我们只是放到后面来讲一下，因为它们是与具体的解码器强相关的。</p>

<hr />

<p>对于解码器。与上面提到的编码实现类似，首先，根据 CODEC_ID 找到注册的解码器 AVCodec，FFMpeg 为此提供的函数为<code>avcodec_find_decoder()</code>；其次，根据找到的解码器获取与之相关的解码器上下文结构体 AVCodecC，使用的函数为编码中提到的<code>avcodec_alloc_context3</code>；再者，如上面提到的要获取完整的一个 NALU，解码器需要分配一个 AVCodecParserContext 结构，使用函数<code>av_parser_init</code>；最后，前面的准备工作完成后，打开解码器，即可调用 FFMpeg 提供的解码函数<code>avcodec_decode_video2</code>对输入的压缩域的码流进行解码，并将解码数据存放到 AVFrame-&gt;data 中。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//register all encoder and decoder</span>
</span><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate AVFrame to Store the Decode Data</span>
</span><span class="line"><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Frame Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Find the  AVCodec Depending on the CODEC_ID</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Find the Decoder Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate the AVCodecContext </span>
</span><span class="line"><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecCtx Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate the AVCodecParserContext </span>
</span><span class="line"><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="n">av_parser_init</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pCodecParserCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecParserContext Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Open the Decoder</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could not Open the Decoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class="line"><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class="line">							<span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class="line">							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class="line">	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="c1">//decode start</span>
</span><span class="line">	<span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">got_frame</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意，上面解码的过程中，针对具体的实现，可能要做一些具体参数上的调整，此处只是理清解码的流程。</p>

<hr />

<p>对于输出数据。解码完成后，解码出来的像素域的数据存放在 AVFrame 的 data 字段内，只需要将该字段内存放的数据之间写文件到输出文件即可。解码函数<code>avcodec_decode_video2</code>函数完成整个解码过程，对于它简单介绍如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class="line">                         <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class="line">                         <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>该函数各个参数的意义：</p>

<ul>
  <li>AVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成；</li>
  <li>AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好；</li>
  <li>int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了;</li>
  <li>const AVPacket *avpkt: 前面解析好的码流包；</li>
</ul>

<p>由此可见，当标识位为1时，代表解码一帧结束，可以写数据到文件中。代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">pOutput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Output_FileName</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pOutput_File</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Output File Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">){</span>
</span><span class="line">	<span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span> <span class="n">Len</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>解码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/decoder.c">解码实现</a>。</p>

<h2 id="ffmpeg--2">FFMpeg 封装实现</h2>

<p>本例子实现的是将视频数据和音频数据，按照一定的格式封装为特定的容器，比如FLV、MKV、MP4、AVI等等。实现的过程，可以大致用如下图表示：</p>

<p><img src="/images/ffmpeg_sdk/muxer.png" /></p>

<p>从图中可以大致看出视频封装的流程：</p>

<ul>
  <li>首先要有编码好的视频、音频数据。</li>
  <li>其次要根据想要封装的格式选择特定的封装器。</li>
  <li>最后利用封装器进行封装。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>利用给定的YUV数据编码得到某种 CODEC 格式的编码视频（可以参见上面提到的<a href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/#ffmpeg-">编码实现</a>），同样的方法得到音频数据。</li>
  <li>获取输出文件格式。获取输出文件格式可以直接指定文件格式，比如FLV/MKV/MP4/AVI等，也可以通过输出文件的后缀名来确定，或者也可以选择默认的输出格式。根据得到的文件格式，其中可能有视频、音频等，为此我们需要为格式添加视频、音频、并对格式中的一些信息进行设置（比如头）。</li>
  <li>利用设置好的音频、视频、头信息等，开始封装。</li>
</ul>

<hr />

<p>对于由 YUV 数据得到编码的视频数据部分，不再重复。直接看与 Muxer 相关的部分，与特定的 Muxer 相关的信息，FFMpeg 提供了一个 AVFormatContext 的结构体描述，并用<code>avformat_alloc_output_context2()</code>函数来分配它。该函数的声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avformat_alloc_output_context2</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">oformat</span><span class="p">,</span>
</span><span class="line">                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中：</p>

<ul>
  <li>ctx:输出到 AVFormatContext 结构的指针，如果函数失败则返回给该指针为 NULL。</li>
  <li>oformat：指定输出的 AVOutputFormat 类型，如果设为 NULL，则根据 format_name 和 filename 生成。</li>
  <li>format_name:输出格式的名称，如果设为 NULL，则使用 filename 默认格式。</li>
  <li>filename：目标文件名，如果不使用，可以设为 NULL。</li>
  <li>返回值：&gt;=0 则成功，否则失败。</li>
</ul>

<p>代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
</span><span class="line"><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* allocate the output media context */</span>
</span><span class="line"><span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could not deduce output format from file extension: using MPEG.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;mpeg&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">fmt</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">oformat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>有了表示媒体文件格式的 AVFormatContext 结构后，就需要根据媒体格式来判断是否需要往媒体文件中添加视频流、音频流（有的媒体文件，这两种流并不是必须的）；以 MP4 格式的媒体文件为例，我们需要一路视频流、一路音频流。因此需要创建一路流，FFMpeg 提供的创建流的函数为<code>avformat_new_stream()</code>，该函数完成向 AVFormatContext 结构体中所代码的媒体文件中添加数据流，函数声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVStream</span> <span class="o">*</span><span class="nf">avformat_new_stream</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中：</p>

<ul>
  <li>s:AVFormatContext 结构，表示要封装生成的视频文件。</li>
  <li>c：视频或音频流的编码器的指针。</li>
  <li>返回值：指向生成的 stream 对象的指针；失败则返回 NULL。</li>
</ul>

<p>注意：对于 Muxer，该函数必须在调用<code>avformat_write_header()</code>前调用。使用完成后，需要调用<code>avcodec_close()</code>和<code>avformat_free_context()</code>来清理由它分配的内容。</p>

<p>该函数调用完成后，一个新的 AVStream 便已经加入到输出文件中，下面就需要设置 stream 的 id 和 codec 等参数。以视频流为例，代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">OutputStream</span> <span class="o">*</span><span class="n">ost</span><span class="p">;</span>
</span><span class="line"><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodec</span> <span class="o">**</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="n">AVStream</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">st</span> <span class="o">=</span> <span class="n">avformat_new_stream</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not allocate stream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">st</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>参数设置完成后，就可以打开编码器并为编码器分配必要的内存。步骤跟之前的类似，以视频为例，示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//open the codec</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not open video codec: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="c1">//allocate and init a re-usable frame</span>
</span><span class="line"><span class="n">ost</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">alloc_picture</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来进行真正的封装：首先，为媒体文件添加头部信息,FFMpeg 为此提供的函数为<code>avformat_write_header()</code>。其次，将编码好的音视频 AVPacket 包添加到媒体文件中去，FFMpeg 为此提供的函数为<code>av_interleaved_write_frame()</code>。最后，写入文件尾的数据，FFMpeg 为此提供的函数为<code>av_write_trailer()</code>。</p>

<p>封装的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/muxer.c">封装实现</a>。</p>

<h2 id="ffmpeg--3">FFMpeg 解封装实现</h2>

<p>本例子实现的是将音视频分离，例如将封装格式为 FLV、MKV、MP4、AVI 等封装格式的文件，将音频、视频分离开来。
实现的过程，可以大致用如下图表示：</p>

<p><img src="/images/ffmpeg_sdk/demuxer.png" /></p>

<p>从图中可以看出大致的节封装流程：</p>

<ul>
  <li>首先要对解复用器进行初始化。</li>
  <li>其次将输入的封装格式文件给到解复用器内。</li>
  <li>最后利用解封装对 Container 进行解封装。</li>
</ul>

<p>根据流程可以推到出大致的代码流程：</p>

<ul>
  <li>首先对输入文件(Container 文件)、输出文件(Video/Audio 进行处理)，方便后面的使用；</li>
  <li>其次打开输入文件，并分配 Format Context，从输入文件中得到流信息</li>
  <li>之后打开视频、音频编码器 Context,针对视频数据，分配图像 image。</li>
  <li>分配 frame 结构，初始化 packet，从输入文件中读取 frame 信息，并之后进行解码 packet。</li>
  <li>最后释放各种分配的数据信息。</li>
</ul>

<hr />

<p>在音视频分离后，需要将分离出的音视频分别放到不同的输出文件中，为此，需要打开文件以备后用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">video_dst_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">audio_dst_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">video_dst_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">audio_dst_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">video_dst_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line"><span class="n">audio_dst_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line"><span class="n">video_dst_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">video_dst_filename</span><span class="p">,</span> <span class="s">&quot;wb+&quot;</span><span class="p">);</span>
</span><span class="line"><span class="n">audio_dst_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">audio_dst_filename</span><span class="p">,</span> <span class="s">&quot;wb+&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>对于给定的需要 AV 分离的输入文件，使用<code>avformat_open_input</code>打开输入文件，并分配<code>AVFormatContext</code>结构。该函数的声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options);</span></code></pre></td></tr></table></div></figure>
<p>其中：</p>

<ul>
  <li>ps:指向由用户提供的<code>AVFormatContext</code>结构体，该结构体通过<code>avformat_alloc_context</code>分配，如果它是一个 NULL，该结构在此函数内分配并负值给 ps。</li>
  <li>filename:指向需要打开的流的名称。</li>
  <li>fmt：如果是 non-NULL,该参数指定输入的文件格式，否则输入文件的格式自动根据文件本身自动获取。</li>
  <li>options:此处可以为 NULL。</li>
  <li>返回值：成功返回0，否则返回 AVERROR。</li>
</ul>

<p>实现代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//open input file, and allocate format context</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">src_filename</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not open source file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">src_filename</span><span class="p">);</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//retrive stream information</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not find stream information</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>通过输入文件分配好<code>AVFormatContext</code>后，需要找到里面的音频流和视频流，此处需要用到的函数为<code>av_find_best_stream</code>;
之后要根据找到的不同的流(如H264流、HEVC流等)找到特定的编解码器，此处使用<code>avcodec_find_decoder</code>;找到了解码器后，
就需要打开解码器，此处使用<code>avcodec_open2</code>函数完成。下面分别介绍这几个函数的使用：</p>

<p><code>av_find_best_stream</code>函数定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec **decoder_ret, int flags);</span></code></pre></td></tr></table></div></figure>
<p>其中：</p>

<ul>
  <li>ic:媒体文件句柄。</li>
  <li>type:媒体类型，视频、音频、文本等。</li>
  <li>wanted_stream_nb:用户请求的流，-1 代表自动选择。</li>
  <li>related_stream:尝试找到相关流，如果没有就设为-1。</li>
  <li>decoder_ret:如果是non-NULL,返回选定的流的解码器。</li>
  <li>flags：此处定位0。</li>
  <li>返回值：成功返回非负值，如果找不到指定的请求类型的流，就返回<code>AVERROR_STREAM_NOT_FOUND</code>;如果找到了流，但没找到对应的解码器，就返回<code>AVERROR_DECODER_NOT_FOUND</code>。</li>
</ul>

<p><code>avcodec_find_decoder</code>函数定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AVCodec *avcodec_find_decoder(enum AVCodecID id);</span></code></pre></td></tr></table></div></figure>

<p>该函数参数为<code>AVCodecID</code>指定了请求的解码器，成功返回解码器，否则返回 NULL。</p>

<p><code>avcodec_open2</code>函数定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);</span></code></pre></td></tr></table></div></figure>

<p>其中：</p>

<ul>
  <li>avctx:即将初始化的<code>AVCodecContext</code>结构体。</li>
  <li>codec：打开的解码器，如果它是non-NULL codec,并在之前传递给了<code>avcodec_alloc_context3</code>或<code>avcodec_get_context_defaults3</code>，该参数必须为 NULL 或之前传递的 CODEC。</li>
  <li>Options：此处我们设置为 NULL。</li>
  <li>返回值：成功返回0，出错返回一个负值。</li>
</ul>

<p>该函数的主要作用是根据给定的<code>AVCodec</code>初始化<code>AVCodecContext</code>,在使用该函数之前，待初始化的<code>AVCodecContext</code>结构需要先使用<code>avcodec_alloc_context3</code>分配好。其中的参数
<code>AVCodec</code>可以通过<code>avcodec_find_decoder_by_name</code><code>avcodec_find_encoder_by_name</code><code>avcodec_find_decoder</code>或<code>avcodec_find_endcoder</code>来获取。在进行真正的解码之前，必须调用该函数。
下面给出使用的示例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line"><span class="n">av_dict_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;2.5M&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>对于上面分析的部分，我们将其封装在一个函数里，代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="nf">open_codec_context</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">stream_idx</span><span class="p">,</span>
</span><span class="line">                              <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">fmt_ctx</span><span class="p">,</span>
</span><span class="line">                              <span class="k">enum</span> <span class="n">AVMediaType</span> <span class="n">type</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stream_index</span><span class="p">;</span>
</span><span class="line">    <span class="n">AVStream</span> <span class="o">*</span><span class="n">pStream</span><span class="p">;</span>
</span><span class="line">    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codec_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="n">av_find_best_stream</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not find %s stream in input file &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">                <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">src_filename</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class="line">        <span class="n">stream_index</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="n">pStream</span> <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">        <span class="c1">//find decoder for the stream</span>
</span><span class="line">        <span class="n">codec_ctx</span> <span class="o">=</span> <span class="n">pStream</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line">        <span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class="line">            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to find %s codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">                    <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="c1">//open the decoder</span>
</span><span class="line">        <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to open %s codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">                    <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="o">*</span><span class="n">stream_idx</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>针对音频、视频，分别调用该函数，示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">open_codec_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_stream_idx</span><span class="p">,</span> <span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="n">video_stream</span>    <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">video_stream_idx</span><span class="p">];</span>
</span><span class="line">        <span class="n">video_codec_ctx</span> <span class="o">=</span> <span class="n">video_stream</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="c1">//allocate image where the decoded image will be put</span>
</span><span class="line">        <span class="n">width</span>   <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">height</span>  <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
</span><span class="line">        <span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">;</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">,</span> <span class="n">video_dst_linesize</span><span class="p">,</span>
</span><span class="line">                             <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not allocate raw video buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">video_dst_bufsize</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">open_codec_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">audio_stream_idx</span><span class="p">,</span> <span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">AVMEDIA_TYPE_AUDIO</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="n">audio_stream</span> <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">audio_stream_idx</span><span class="p">];</span>
</span><span class="line">        <span class="n">audio_codec_ctx</span> <span class="o">=</span> <span class="n">audio_stream</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的一些准备工作完成后，就需要从输入文件中一帧一帧读取数据，并进行解码了。从这里可以看出，需要找到一个
一帧视频存放的地方，为此需要使用<code>av_init_packet</code>初始化一个<code>AVPacket</code>。之后就可以使用<code>av_read_frame</code>来从输入
文件中读取一个 frame。示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_packet</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">got_frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cached</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">got_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">video_stream_idx</span><span class="p">){</span>
</span><span class="line">        <span class="c1">//decode video frame</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">video_codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">got_frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error decoding video frame (%s) </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">                    <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;num %d got_frame %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="o">++</span><span class="p">,</span> <span class="o">*</span><span class="n">got_frame</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_frame</span><span class="p">){</span>
</span><span class="line">            <span class="n">av_image_copy</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">,</span> <span class="n">video_dst_linesize</span><span class="p">,</span>
</span><span class="line">                          <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="p">)(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span>
</span><span class="line">                          <span class="n">pix_fmt</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="c1">//write to raw video file</span>
</span><span class="line">            <span class="n">fwrite</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">video_dst_bufsize</span><span class="p">,</span> <span class="n">video_dst_file</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">audio_stream_idx</span><span class="p">){</span>
</span><span class="line">        <span class="c1">//decode audio frame</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_decode_audio4</span><span class="p">(</span><span class="n">audio_codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">got_frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error decoding audio frame (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_frame</span><span class="p">){</span>
</span><span class="line">            <span class="kt">size_t</span> <span class="n">unpadded_linesize</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">nb_samples</span> <span class="o">*</span> <span class="n">av_get_bytes_per_sample</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">);</span>
</span><span class="line">            <span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">extended_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">unpadded_linesize</span><span class="p">,</span> <span class="n">audio_dst_file</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">FFMIN</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//allocate frame </span>
</span><span class="line"><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not allocate frame</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//read frames from the file</span>
</span><span class="line"><span class="kt">int</span> <span class="n">got_frame</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">av_read_frame</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="n">AVPacket</span> <span class="n">orig_pkt</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">do</span><span class="p">{</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">decode_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">got_frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="n">av_free_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">orig_pkt</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>解封装大致流程已经完成了，剩余的是一些收尾工作，例如释放刚刚分配的内存等。</p>

<p>完整实现过程请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/demuxer.c">解封在实现</a>.</p>

<h2 id="ffmpeg--4">FFMpeg 转码的实现</h2>

<h2 id="ffmpeg--5">FFMpeg 视频缩放实现</h2>

<p>针对视频的缩放，FFMpeg 提供了 libswscale 库，可以轻松实现视频的分辨率转换功能。除此之外，libswscale 库还可以
实现颜色空间转换的功能。</p>

<p>FFMpeg 中针对视频的缩放提供了一个示例代码，位于<code>doc\examples\scaling_video.c</code>中。分析该程序的流程大致分为如下几部分：</p>

<ol>
  <li>解析命令行参数，获取缩放的视频宽高，视频文件名。</li>
  <li>创建<code>SwsContext</code>结构体。</li>
  <li>分配源图像和目标图像的内存。</li>
  <li>将源图像进行转换为目标图像的大小。</li>
  <li>将缩放的图像写到输出文件中。</li>
  <li>收尾工作，释放分配的内存，关闭打开的文件。</li>
</ol>

<p>首先解析期望的视频宽高，示例代码中使用的是<code>av_parse_video_size</code>函数，该函数的声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">av_parse_video_size</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">width_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">height_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>解析 str，并将解析出来的宽高信息赋值给 width_ptr, height_ptr;其中：</p>

<ul>
  <li>str：待解析的字符串，可以是格式为<code>widthxheight</code>的字符串，或者是一个合法的视频大小描述。</li>
  <li>width_ptr,height_ptr,指向检测到的宽高变量的指针。</li>
  <li>返回值，成功返回大于0，失败返回负值。</li>
</ul>

<p>之后，创建<code>SwsContext</code>结构体，示例代码中使用的是<code>sws_getContext</code>函数，该函数声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="nf">sws_getContext</span><span class="p">(</span><span class="kt">int</span> <span class="n">srcW</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcH</span><span class="p">,</span> <span class="k">enum</span> <span class="n">AVPixelFormat</span> <span class="n">srcFormat</span><span class="p">,</span>
</span><span class="line">                                  <span class="kt">int</span> <span class="n">dstW</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstH</span><span class="p">,</span> <span class="k">enum</span> <span class="n">AVPixelFormat</span> <span class="n">dstFormat</span><span class="p">,</span>
</span><span class="line">                                  <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">SwsFilter</span> <span class="o">*</span><span class="n">srcFilter</span><span class="p">,</span>
</span><span class="line">                                  <span class="n">SwsFilter</span> <span class="o">*</span><span class="n">dstFilter</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>该函数的作用是分配并返回一个<code>SwsContext</code>结构，后面如果需要实现缩放/转换操作时，需要使用<code>sws_scale</code>函数。其中：</p>

<ul>
  <li>srcW:源图像的宽</li>
  <li>srcH:源图像的高</li>
  <li>srcFormat:源图像的格式</li>
  <li>dstW:目标图像的宽</li>
  <li>dstH:目标图像的高</li>
  <li>dstFormat:目标图像的格式</li>
  <li>flags:指定了使用何种算法和选项进行缩放</li>
</ul>

<p>编译时用<code>make examples</code>后生成 scaling_video 可执行文件。命令行如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ /scaling_video 001_bit_rv8_64P_352x288.yuv hd1080</span></code></pre></td></tr></table></div></figure>
<p>注意，输入时 YUV 数据，输出时 RGB 数据，会根据后面的 size 生成不同分辨率的数据。</p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">李冰</span></span>

      




<time class='entry-date' datetime='2017-01-01T08:17:10-07:00'><span class='date'>2017 年 01 月 01 日</span> <span class='time'>8:17 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ffmpegyuan-ma-fen-xi/'>ffmpeg源码分析</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/" data-via="" data-counturl="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/12/25/avformat_find_stream_info/" title="Previous Post: FFMPEG 源码分析：avformat_find_stream_info">&laquo; FFMPEG 源码分析：avformat_find_stream_info</a>
      
      
        <a class="basic-alignment right" href="/blog/2017/05/01/linux-tips/" title="Next Post: linux 使用小技巧总结">linux 使用小技巧总结 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
      <h1>分类目录</h1>
        <ul id="categories">
                <li class='category'><a href='/blog/categories/av1/'>av1 (8)</a></li>
<li class='category'><a href='/blog/categories/ffmpegyuan-ma-fen-xi/'>ffmpeg源码分析 (13)</a></li>
<li class='category'><a href='/blog/categories/hevc/'>hevc (8)</a></li>
<li class='category'><a href='/blog/categories/hmyuan-ma-fen-xi/'>hm源码分析 (5)</a></li>
<li class='category'><a href='/blog/categories/rtmpyuan-ma-fen-xi/'>rtmp源码分析 (2)</a></li>
<li class='category'><a href='/blog/categories/vmaf/'>vmaf (1)</a></li>
<li class='category'><a href='/blog/categories/x264/'>x264 (25)</a></li>
<li class='category'><a href='/blog/categories/xing-neng-you-hua/'>性能优化 (7)</a></li>
<li class='category'><a href='/blog/categories/zong-jie-ji-lei/'>总结积累 (9)</a></li>
<li class='category'><a href='/blog/categories/hui-bian-xue-xi/'>汇编学习 (8)</a></li>
<li class='category'><a href='/blog/categories/bian-cheng-gong-ju/'>编程工具 (7)</a></li>
<li class='category'><a href='/blog/categories/shi-pin-ji-chu/'>视频基础 (3)</a></li>
<li class='category'><a href='/blog/categories/lun-wen/'>论文 (2)</a></li>
<li class='category'><a href='/blog/categories/du-shu-bi-ji/'>读书笔记 (3)</a></li>
<li class='category'><a href='/blog/categories/xiang-mu-shi-jian/'>项目实践 (4)</a></li>

                  </ul>
</section>
<section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/11/01/h264-cabac-alogrithm/">H264 CABAC Alogrithm</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/10/16/overview-of-hevc-stand/">OverView of HEVC Standard</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/07/26/video-coding-with-h264-tools-performance-and-complexity/">H.264/AVC 视频编码：工具、性能和复杂性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/07/21/x264-rate-control-vbv-algorithm/">x264码率控制之VBV详解</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/06/22/h264-rate-control-algorithm/">H.264 Rate Control Algorithm</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>微博</h1>
  <ul id="weibo">
    <li>
        <iframe 
            width="100%" 
            height="350" 
            class="share_self"  
            frameborder="0" 
            scrolling="no" 
            src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=350&fansRow=0&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1882167025&verifier=64bf2e00&dpc=1">
        </iframe>
    </li>
  </ul">
</section>

<section>
    <h1>微信</h1>
    <img src="/images/weixin.png">
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.3/jquery.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){

      // hide #back-top first
      $("#back-top").hide();
        
        // fade in #back-top
        $(function () {
           $(window).scroll(function () {
                 if ($(this).scrollTop() > 100) {
                     $('#back-top').fadeIn();
                 } else {
                     $('#back-top').fadeOut();
                 }
           });

          // scroll body to 0px on click
          $('#back-top a').click(function () {
              $('body,html').animate({
                  scrollTop: 0
              }, 800);
              return false;
         });
     });

});
</script>

<style type="text/css">
#back-top {
      position: fixed;
      bottom: 50px;
      right: 100px;
}

#back-top a {
      width: 80px;
      display: block;
      text-align: center;
      font: 11px/100% Arial, Helvetica, sans-serif;
      text-transform: uppercase;
      text-decoration: none;
      color: #bbb;

      /* transition */
      -webkit-transition: 1s;
      -moz-transition: 1s;
      transition: 1s;
}
#back-top a:hover {
      color: #000;
}

/* arrow icon (span tag) */
#back-top span {
      width: 80px;
      height: 80px;
      display: block;
      margin-bottom: 7px;
      background: #ddd url(/images/top.png) no-repeat center center;

      /* rounded corners */
      -webkit-border-radius: 15px;
      -moz-border-radius: 15px;
      border-radius: 15px;

      /* transition */
      -webkit-transition: 1s;
      -moz-transition: 1s;
      transition: 1s;
}
#back-top a:hover span {
      background-color: #888;
}
</style>

<p id="back-top">
  <a href="#top"><span></span></a>
</p>

<p>
  Copyright &copy; 2021 - 李冰 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1259410454'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1259410454%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

<!-- MathJax -->  
<script type="text/x-mathjax-config">  
    MathJax.Hub.Config({  
                       tex2jax: {  
                       inlineMath: [ ['$','$'], ["\\(","\\)"] ],  
                       processEscapes: true  
                       }  
                       });  
    </script>  
  
<script type="text/x-mathjax-config">  
    MathJax.Hub.Config({  
                       tex2jax: {  
                       skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']  
                       }  
                       });  
    </script>  
  
<script type="text/x-mathjax-config">  
    MathJax.Hub.Queue(function() {  
                      var all = MathJax.Hub.getAllJax(), i;  
                      for(i=0; i < all.length; i += 1) {  
                      all[i].SourceElement().parentNode.className += ' has-jax';  
                      }  
                      });  
    </script>  
  
<script type="text/javascript"  
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">  
    </script>  

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
