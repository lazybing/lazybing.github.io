<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:汇编学习 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/hui-bian-xue-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-01-24T06:02:22-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NEON 编程3——矩阵相乘]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication/"/>
    <updated>2019-01-21T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">矩阵</a></li>
  <li><a href="#algorithm" id="markdown-toc-algorithm">语法(Algorithm)</a></li>
</ul>

<p>前面两篇分别介绍了如何使用 NEON 来加载和存储数据，如何使用 NEON 处理多余的数据。这一篇介绍一点儿使用的数据处理——矩阵相乘。</p>

<!--more-->

<h2 id="section">矩阵</h2>

<p>本篇文章会分析如何有效的完成4x4矩阵相乘，这种操作在 3D 图形中经常会用到。假设矩阵存放到内存中，并且是列优先的顺序，该格式在 OpenGL-ES 中使用。</p>

<h2 id="algorithm">语法(Algorithm)</h2>

<p>先详细的检测一下矩阵相乘的操作，通过把计算扩展开，并确定哪些子操作可以使用 NEON 指令实现。</p>

<p><img src="/images/neon_matrix_multiply/neon_matrix_multiply.png"></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程2——处理多余的数据]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers/"/>
    <updated>2019-01-20T00:56:44-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#fixing-up" id="markdown-toc-fixing-up">修复数据(Fixing Up)</a>    <ul>
      <li><a href="#larger-arrays" id="markdown-toc-larger-arrays">Larger Arrays</a>        <ul>
          <li><a href="#notes" id="markdown-toc-notes">Notes</a></li>
          <li><a href="#code-fragment" id="markdown-toc-code-fragment">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#overlapping" id="markdown-toc-overlapping">Overlapping</a>        <ul>
          <li><a href="#notes-1" id="markdown-toc-notes-1">Notes</a></li>
          <li><a href="#code-fragment-1" id="markdown-toc-code-fragment-1">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#single-elements" id="markdown-toc-single-elements">Single Elements</a>        <ul>
          <li><a href="#notes-2" id="markdown-toc-notes-2">Notes</a></li>
        </ul>
      </li>
      <li><a href="#further-considerations" id="markdown-toc-further-considerations">Further Considerations</a>        <ul>
          <li><a href="#beginning-or-end" id="markdown-toc-beginning-or-end">Beginning or End</a></li>
          <li><a href="#alignment" id="markdown-toc-alignment">Alignment</a></li>
          <li><a href="#using-arm-to-fix-up" id="markdown-toc-using-arm-to-fix-up">Using Arm to Fix Up</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>上一篇关于NEON 加载和存储的文章中，在NEON 处理单元（寄存器）和内存之间进行数据传输。这篇文章中，我们会处理经常遇到的问题：输入数据并不对齐，也就是输入数据的长度并不是向量长度的整数倍。我们需要在数组开始或结束的位置处理剩余的元素。使用 NEON 哪种方式最有效呢？</p>

<!--more-->

<p>使用 NEON 处理数据时，通常处理的数据向量的长度从 4 个元素到 16 个元素。通常情况下，你会发现数据的实际长度并不是切好等于寄存器向量长度的倍数，你必须单独处理剩余的元素。</p>

<p>例如，你想要使用 NEON 每次加载、处理、存储 8 个元素，但你的数组有 21 个元素的长度。前面 2 组能够正常处理，但对第 3 个，还剩下 5 个元素没有处理。你要怎么做呢？</p>

<h2 id="fixing-up">修复数据(Fixing Up)</h2>

<p>有三种方法来处理剩余的数据，三种方法的需求、性能和代码大小都不相同，分别是<code>Larger Arrays</code>、<code>Overlapping</code>、<code>Single Elements</code>，第一种方法效率最高。</p>

<h3 id="larger-arrays">Larger Arrays</h3>

<p>如何可以改变处理数组的大小，使用填充元素增加数组的长度到下一个向量大小的倍数，就可以读写超出数据本身的边界而不会影响相邻的存储。下面的例子中，增加元素到 24 个元素是的第三组可以很好地完成而不会有数据损坏。</p>

<p><img src="/images/neon_deal_leftovers/larger_array.png"></p>

<h4 id="notes">Notes</h4>

<ul>
  <li>分配更大的数组会消耗更大的内存。</li>
  <li>新的填充数据需要在初始化时给定一个值，该值不能够影响最后的计算结果。例如，如果是求和，填充数据就只能填充为 0.如果是要找到数组里面的最小值，可以设置填充数据为可以获取的最大值。</li>
  <li>某些情况下，没办法给定一个填充数据一个初始值，不影响最终结果，比如查找数据的范围时。</li>
</ul>

<h4 id="code-fragment">Code Fragment</h4>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ r0 = input array pointer
</span><span class='line'>@ r1 = output array pointer
</span><span class='line'>@ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ We can assume that the array length is greater than zero, is an integer
</span><span class='line'>@ number of vectors, and is greater than or equal to the length of data
</span><span class='line'>@ in the array.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>add r2, r2, #7      @ add (vector length - 1) to the data length
</span><span class='line'>lsr r2, r2, #3      @ divide the length of the array by the length
</span><span class='line'>                    @ of a vector, 8, to find the number of
</span><span class='line'>                    @ vectors of data to be processed loop:
</span><span class='line'>subs r2, r2, #1     @ decrement the loop counter, and set flags
</span><span class='line'>vld1.8 {d0}, [r0]!  @ load eight elements from the array pointed to
</span><span class='line'>                    @ by r0 into d0, and update r0 to point to the next vector
</span><span class='line'>...
</span><span class='line'>...                 @ process the input in d0
</span><span class='line'>...
</span><span class='line'>vst1.8 {d0}, [r1]!  @ write eight elements to the output array, and 
</span><span class='line'>                    @ update r1 to point to next vector
</span><span class='line'>bne loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="overlapping">Overlapping</h3>

<p>如果操作合适，剩余元素可以使用重叠的方法来处理。这会对数组中的某些元素进行两次处理。</p>

<p>示例中，第一组处理元素从0-7，第二组处理元素从5-12，第三组处理元素是13-20。注意，第5-7个元素，在第一次和第二次处理的向量中有重合，它们处理了两次。</p>

<p><img src="/images/neon_deal_leftovers/neon_overlapping.png"></p>

<h4 id="notes-1">Notes</h4>

<ul>
  <li>Overlapping 方法只有当输入数据的操作应用不会受操作次数的改变而改变时才能使用；例如，如果想要找到最大值可以使用该方法，而求和操作就不能使用该方法，因为 overlapping 会计算元素两次。</li>
  <li>数组中的元素数量至少能够填充一个完整的向量。</li>
</ul>

<h4 id="code-fragment-1">Code Fragment</h4>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ r0 = input array pointer
</span><span class='line'>@ r1 = output array pointer
</span><span class='line'>@ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ We can assume that the operation is idempotent, and the array is greater
</span><span class='line'>@ than or equal to one vector long.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>ands r3, r2, #7     @ calculate number of elements left over after
</span><span class='line'>                    @ processing complete vectors using
</span><span class='line'>                    @ data length &amp; (vector length - 1)
</span><span class='line'>beq loopsetup       @ if the result of the ands is zero, the length
</span><span class='line'>                    @ of the data is an integer number of vectors,
</span><span class='line'>                    @ so there is no overlap, and processing can begin at the loop
</span><span class='line'>                    @ handle the first vector separately
</span><span class='line'>vld1.8 {d0}, [r0], r3   @ load the first eight elements from the array,
</span><span class='line'>                        @ and update the pointer by the number of elements left over
</span><span class='line'>...
</span><span class='line'>...                     @ process the input in d0
</span><span class='line'>...
</span><span class='line'>vst1.8  {d0}, [r1], r3  @ wirte eight elements to the output array, and
</span><span class='line'>                        @ update the pointer
</span><span class='line'>                        @ now, set up the vector processing loop  loopsetup:
</span><span class='line'> lsr  r2, r2, #3      @ divide the length of the array by the length
</span><span class='line'>                         @  of a vector, 8, to find the number of
</span><span class='line'>                         @  vectors of data to be processed
</span><span class='line'> 
</span><span class='line'>                         @ the loop can now be executed as normal. the
</span><span class='line'>                         @  first few elements of the first vector will
</span><span class='line'>                         @  overlap with some of those processed above  loop:
</span><span class='line'> subs    r2, r2, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0}, [r0]!  @ load eight elements from the array, and update
</span><span class='line'>                         @  the pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class='line'>                         @  update the pointer
</span><span class='line'> bne  loop            @ if r2 is not equal to 0, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h3 id="single-elements">Single Elements</h3>

<p>NEON 提供的加载和存储指令可以对向量中的某个元素进行操作。使用这个操作，可以加载向量的单个元素，在上面执行操作，并把元素写会内存。</p>

<p>示例中的问题是，前面两组数据能够正常执行(0-7元素、8-15元素)。第三组需要处理剩余的 5 个元素，它们是单独的循环中处理的，每次都执行加载、处理和存储元素。</p>

<p><img src="/images/neon_deal_leftovers/neon_single_element.png"></p>

<h4 id="notes-2">Notes</h4>

<ul>
  <li>该方法比上面提到的方法要效率低，因为每个元素都单独执行加载、处理和存储。</li>
  <li>处理剩余的元素需要两个循环——一个是向量、另一个是单个元素，这回增加函数中的代码量</li>
</ul>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ r0 = input array pointer
</span><span class='line'> @ r1 = output array pointer
</span><span class='line'> @ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code> lsrs    r3, r2, #3      @ calculate the number of complete vectors to be
</span><span class='line'>                         @  processed and set flags
</span><span class='line'> beq  singlesetup  @ if there are zero complete vectors, branch to
</span><span class='line'>                         @  the single element handling code
</span><span class='line'> 
</span><span class='line'>                         @ process vector loop  vectors:
</span><span class='line'> subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0}, [r0]!  @ load eight elements from the array and update
</span><span class='line'>                         @  the pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class='line'>                         @  update the pointer
</span><span class='line'> bne  vectors      @ if r3 is not equal to zero, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>singlesetup:
</span><span class='line'>     ands    r3, r2, #7      @ calculate the number of single elements to process
</span><span class='line'>     beq  exit            @ if the number of single elements is zero, branch
</span><span class='line'>                             @  to exit&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                         @ process single element loop  singles:
</span><span class='line'> subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0[0]}, [r0]!  @ load single element into d0, and update the
</span><span class='line'>                         @  pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0[0]
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0[0]}, [r1]!  @ write the single element to the output array,
</span><span class='line'>                         @  and update the pointer
</span><span class='line'> bne  singles      @ if r3 is not equal to zero, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>exit:&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h3 id="further-considerations">Further Considerations</h3>

<h4 id="beginning-or-end">Beginning or End</h4>

<p>Overlapping 和 single element 技术可以应用到处理数组的开始或结束位置。如何应用程序更适合处理结束端，上面的代码可以很容易的改成处理末端的元素。</p>

<h4 id="alignment">Alignment</h4>

<p>加载和存储地址应该与高速缓存线对齐，这样会使得内存访问更加高效。</p>

<p>对于 Cortex-A8，至少要 16 字节对齐，如果在输入或输出数组的开始位置没有对齐，就必须在数组的开始和结束位置处理元素。</p>

<p>当对齐内存来加速时，记得使用加载和存储指令时加上<code>:64</code>或<code>:128</code>或<code>:256</code>。</p>

<h4 id="using-arm-to-fix-up">Using Arm to Fix Up</h4>

<p>在使用<code>single elements</code>方法时，你可以使用 Arm 指令来对每个元素进行单独处理。然而，同时使用 Arm 指令和 NEON 指令来存储相同的内存会降低效率，因为通过 Arm 管道来写必须在 NEON 管道写完后才能进行。</p>

<p>一般情况下，应该避免同时使用 Arm 和 NEON 代码写到相同的内存区域，尤其是同一个高速缓存区域。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程1——加载和存储]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store/"/>
    <updated>2019-01-19T06:53:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">技术细节</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">概述</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">语法</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">交错存取模式</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">元素类型</a></li>
          <li><a href="#sigle-or-multiple-elements" id="markdown-toc-sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</a></li>
          <li><a href="#addressing" id="markdown-toc-addressing">寻址(Addressing)</a></li>
        </ul>
      </li>
      <li><a href="#section-6" id="markdown-toc-section-6">其他存取指令</a></li>
    </ul>
  </li>
</ul>

<p>ARM NEON 技术是 64/128 位的混合 SIMD 架构，它的设计目的就是为了提高多媒体和信号处理应用的性能，包括视频编解码、音频编解码、3D 图像、声音和图像处理。</p>

<!--more-->

<p>针对如何利用汇编语言为 NEON 编写 SIMD，后面会出一系列文章，本篇为第一部分。该系列文章会包含如何开始 NEON，如何高效使用它，后面还会介绍编写更复杂代码的技巧。我们先从操作内存开始，以及如何利用序列指令，灵活的使用 load 和 store。</p>

<h2 id="section">示例</h2>

<p>我们从一个具体的示例开始。假设你有一个 24bit RGB 图像，像素在内存中的排列格式为 R,G,B,R,G,B…，假设你想要将其中的 R 和 B 进行交换，该如何利用 NEON，是的操作更加高效呢？</p>

<p>采用简单的线性 load 指令从内存中复制到寄存器里面，然后进行R/B 调换操作，会比较繁琐。示例如图</p>

<p><img src="/images/neon_load_store/linear_load_rgb.png"></p>

<p>基于上图中的输入，进行分割、移位、合并这种方法去交换通道会很麻烦，效率低下。</p>

<p>NEON 针对此种应用场景提供了结构化的加载和存储指令，它们会从内存中加载数据的同时将数据分发到不同的寄存器。如上面例子中，VLD3 指令可以分别将加载的 R/G/B数据分别放到三个不同的寄存器中。</p>

<p><img src="/images/neon_load_store/structed_load_rgb.png"></p>

<p>现在，只要交换R/B寄存器的内容(VSWP d0, d2),之后用类似的存储指令 VST3 将数据写会内存中即可。</p>

<h2 id="section-1">技术细节</h2>

<h3 id="section-2">概述</h3>

<p>NEON 结构化加载指令从内存中读取数据进入 64 位 NEON 寄存器，可以选择是否交错读取；同样的，存储指令将寄存器中的数据可以交错写回到内存中。</p>

<p><img src="/images/neon_load_store/neon_structure_loads_stores.png"></p>

<h3 id="section-3">语法</h3>

<p>结构化加载和存取指令的语法结构有 5 部分组成。</p>

<p><img src="/images/neon_load_store/neon_load_store_syntax.png"></p>

<ul>
  <li>指令助记符，VLD 用于加载，VST 用于存储。</li>
  <li>交错存取的模式，此数字指定了相关元素之间的距离。</li>
  <li>访问的元素类型，该类型指定了元素的位宽。</li>
  <li>需要读取或者写入的寄存器集合，最大为4， 取决于交错存取的模式。</li>
  <li>ARM 地址寄存器，包含需要访问的内存地址。</li>
</ul>

<h4 id="section-4">交错存取模式</h4>

<p>NEON 指令能够加载和存储数据并以交错方式加载或存储1-4个相同位宽的元素，NEON 支持8、16、32bit的交错存取元素。</p>

<ul>
  <li>VLD1 是最简单的一种形式，该指令能从内存中线性加载数据到1-4个寄存器中，一般用于无交错存取的数据处理。</li>
  <li>VLD2 可以从内存中加载数据到 2 或 4 个寄存器中，将交错的奇数和偶数项的数据分别加载到不同的寄存器中，一般用于立体声的左右声道的分离。</li>
  <li>VLD3 加载交错距离为 3 的数据到 3 个寄存器中，一般用于图像中 RGB 通道的分离。</li>
  <li>VLD4 加载交错距离为 4 的数据到 4 个寄存器中，一般用于图像中 ARGB 通道的分离。</li>
</ul>

<p>存储指令类似加载指令，但是在写入到内存之前就已经完成了数据元素交错。</p>

<h4 id="section-5">元素类型</h4>

<p>交错元素的存取规则取决于指令本身。例如，使用 VLD2.16 加载数据，完成操作后，共加载 8 个 16bit 的元素，其中偶数项元素加载到第一个寄存器，奇数项元素加载到第二个寄存器中。</p>

<p><img src="/images/neon_load_store/100310_MC_diag3-1.png"></p>

<p>元素大小变成 32 之后，加载同样大小的数据(4x32),然而每个寄存器中只有2个元素(2x32)，与 VLD2.16 一样，VLD2.32 同样是偶数项元素加载到第一个寄存器中，奇数项元素加载到第二个寄存器中。</p>

<p><img src="/images/neon_load_store/100310_MC_diag3a-1.png"></p>

<p>元素大小还会影响字节顺序，一般来讲，如果你是在存取指令中指定了正确的元素大小，从内存中读取的字节顺序将符合你的语气，并且相同的代码能在大端或者小端系统上运行良好。</p>

<p>最后，元素大小对于指针对齐也有一定的影响，指针地址对齐到元素大小将具有更好的性能，例如，当加载 32 位的元素时，内存首地址最小要对齐 32 位。</p>

<h4 id="sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</h4>

<p>除了一次加载多个元素外，结构化的加载指令还能够一次从内存中读取一个元素，并且交错的放到不同的寄存器中，或者是放到寄存器的所有通道中，或者是放到寄存器的单个通道，其他通道不受影响。</p>

<p><img src="/images/neon_load_store/deinterleaving_vector_lanes.png"></p>

<p>后面的描述对于从散乱的内存中构造出一个 vector 比较有用。</p>

<p><img src="/images/neon_load_store/deinterleaving_single_vect.png"></p>

<p>存储指令和读取指令类似。</p>

<h4 id="addressing">寻址(Addressing)</h4>

<p>结构化的加载和存取指令支持 3 种格式来指定地址。</p>

<ul>
  <li><code>Register:[{,:}]</code>,这是最简单的寻址方式，数据在指定地址中进行存取</li>
  <li><code>Register with increment after:[{,:}]!</code>, 这种寻址方式在完成数据加载后将更新指针使其指向之后待处理的元素，指针的增长大小与指令存取的字节数一致。</li>
  <li><code>Register with post-index:[{,:}]</code>，这种寻址方式在完成数据存取之后将改变指针，指针增加指定量（由寄存器 Rm 指定），这种方式在存取元素分散在固定距离的情况下比较方便，如读取图像的一列像素。</li>
</ul>

<p>同样的，也可以通过指定 Rn 来指定指针的对齐，使用 optional:parameter 这样同样能加快内存的读取。</p>

<h3 id="section-6">其他存取指令</h3>

<p>这里只介绍了结构化的存取指令，NEON 还提供了如下指令：</p>

<ul>
  <li>VLDR 和 VSTR，存取单个 64 位寄存器</li>
  <li>VLDM 和 VSTM，加载多个 64 位寄存器，方便从栈上存取数据。</li>
</ul>

<p>更多关于加载和存取操作的细节，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406b/index.html&amp;_ga=2.76337745.535197283.1547875098-60705264.1529324001">Arm Architecture Reference Manual</a>, 关于每条指令所占用的时钟周期数，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexa/index.html&amp;_ga=2.41000550.535197283.1547875098-60705264.1529324001">Technical Reference Manual for each core</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 技术概述]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-technology-overview/"/>
    <updated>2019-01-19T00:10:40-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-technology-overview</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#neon-" id="markdown-toc-neon-">NEON 概述</a></li>
  <li><a href="#neon" id="markdown-toc-neon">如何使用 NEON</a>    <ul>
      <li><a href="#neon--1" id="markdown-toc-neon--1">NEON 库</a>        <ul>
          <li><a href="#arm-" id="markdown-toc-arm-">用于机器学习和计算机视觉的 Arm 计算库</a></li>
        </ul>
      </li>
      <li><a href="#autovectorization" id="markdown-toc-autovectorization">AutoVectorization（自动向量化）</a></li>
      <li><a href="#compiler-intrinsics-" id="markdown-toc-compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</a></li>
      <li><a href="#assembly-code" id="markdown-toc-assembly-code">Assembly Code(汇编代码)</a></li>
    </ul>
  </li>
  <li><a href="#section" id="markdown-toc-section">开发工具</a></li>
  <li><a href="#neon--2" id="markdown-toc-neon--2">NEON 生态系统</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">参考资源:</a></li>
</ul>

<p>ARM NEON 技术是针对<code>Arm Cortex-A/R52</code>系列处理器的一种高级 SIMD 架构扩展。NEON 技术在 Armv7-A 和 Armv7-R 架构时开始引入，现在同样是 Armv8-A 和 Armv8-R 架构的扩展。</p>

<p>NEON 技术使用场景非常多，例如通过提高音视频编解码速度来提供更好的多媒体体验、加速数字信号处理算法和功能来加速音视频处理的应用、语音和面部识别、计算机视觉和深度学习。</p>

<!--more-->

<p><img src="/images/neon_overview/SIMDArchitecture-20.png"></p>

<h2 id="neon-">NEON 概述</h2>

<p>NEON 技术是一个打包的 SIMD 架构。NEON 寄存器是相同数据类型的向量元素，它可以支持多种数据类型。下表描述了不同架构版本支持的数据类型：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Armv7-A/R</th>
      <th style="text-align: center">Armv8-A/R</th>
      <th style="text-align: center">Armv8-A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Floating point</td>
      <td style="text-align: center">32-bit</td>
      <td style="text-align: center">16-bit*/32-bit</td>
      <td style="text-align: center">16-bit*/32-bit/64-bit</td>
    </tr>
    <tr>
      <td style="text-align: center">Integer</td>
      <td style="text-align: center">8-bit/16-bit/32-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
    </tr>
  </tbody>
</table>

<p>NEON 指令针对向量中的所有通道执行相同的操作，操作的个数会根据不同数据类型而不同。NEON 指令允许下面的类型：</p>

<ul>
  <li>16x8-bit, 8x16-bit, 4x32-bit, 2x64-bit整形操作</li>
  <li>8x16-bit*, 4x32-bit, 2x64-bit** 浮点型操作</li>
</ul>

<p>其中<code>*</code>代表只存在于 Armv8.2-A 架构中，<code>**</code>代表只存在于 Armv8-A/R 架构中。</p>

<p>NEON 技术也能够支持多个指令并行发布。</p>

<h2 id="neon">如何使用 NEON</h2>

<p>NEON 的使用方式有多种，比如使用 NEON 库、编译器的 auto-vectorization 功能、NEON intrinsics（内联函数）、NEON 汇编代码。
关于 NEON 编程的详细信息可以参考<a href="https://static.docs.arm.com/den0018/a/DEN0018A_neon_programmers_guide_en.pdf?_ga=2.112843328.535197283.1547875098-60705264.1529324001">NEON 编程指南</a>.</p>

<h3 id="neon--1">NEON 库</h3>

<p>利用 NEON 的最简单的方式就是使用已经使用了 NEON 的开源库。</p>

<h4 id="arm-">用于机器学习和计算机视觉的 Arm 计算库</h4>

<p>Arm 计算库的目标是对于图像处理、计算机视觉和机器学习，它包含一些列针对 Arm CPU 和 GPU 架构的低级优化。更多信息可以访问<a href="https://developer.arm.com/technologies/compute-library">compue-library</a>.</p>

<p>Ne10 是一个开源的 C 库，由 arm 公司在 github 上维护，它包含了一组最常用的功能，这些功能都已经为 arm 做了专项优化。Ne10 是一个模块化结构，包含了很多小的库，目前包含的主要功能有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Math functions</th>
      <th style="text-align: center">Signal Processing functions</th>
      <th style="text-align: center">Image processing functions</th>
      <th style="text-align: center">Physics functions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Vector Add</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center">Image Resize</td>
      <td style="text-align: center">Collision Detection</td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix-Add</td>
      <td style="text-align: center">Complex-to-Complex FFT</td>
      <td style="text-align: center">Image Rotate</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract From</td>
      <td style="text-align: center">Real-to-Complex FFT</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix Subtract</td>
      <td style="text-align: center">FIR Filters</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>libyuv 是一个开源项目库，它包含了 YUV 缩放和转换功能。</p>

<p>skia 库是一个针对 2D 图像的开源库，用作 谷歌 Chrome 和 Chrome OS, Android、Mozilla Firefox 和 Firefox OS 以及其他许多产品的图形引擎。</p>

<h3 id="autovectorization">AutoVectorization（自动向量化）</h3>

<p>auto-vectorization 特性是由 arm 编译器支持的，编译器会自动利用 NEON 功能。支持该特性的编译器有:</p>

<ul>
  <li>Arm Compiler 5</li>
  <li>Arm LLVM-based Compiler 6</li>
  <li>GCC</li>
</ul>

<p>NEON 编程指南在 arm 编译器使用用户指导部分同样对于 NEON 选项提供了额外的指导。</p>

<h3 id="compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</h3>

<p>使用内联函数，编译器会在编译时将内联函数替换成一条或几条对应的 NEON 指令。内联函数提供的功能与汇编语言差不多，但将寄存器的使用交给了编译器，
所以开发者可以专注在算法上。它同样可以执行指令调度从而移除指定目标处理器的流水线停顿。内联函数的可维护性比汇编语言更好，支持内联函数的编译器包括 ARM 编译器、GCC 编译器和 LLVM 编译器。</p>

<p>更多关于 Intrinsics 的信息，可以参考<a href="https://developer.arm.com/technologies/neon/intrinsics">Arm NEON Intrinsics Reference document</a>,该参考文档记录了 Armv7 和 Armv8 架构的 NEON Intrinsics 使用方法。示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;arm_neon.h&gt;</span>
</span><span class='line'><span class="kt">uint32x4_t</span> <span class="nf">double_elements</span><span class="p">(</span><span class="kt">uint32x4_t</span> <span class="n">input</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">vaddq_u32</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></arm_neon.h></p>

<h3 id="assembly-code">Assembly Code(汇编代码)</h3>

<p>为例更高的性能，NEON 汇编代码是最好的方法，只要支持 NEON instructions 的编译器，GNU 编译器(gas) 和 ARM 编译器(armasm) 都支持汇编代码。</p>

<h2 id="section">开发工具</h2>

<p><code>Arm DS-5 Development Studio</code>为基于 Arm 平台提供了用于 C/C++ 软件开发的端到端的工具套件，DS-5 从编程到调试对 NEON 架构提供了全支持。DS-5 调试器提供 NEON 指令的完整调试功能和架构寄存器的可视化。DS-5 调试器支持所有 Arm 架构配置文件和处理器。</p>

<p><img src="/images/neon_overview/DS5.png"></p>

<h2 id="neon--2">NEON 生态系统</h2>

<p>NEON 在如下表格所示的领域内有广泛的使用，其中包含了很多跨平台的开源项目：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Video Codecs</th>
      <th style="text-align: center">Audio Codecs</th>
      <th style="text-align: center">Voice and speech codecs</th>
      <th style="text-align: center">Audio enhancement algorithms</th>
      <th style="text-align: center">Computer Vision</th>
      <th style="text-align: center">Machine and deep leaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">VP9 OTT encoder, VP9 Consumer encoder/decoder</td>
      <td style="text-align: center">MP3 encoder/decoder</td>
      <td style="text-align: center">G.711</td>
      <td style="text-align: center">Echo cancellation</td>
      <td style="text-align: center">Canny Edge detection</td>
      <td style="text-align: center">On-device object recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">H.264(AVC) encoder/decoder</td>
      <td style="text-align: center">MPEG-2 layer I&amp;II encoder/decoder</td>
      <td style="text-align: center">G.722, G.722.1, G.722.2</td>
      <td style="text-align: center">Noise Reduction</td>
      <td style="text-align: center">Harris Corner</td>
      <td style="text-align: center">On-device scene recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG4 SP/ASP encoder/decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder</td>
      <td style="text-align: center">G.723.1</td>
      <td style="text-align: center">Beam Forming</td>
      <td style="text-align: center">ORB</td>
      <td style="text-align: center">Human pose recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG2 decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder /decoder</td>
      <td style="text-align: center">G.726</td>
      <td style="text-align: center">Comfort Noise</td>
      <td style="text-align: center">Convolution filter</td>
      <td style="text-align: center">Defect detection</td>
    </tr>
    <tr>
      <td style="text-align: center">H.263 decoder</td>
      <td style="text-align: center">HE-AACv1, v2 encoder/decoder</td>
      <td style="text-align: center">G.727</td>
      <td style="text-align: center">AudioZoom</td>
      <td style="text-align: center">Erosion/Dilation</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Standart encoder/decoder</td>
      <td style="text-align: center">G.728</td>
      <td style="text-align: center">Equalization</td>
      <td style="text-align: center">Face detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Pro, WMA Lossless decoder</td>
      <td style="text-align: center">G.729, G.279A, G.729B</td>
      <td style="text-align: center">Wind noise reduction</td>
      <td style="text-align: center">Pedestrian detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">SBC Bluetooth encoder/decoder</td>
      <td style="text-align: center">G.729AB</td>
      <td style="text-align: center">Automatic Gain Control</td>
      <td style="text-align: center">Fast9/Fast12 corner detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">OggVorbis encoder/decoder</td>
      <td style="text-align: center">AMR Narrowband, Wideband, Wideband+</td>
      <td style="text-align: center">Voice Activity Detection</td>
      <td style="text-align: center">Object tracking</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
  </tbody>
</table>

<p>有关 NEON 生态系统的更多合作伙伴可以参考 <a href="https://developer.arm.com/technologies/dsp/arm-dsp-ecosystem-partners">DSP Ecosystem Partners page</a>。</p>

<h2 id="section-1">参考资源:</h2>

<ol>
  <li><a href="https://www.youtube.com/watch?v=ixuDntaSnHI">Taming Armv8 NEON:from theory to benchmark results</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores">Coding for NEON - Part 1: Load and Stores</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-2-dealing-with-leftovers">Coding for NEON - Part 2: Dealing With Leftovers</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-3-matrix-multiplication">Coding for NEON - Part 3: Matrix Multiplication</a>.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汇编语言实现hello World]]></title>
    <link href="http://lazybing.github.io/blog/2018/01/11/assemble-hello-world/"/>
    <updated>2018-01-11T21:29:27-08:00</updated>
    <id>http://lazybing.github.io/blog/2018/01/11/assemble-hello-world</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#write-our-string-to-stdout" id="markdown-toc-write-our-string-to-stdout">write our string to stdout</a></li>
  <li><a href="#and-exit" id="markdown-toc-and-exit">and exit</a></li>
</ul>

<p>接下来的工作可能要用到汇编语言。</p>

<!--more-->

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.data                   # section declaration
</span><span class='line'>msg:
</span><span class='line'>    .ascii  “Hello, world!\n”   # our dear string
</span><span class='line'>    len = . - msg               # length of our dear string&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>.text                           # section declaration&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                        # we must export the entry point to the ELF linker or
</span><span class='line'>.global _start          # loader. They conventionally recognize _start as their 
</span><span class='line'>                        # entry point. Use ld -e foo to override the default.
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>_start:&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="write-our-string-to-stdout">write our string to stdout&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>movl $len, %edx        # third argument:message length
</span><span class='line'>movl $msg, %ecx        # second argument:pointer to message to write
</span><span class='line'>movl $1, %ebx          # first argument:file handle(stdout) 
</span><span class='line'>movl $4, %eax          # system call number (sys_write)
</span><span class='line'>int  $0x80             # call kernel
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1 id="and-exit">and exit&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>movl $0, %ebx           # first argument:exit code
</span><span class='line'>movl $1, %eax           # system call number (sys_exit)
</span><span class='line'>int  $0x80              # call kernel
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
</feed>
