<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:汇编学习 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/hui-bian-xue-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-04-14T00:31:40-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARM64 汇编指令总结]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/24/neon-of-coding/"/>
    <updated>2019-01-24T06:35:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/24/neon-of-coding</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#sqdmulhvectorby-element" id="markdown-toc-sqdmulhvectorby-element">SQDMULH(vector/by element)</a></li>
  <li><a href="#sqrdmulhvectorby-element" id="markdown-toc-sqrdmulhvectorby-element">SQRDMULH(vector/by element)</a></li>
  <li><a href="#sqrshrun-sqrshrun2" id="markdown-toc-sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</a></li>
  <li><a href="#sqshrun-sqshrun2" id="markdown-toc-sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</a></li>
  <li><a href="#shl" id="markdown-toc-shl">SHL</a></li>
  <li><a href="#shll-shll2" id="markdown-toc-shll-shll2">SHLL, SHLL2</a></li>
  <li><a href="#sshll-sshll2" id="markdown-toc-sshll-sshll2">SSHLL, SSHLL2</a></li>
  <li><a href="#ushll-ushll2" id="markdown-toc-ushll-ushll2">USHLL, USHLL2</a></li>
  <li><a href="#trn1--trn2" id="markdown-toc-trn1--trn2">TRN1 &amp; TRN2</a></li>
  <li><a href="#sxtl-sxtl2" id="markdown-toc-sxtl-sxtl2">SXTL, SXTL2</a></li>
  <li><a href="#uxtl-uxtl2" id="markdown-toc-uxtl-uxtl2">UXTL, UXTL2</a></li>
  <li><a href="#ext" id="markdown-toc-ext">EXT</a></li>
  <li><a href="#bfm-ubfm-sbfmbitfield-move" id="markdown-toc-bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</a></li>
  <li><a href="#srshr" id="markdown-toc-srshr">SRSHR</a></li>
</ul>

<p>ARMv8 指令集可以大致分为三类:A64 指令集、A32&amp;T32 指令集。</p>

<p>ARM 汇编真的太痛苦了。。。一个命令一个命令的学习记录吧</p>

<!--more-->

<p>指令格式：</p>

<p><code>&lt;Opcode&gt;[&lt;Cond&gt;]&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; [.&lt;Opcode2&gt;]</code></p>

<ul>
  <li>其中尖括号的选项是必须的，花括号是可选的。</li>
  <li>A32 : Rd==&gt;{R0-R14}</li>
  <li>A64 : Rd==&gt;Xt==&gt;{X0-X30}</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标识符</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Opcode</td>
      <td style="text-align: center">操作码，也就是助记符，说明指令需要执行的操作类型</td>
    </tr>
    <tr>
      <td style="text-align: center">Cond</td>
      <td style="text-align: center">指令执行条件码，在编码中占4bit, 0b000-0b1110</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">条件码设置项，决定本次指令是否影响 PSTATE 寄存器响应状态位值</td>
    </tr>
    <tr>
      <td style="text-align: center">Rd/Xt</td>
      <td style="text-align: center">目标寄存器，A32 指令可以选择 R0-R14，T32指令大部分只能选择R0-R7,A64指令可以选择X0-X30 或 W0-W30</td>
    </tr>
    <tr>
      <td style="text-align: center">Rn/Xn</td>
      <td style="text-align: center">第一个操作数的寄存器，和 Rd 一样，不同指令有不同要求</td>
    </tr>
    <tr>
      <td style="text-align: center">Opcode2</td>
      <td style="text-align: center">第二个操作数，可以是立即数，寄存器Rm 和寄存器移位方式(Rm, #shift)</td>
    </tr>
  </tbody>
</table>

<h2 id="sqdmulhvectorby-element">SQDMULH(vector/by element)</h2>

<p>Signed saturating Doubling Multiply return High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;T&gt;</code>:4H/8H/2S/4S 中的一个</li>
</ul>

<p>示例</p>

<ul>
  <li>sqdmulh v0.8h, v0.8h, v30.8h</li>
</ul>

<p>Signed saturation Doubling Multiply return High half(by element).该指令将第一个源寄存器的每个矢量元素乘以第二个源寄存器的某个特定矢量元素，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrdmulhvectorby-element">SQRDMULH(vector/by element)</h2>

<p>Signed saturating Rounding Doubling Multiply returning High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</h2>

<p>Signed saturating Rounded Shift Right Unsigned Narrow(immediate).</p>

<p>Scalar:</p>

<p><code>SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>sqrshrun v0.8b, v1.8h, #5</li>
</ul>

<p>Vector:</p>

<p><code>SQRSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</h2>

<p>Signed saturating Shift Right Unsigned Narror(immediate).</p>

<p>Scalar:</p>

<p><code>SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SQSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="shl">SHL</h2>

<p>Shift Left(immediate)。</p>

<p>Scalar:</p>

<p><code>SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<h2 id="shll-shll2">SHLL, SHLL2</h2>

<p>Shift Left Long(by element size)。</p>

<p>Vector:</p>

<p><code>SHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li>
    <p><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</p>
  </li>
  <li>shll  v28.8h, v30.8b,  #8</li>
  <li>shll2 v29.8h, v30.16b, #8</li>
</ul>

<h2 id="sshll-sshll2">SSHLL, SSHLL2</h2>

<p>Signed Shift Left Long(immediate)。</p>

<p><code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="ushll-ushll2">USHLL, USHLL2</h2>

<p>Unsigned Shift Left Long(immediate)。</p>

<p><code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="trn1--trn2">TRN1 &amp; TRN2</h2>

<p>TRN1:转置向量 Transpose vector(primary), 该指令从零开始读取两个源寄存器 SIMD&amp;FP 的相应偶数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn1 v4.2d, v4.2d, v5.2d</li>
</ul>

<p>TRN2:转置向量 Transpose vectors(secondary)。该指令读取两个源寄存器 SIMD&amp;FP 的相应奇数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>T</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn2 v7.2s, v5.2s, v7.2s</li>
</ul>

<p><img src="/images/neon_coding/trn.png"></p>

<h2 id="sxtl-sxtl2">SXTL, SXTL2</h2>

<p>SXTL:Signed extend Long,该指令</p>

<p>Vector:</p>

<p><code>SXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>sxtl v0.8h, v0.8b</li>
</ul>

<h2 id="uxtl-uxtl2">UXTL, UXTL2</h2>

<p>UXTL:Unsigned extend Long.</p>

<p>Vector:</p>

<p><code>UXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>uxtl v4.8h, v4.8b</li>
</ul>

<h2 id="ext">EXT</h2>

<p>EXT:Extract vector from pair of vectors.</p>

<p>Advanced SIMD variant</p>

<p><code>EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</code></p>

<p><img src="/images/neon_coding/ext.png"></p>

<p>示例：</p>

<ul>
  <li>ext v5.16b, v4.16b, v4.16b, #2</li>
</ul>

<h2 id="bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</h2>

<p>BFM:</p>

<p>32-bit variant</p>

<p><code>BFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>SBFM:</p>

<p>32-bit variant</p>

<p><code>SBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>UBFM:</p>

<p>32-bit variant</p>

<p><code>UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>示例：</p>

<ul>
  <li>ubfm w9, w5, #7, #13</li>
</ul>

<h2 id="srshr">SRSHR</h2>

<p>SRSHR:Signed Rounding Shift Right(immediate)。</p>

<p>Scalar variant:</p>

<p><code>SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SRSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>srshr v24.8h, v24.8h, #2</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程4——左右移位]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right/"/>
    <updated>2019-01-22T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">向量移位</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">移位与插入</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">移位与计算</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">指令修改器</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可用移位表</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">示例：转换颜色深度</a>    <ul>
      <li><a href="#section-6" id="markdown-toc-section-6">从 565 到 888</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">从888到565</a></li>
    </ul>
  </li>
  <li><a href="#section-8" id="markdown-toc-section-8">结论</a></li>
</ul>

<p>本文将介绍 NEON 提供的移位运算，并介绍如何利用移位运算在常用颜色深度之间转换影像数据。本系列前期已发布的文章包括：第一部分：加载与存储，第二部分：余数的处理，第三部分：矩阵乘法。</p>

<!--more-->

<h2 id="section">向量移位</h2>

<p>NEON 上的移位与标量 ARM 编码中可能用到的移位非常相似，即每个向量元素的位数均向左或向右移位，出现在每个元素左侧与右侧的位将被删除；它们不能移位至相连的元素。</p>

<p><img src="/images/neon_shift_left_right/shift_vector.png"></p>

<p>带符号元素的向量上发生的右移位由指令附加的类型指定，并会将符号扩展至每一个元素。这与 ARM 编码中可能用到的算术移位相同。应用到无符号向量的移位不会发生符号扩展。</p>

<h2 id="section-1">移位与插入</h2>

<p>NEON 也支持通过插入产生移位，使两个不同向量的位相结合。例如，左移位与插入（VSLI）可使源向量的每一个元素均向左移位。每个元素右侧新插入的位就是目标向量中的对应为。</p>

<p><img src="/images/neon_shift_left_right/shift_insert.png"></p>

<h2 id="section-2">移位与计算</h2>

<p>最后，NEON 还支持向量元素向右移位，并将结果计入到另一个向量中。这种方法对于先在高精度条件下进行临时计算，然后再将结果与低精度计算器相结合的情况非常有用。</p>

<h2 id="section-3">指令修改器</h2>

<p>每个移位指令都能拥有一个或多个修改器。这些修改器并不改变移位运算本身，而是通过调整输入值与输出值，消除偏差或饱和状态，保持一定的范围。共有五种移位修改器：</p>

<ul>
  <li>舍位修改器(Rounding)，以 R 前缀表示，可以纠正右移时舍位导致的偏差。</li>
  <li>窄修改器(Narrow)，以 N 后缀表示，可以让结果中每个元素的位数减半。它代表Q(128位)源和D(64位)目标寄存器。</li>
  <li>长修改器(Long),以 L 后缀表示，可以让结果中每个元素的位数加倍。它代表D源和Q目标寄存器。饱和修改器(Saturating)，以Q前缀表示，可以在最大和最小可表示范围内设置每个结果元素，前提是结果未超出该范围。向量的位数和符号类型可用于确定饱和范围。</li>
  <li>无符号饱和修改器(Unsigned Saturationg)，以Q前缀和U后缀表示，与饱和修改器类似，但在进行带符号与无符号输入时，结果将在无符号范围内表示为饱和。</li>
</ul>

<p>这些修改器的部分组合并未表现出有用的运算，因此 NEON 也没有提供相应指令。例如，饱和右移位（应称为 VQSHR）其实就毫无必要，因为右移位只会让结果变得更小，因而值根本无法超出有效范围。</p>

<h2 id="section-4">可用移位表</h2>

<p>NEON 提供的所有移位指令均在下表中列出。它们根据先前提到的修改器进行排列。如果你还是不太确定修改器各个字母代表的含义，请利用下表选择需要的指令。</p>

<p><img src="/images/neon_shift_left_right/shift_table_avaliable.png"></p>

<h2 id="section-5">示例：转换颜色深度</h2>

<p>颜色深度之间的转换是图形处理中经常需要的运算。通常，输入或输出数据都是 RGB565 16 位颜色格式，但 RGB888 格式的数据处理起来更为方便。对于 NEON 而言尤其如此，因为它无法为 RGB565 这样的数据类型提供本机支持。</p>

<p><img src="/images/neon_shift_left_right/color_format.png"></p>

<p>但是，NEON 仍然可以有效地处理 RGB565 数据，上文中介绍的向量移位便提供了处理方法。</p>

<h3 id="section-6">从 565 到 888</h3>

<p>首先，我们来看如何将 RGB565 转换为 RGB888。假设寄存器 q0 中有 8 个 16 位像素，我们想要在 d2、d3和d4这三个寄存器中将红色、绿色和蓝色分离成 8 位的元素。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='asm'><span class='line'><span class="nf">vshr.u8</span>     <span class="no">q1</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift red elements right by three bits,</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">at</span> <span class="no">the</span> <span class="no">bottom</span> <span class="no">of</span> <span class="no">the</span> <span class="no">red</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class='line'><span class="nf">vshrn.i16</span>   <span class="no">d2</span><span class="p">,</span> <span class="no">q1</span><span class="p">,</span> <span class="c">#5  @shift red element right and narrow,</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits.</span>
</span><span class='line'><span class="nf">vshrn.i16</span>   <span class="no">d3</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#5  @shift green elements right and narrow,</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">bits</span> <span class="no">and</span> <span class="no">some</span> <span class="no">red</span> <span class="no">bits</span> <span class="no">due</span> <span class="no">to</span> <span class="no">narrowing.</span>
</span><span class='line'><span class="nf">vshl.i8</span>     <span class="no">d3</span><span class="p">,</span> <span class="no">d3</span><span class="p">,</span> <span class="c">#2  @shift green elements left, discarding the remaining red bits,</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">and</span> <span class="no">placing</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">in</span> <span class="no">the</span> <span class="no">correct</span> <span class="no">place.</span>
</span><span class='line'><span class="nf">vshl.i16</span>    <span class="no">q0</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift blue elements left to most-significant </span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">color</span> <span class="no">channel.</span>
</span><span class='line'><span class="nf">vmovn.i16</span>   <span class="no">d4</span><span class="p">,</span> <span class="no">q0</span>      <span class="err">@</span><span class="no">remove</span> <span class="no">remaining</span> <span class="no">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">by</span> <span class="no">narrowing</span> <span class="no">to</span> <span class="mi">8</span> <span class="no">bits</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>每个指令的效果都在上面备注中做了描述，但总而言之，每个通道上执行的运算为：</p>

<ol>
  <li>利用移位推掉元素任意一端的位数，清除相邻通道的颜色数据。</li>
  <li>使用第二次移位将颜色数据放置到每个元素最重要的位上，并缩短位数将元素大小从 16 位减至 8 位。</li>
</ol>

<p>请注意在这个顺序中使用元素大小来确定 8 位和 16 位元素的位置，以进行部分掩码运算。</p>

<h3 id="section-7">从888到565</h3>

<p>现在，我们来看反向运算，即从 RGB888 转换为 RGB565。这里，我们假设 RGB888 数据为上述代码产生的格式；在d0、d1和d2这三个寄存器上，每个寄存器均包含每种颜色的 8 个元素。结果将存储为 q2 格式的 8 个 16 位 RGB565 元素。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='asm'><span class='line'><span class="nf">vshll.u8</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">d0</span><span class="p">,</span> <span class="c">#8  @shift red element left to most-significant</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class='line'><span class="nf">ushll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d1</span><span class="p">,</span> <span class="c">#8  @shift green elements left to most-significant</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">bits</span> <span class="no">fo</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements</span>
</span><span class='line'><span class="nf">vsri.16</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#5  @shift green elemnts right and insert into red</span>
</span><span class='line'>                        <span class="err">@</span> <span class="nf">red</span> <span class="no">elements.</span>
</span><span class='line'><span class="nf">vshll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d2</span><span class="p">,</span> <span class="c">#8  @shift blue elements left to most-significant</span>
</span><span class='line'>                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class='line'><span class="nf">vsri.16</span>     <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#11 @shift blue elements right and insert into</span>
</span><span class='line'>                        <span class="err">@</span> <span class="nf">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">elements.</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>同样，每个指令的详细说明在备注中列出，但总而言之，对于每个通道而言：</p>

<ol>
  <li>将每个元素的长度扩展到 16 位，并将颜色数据移至最重要的位上。</li>
  <li>使用插入右移位，将每个颜色通道放置到结果寄存器中。</li>
</ol>

<h2 id="section-8">结论</h2>

<p>NEON 提供的强大的移位指令范围让你能够：</p>

<ul>
  <li>利用舍入和饱和，通过二次幂快速进行向量的除法和乘法运算。</li>
  <li>通过移位将一个向量位复制到另一个向量位。</li>
  <li>在高精度条件下进行临时计算，并在低精度条件下计算结果。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程3——矩阵相乘]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication/"/>
    <updated>2019-01-21T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">矩阵</a></li>
  <li><a href="#algorithm" id="markdown-toc-algorithm">语法(Algorithm)</a></li>
</ul>

<p>前面两篇分别介绍了如何使用 NEON 来加载和存储数据，如何使用 NEON 处理多余的数据。这一篇介绍一点儿使用的数据处理——矩阵相乘。</p>

<!--more-->

<h2 id="section">矩阵</h2>

<p>本篇文章会分析如何有效的完成4x4矩阵相乘，这种操作在 3D 图形中经常会用到。假设矩阵存放到内存中，并且是列优先的顺序，该格式在 OpenGL-ES 中使用。</p>

<h2 id="algorithm">语法(Algorithm)</h2>

<p>先详细的检测一下矩阵相乘的操作，通过把计算扩展开，并确定哪些子操作可以使用 NEON 指令实现。</p>

<p><img src="/images/neon_matrix_multiply/neon_matrix_multiply.png"></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程2——处理多余的数据]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers/"/>
    <updated>2019-01-20T00:56:44-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#fixing-up" id="markdown-toc-fixing-up">修复数据(Fixing Up)</a>    <ul>
      <li><a href="#larger-arrays" id="markdown-toc-larger-arrays">Larger Arrays</a>        <ul>
          <li><a href="#notes" id="markdown-toc-notes">Notes</a></li>
          <li><a href="#code-fragment" id="markdown-toc-code-fragment">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#overlapping" id="markdown-toc-overlapping">Overlapping</a>        <ul>
          <li><a href="#notes-1" id="markdown-toc-notes-1">Notes</a></li>
          <li><a href="#code-fragment-1" id="markdown-toc-code-fragment-1">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#single-elements" id="markdown-toc-single-elements">Single Elements</a>        <ul>
          <li><a href="#notes-2" id="markdown-toc-notes-2">Notes</a></li>
        </ul>
      </li>
      <li><a href="#further-considerations" id="markdown-toc-further-considerations">Further Considerations</a>        <ul>
          <li><a href="#beginning-or-end" id="markdown-toc-beginning-or-end">Beginning or End</a></li>
          <li><a href="#alignment" id="markdown-toc-alignment">Alignment</a></li>
          <li><a href="#using-arm-to-fix-up" id="markdown-toc-using-arm-to-fix-up">Using Arm to Fix Up</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>上一篇关于NEON 加载和存储的文章中，在NEON 处理单元（寄存器）和内存之间进行数据传输。这篇文章中，我们会处理经常遇到的问题：输入数据并不对齐，也就是输入数据的长度并不是向量长度的整数倍。我们需要在数组开始或结束的位置处理剩余的元素。使用 NEON 哪种方式最有效呢？</p>

<!--more-->

<p>使用 NEON 处理数据时，通常处理的数据向量的长度从 4 个元素到 16 个元素。通常情况下，你会发现数据的实际长度并不是切好等于寄存器向量长度的倍数，你必须单独处理剩余的元素。</p>

<p>例如，你想要使用 NEON 每次加载、处理、存储 8 个元素，但你的数组有 21 个元素的长度。前面 2 组能够正常处理，但对第 3 个，还剩下 5 个元素没有处理。你要怎么做呢？</p>

<h2 id="fixing-up">修复数据(Fixing Up)</h2>

<p>有三种方法来处理剩余的数据，三种方法的需求、性能和代码大小都不相同，分别是<code>Larger Arrays</code>、<code>Overlapping</code>、<code>Single Elements</code>，第一种方法效率最高。</p>

<h3 id="larger-arrays">Larger Arrays</h3>

<p>如何可以改变处理数组的大小，使用填充元素增加数组的长度到下一个向量大小的倍数，就可以读写超出数据本身的边界而不会影响相邻的存储。下面的例子中，增加元素到 24 个元素是的第三组可以很好地完成而不会有数据损坏。</p>

<p><img src="/images/neon_deal_leftovers/larger_array.png"></p>

<h4 id="notes">Notes</h4>

<ul>
  <li>分配更大的数组会消耗更大的内存。</li>
  <li>新的填充数据需要在初始化时给定一个值，该值不能够影响最后的计算结果。例如，如果是求和，填充数据就只能填充为 0.如果是要找到数组里面的最小值，可以设置填充数据为可以获取的最大值。</li>
  <li>某些情况下，没办法给定一个填充数据一个初始值，不影响最终结果，比如查找数据的范围时。</li>
</ul>

<h4 id="code-fragment">Code Fragment</h4>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ r0 = input array pointer
</span><span class='line'>@ r1 = output array pointer
</span><span class='line'>@ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ We can assume that the array length is greater than zero, is an integer
</span><span class='line'>@ number of vectors, and is greater than or equal to the length of data
</span><span class='line'>@ in the array.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>add r2, r2, #7      @ add (vector length - 1) to the data length
</span><span class='line'>lsr r2, r2, #3      @ divide the length of the array by the length
</span><span class='line'>                    @ of a vector, 8, to find the number of
</span><span class='line'>                    @ vectors of data to be processed loop:
</span><span class='line'>subs r2, r2, #1     @ decrement the loop counter, and set flags
</span><span class='line'>vld1.8 {d0}, [r0]!  @ load eight elements from the array pointed to
</span><span class='line'>                    @ by r0 into d0, and update r0 to point to the next vector
</span><span class='line'>...
</span><span class='line'>...                 @ process the input in d0
</span><span class='line'>...
</span><span class='line'>vst1.8 {d0}, [r1]!  @ write eight elements to the output array, and 
</span><span class='line'>                    @ update r1 to point to next vector
</span><span class='line'>bne loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="overlapping">Overlapping</h3>

<p>如果操作合适，剩余元素可以使用重叠的方法来处理。这会对数组中的某些元素进行两次处理。</p>

<p>示例中，第一组处理元素从0-7，第二组处理元素从5-12，第三组处理元素是13-20。注意，第5-7个元素，在第一次和第二次处理的向量中有重合，它们处理了两次。</p>

<p><img src="/images/neon_deal_leftovers/neon_overlapping.png"></p>

<h4 id="notes-1">Notes</h4>

<ul>
  <li>Overlapping 方法只有当输入数据的操作应用不会受操作次数的改变而改变时才能使用；例如，如果想要找到最大值可以使用该方法，而求和操作就不能使用该方法，因为 overlapping 会计算元素两次。</li>
  <li>数组中的元素数量至少能够填充一个完整的向量。</li>
</ul>

<h4 id="code-fragment-1">Code Fragment</h4>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ r0 = input array pointer
</span><span class='line'>@ r1 = output array pointer
</span><span class='line'>@ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ We can assume that the operation is idempotent, and the array is greater
</span><span class='line'>@ than or equal to one vector long.&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>ands r3, r2, #7     @ calculate number of elements left over after
</span><span class='line'>                    @ processing complete vectors using
</span><span class='line'>                    @ data length &amp; (vector length - 1)
</span><span class='line'>beq loopsetup       @ if the result of the ands is zero, the length
</span><span class='line'>                    @ of the data is an integer number of vectors,
</span><span class='line'>                    @ so there is no overlap, and processing can begin at the loop
</span><span class='line'>                    @ handle the first vector separately
</span><span class='line'>vld1.8 {d0}, [r0], r3   @ load the first eight elements from the array,
</span><span class='line'>                        @ and update the pointer by the number of elements left over
</span><span class='line'>...
</span><span class='line'>...                     @ process the input in d0
</span><span class='line'>...
</span><span class='line'>vst1.8  {d0}, [r1], r3  @ wirte eight elements to the output array, and
</span><span class='line'>                        @ update the pointer
</span><span class='line'>                        @ now, set up the vector processing loop  loopsetup:
</span><span class='line'> lsr  r2, r2, #3      @ divide the length of the array by the length
</span><span class='line'>                         @  of a vector, 8, to find the number of
</span><span class='line'>                         @  vectors of data to be processed
</span><span class='line'> 
</span><span class='line'>                         @ the loop can now be executed as normal. the
</span><span class='line'>                         @  first few elements of the first vector will
</span><span class='line'>                         @  overlap with some of those processed above  loop:
</span><span class='line'> subs    r2, r2, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0}, [r0]!  @ load eight elements from the array, and update
</span><span class='line'>                         @  the pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class='line'>                         @  update the pointer
</span><span class='line'> bne  loop            @ if r2 is not equal to 0, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h3 id="single-elements">Single Elements</h3>

<p>NEON 提供的加载和存储指令可以对向量中的某个元素进行操作。使用这个操作，可以加载向量的单个元素，在上面执行操作，并把元素写会内存。</p>

<p>示例中的问题是，前面两组数据能够正常执行(0-7元素、8-15元素)。第三组需要处理剩余的 5 个元素，它们是单独的循环中处理的，每次都执行加载、处理和存储元素。</p>

<p><img src="/images/neon_deal_leftovers/neon_single_element.png"></p>

<h4 id="notes-2">Notes</h4>

<ul>
  <li>该方法比上面提到的方法要效率低，因为每个元素都单独执行加载、处理和存储。</li>
  <li>处理剩余的元素需要两个循环——一个是向量、另一个是单个元素，这回增加函数中的代码量</li>
</ul>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>@ r0 = input array pointer
</span><span class='line'> @ r1 = output array pointer
</span><span class='line'> @ r2 = length of data in array&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code> lsrs    r3, r2, #3      @ calculate the number of complete vectors to be
</span><span class='line'>                         @  processed and set flags
</span><span class='line'> beq  singlesetup  @ if there are zero complete vectors, branch to
</span><span class='line'>                         @  the single element handling code
</span><span class='line'> 
</span><span class='line'>                         @ process vector loop  vectors:
</span><span class='line'> subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0}, [r0]!  @ load eight elements from the array and update
</span><span class='line'>                         @  the pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class='line'>                         @  update the pointer
</span><span class='line'> bne  vectors      @ if r3 is not equal to zero, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>singlesetup:
</span><span class='line'>     ands    r3, r2, #7      @ calculate the number of single elements to process
</span><span class='line'>     beq  exit            @ if the number of single elements is zero, branch
</span><span class='line'>                             @  to exit&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                         @ process single element loop  singles:
</span><span class='line'> subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class='line'> vld1.8  {d0[0]}, [r0]!  @ load single element into d0, and update the
</span><span class='line'>                         @  pointer
</span><span class='line'> ...
</span><span class='line'> ...                  @ process the input in d0[0]
</span><span class='line'> ...
</span><span class='line'> 
</span><span class='line'> vst1.8  {d0[0]}, [r1]!  @ write the single element to the output array,
</span><span class='line'>                         @  and update the pointer
</span><span class='line'> bne  singles      @ if r3 is not equal to zero, loop
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>exit:&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<h3 id="further-considerations">Further Considerations</h3>

<h4 id="beginning-or-end">Beginning or End</h4>

<p>Overlapping 和 single element 技术可以应用到处理数组的开始或结束位置。如何应用程序更适合处理结束端，上面的代码可以很容易的改成处理末端的元素。</p>

<h4 id="alignment">Alignment</h4>

<p>加载和存储地址应该与高速缓存线对齐，这样会使得内存访问更加高效。</p>

<p>对于 Cortex-A8，至少要 16 字节对齐，如果在输入或输出数组的开始位置没有对齐，就必须在数组的开始和结束位置处理元素。</p>

<p>当对齐内存来加速时，记得使用加载和存储指令时加上<code>:64</code>或<code>:128</code>或<code>:256</code>。</p>

<h4 id="using-arm-to-fix-up">Using Arm to Fix Up</h4>

<p>在使用<code>single elements</code>方法时，你可以使用 Arm 指令来对每个元素进行单独处理。然而，同时使用 Arm 指令和 NEON 指令来存储相同的内存会降低效率，因为通过 Arm 管道来写必须在 NEON 管道写完后才能进行。</p>

<p>一般情况下，应该避免同时使用 Arm 和 NEON 代码写到相同的内存区域，尤其是同一个高速缓存区域。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程1——加载和存储]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store/"/>
    <updated>2019-01-19T06:53:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">技术细节</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">概述</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">语法</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">交错存取模式</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">元素类型</a></li>
          <li><a href="#sigle-or-multiple-elements" id="markdown-toc-sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</a></li>
          <li><a href="#addressing" id="markdown-toc-addressing">寻址(Addressing)</a></li>
        </ul>
      </li>
      <li><a href="#section-6" id="markdown-toc-section-6">其他存取指令</a></li>
    </ul>
  </li>
</ul>

<p>ARM NEON 技术是 64/128 位的混合 SIMD 架构，它的设计目的就是为了提高多媒体和信号处理应用的性能，包括视频编解码、音频编解码、3D 图像、声音和图像处理。</p>

<!--more-->

<p>针对如何利用汇编语言为 NEON 编写 SIMD，后面会出一系列文章，本篇为第一部分。该系列文章会包含如何开始 NEON，如何高效使用它，后面还会介绍编写更复杂代码的技巧。我们先从操作内存开始，以及如何利用序列指令，灵活的使用 load 和 store。</p>

<h2 id="section">示例</h2>

<p>我们从一个具体的示例开始。假设你有一个 24bit RGB 图像，像素在内存中的排列格式为 R,G,B,R,G,B…，假设你想要将其中的 R 和 B 进行交换，该如何利用 NEON，是的操作更加高效呢？</p>

<p>采用简单的线性 load 指令从内存中复制到寄存器里面，然后进行R/B 调换操作，会比较繁琐。示例如图</p>

<p><img src="/images/neon_load_store/linear_load_rgb.png"></p>

<p>基于上图中的输入，进行分割、移位、合并这种方法去交换通道会很麻烦，效率低下。</p>

<p>NEON 针对此种应用场景提供了结构化的加载和存储指令，它们会从内存中加载数据的同时将数据分发到不同的寄存器。如上面例子中，VLD3 指令可以分别将加载的 R/G/B数据分别放到三个不同的寄存器中。</p>

<p><img src="/images/neon_load_store/structed_load_rgb.png"></p>

<p>现在，只要交换R/B寄存器的内容(VSWP d0, d2),之后用类似的存储指令 VST3 将数据写会内存中即可。</p>

<h2 id="section-1">技术细节</h2>

<h3 id="section-2">概述</h3>

<p>NEON 结构化加载指令从内存中读取数据进入 64 位 NEON 寄存器，可以选择是否交错读取；同样的，存储指令将寄存器中的数据可以交错写回到内存中。</p>

<p><img src="/images/neon_load_store/neon_structure_loads_stores.png"></p>

<h3 id="section-3">语法</h3>

<p>结构化加载和存取指令的语法结构有 5 部分组成。</p>

<p><img src="/images/neon_load_store/neon_load_store_syntax.png"></p>

<ul>
  <li>指令助记符，VLD 用于加载，VST 用于存储。</li>
  <li>交错存取的模式，此数字指定了相关元素之间的距离。</li>
  <li>访问的元素类型，该类型指定了元素的位宽。</li>
  <li>需要读取或者写入的寄存器集合，最大为4， 取决于交错存取的模式。</li>
  <li>ARM 地址寄存器，包含需要访问的内存地址。</li>
</ul>

<h4 id="section-4">交错存取模式</h4>

<p>NEON 指令能够加载和存储数据并以交错方式加载或存储1-4个相同位宽的元素，NEON 支持8、16、32bit的交错存取元素。</p>

<ul>
  <li>VLD1 是最简单的一种形式，该指令能从内存中线性加载数据到1-4个寄存器中，一般用于无交错存取的数据处理。</li>
  <li>VLD2 可以从内存中加载数据到 2 或 4 个寄存器中，将交错的奇数和偶数项的数据分别加载到不同的寄存器中，一般用于立体声的左右声道的分离。</li>
  <li>VLD3 加载交错距离为 3 的数据到 3 个寄存器中，一般用于图像中 RGB 通道的分离。</li>
  <li>VLD4 加载交错距离为 4 的数据到 4 个寄存器中，一般用于图像中 ARGB 通道的分离。</li>
</ul>

<p>存储指令类似加载指令，但是在写入到内存之前就已经完成了数据元素交错。</p>

<h4 id="section-5">元素类型</h4>

<p>交错元素的存取规则取决于指令本身。例如，使用 VLD2.16 加载数据，完成操作后，共加载 8 个 16bit 的元素，其中偶数项元素加载到第一个寄存器，奇数项元素加载到第二个寄存器中。</p>

<p><img src="/images/neon_load_store/100310_MC_diag3-1.png"></p>

<p>元素大小变成 32 之后，加载同样大小的数据(4x32),然而每个寄存器中只有2个元素(2x32)，与 VLD2.16 一样，VLD2.32 同样是偶数项元素加载到第一个寄存器中，奇数项元素加载到第二个寄存器中。</p>

<p><img src="/images/neon_load_store/100310_MC_diag3a-1.png"></p>

<p>元素大小还会影响字节顺序，一般来讲，如果你是在存取指令中指定了正确的元素大小，从内存中读取的字节顺序将符合你的语气，并且相同的代码能在大端或者小端系统上运行良好。</p>

<p>最后，元素大小对于指针对齐也有一定的影响，指针地址对齐到元素大小将具有更好的性能，例如，当加载 32 位的元素时，内存首地址最小要对齐 32 位。</p>

<h4 id="sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</h4>

<p>除了一次加载多个元素外，结构化的加载指令还能够一次从内存中读取一个元素，并且交错的放到不同的寄存器中，或者是放到寄存器的所有通道中，或者是放到寄存器的单个通道，其他通道不受影响。</p>

<p><img src="/images/neon_load_store/deinterleaving_vector_lanes.png"></p>

<p>后面的描述对于从散乱的内存中构造出一个 vector 比较有用。</p>

<p><img src="/images/neon_load_store/deinterleaving_single_vect.png"></p>

<p>存储指令和读取指令类似。</p>

<h4 id="addressing">寻址(Addressing)</h4>

<p>结构化的加载和存取指令支持 3 种格式来指定地址。</p>

<ul>
  <li><code>Register:[{,:}]</code>,这是最简单的寻址方式，数据在指定地址中进行存取</li>
  <li><code>Register with increment after:[{,:}]!</code>, 这种寻址方式在完成数据加载后将更新指针使其指向之后待处理的元素，指针的增长大小与指令存取的字节数一致。</li>
  <li><code>Register with post-index:[{,:}]</code>，这种寻址方式在完成数据存取之后将改变指针，指针增加指定量（由寄存器 Rm 指定），这种方式在存取元素分散在固定距离的情况下比较方便，如读取图像的一列像素。</li>
</ul>

<p>同样的，也可以通过指定 Rn 来指定指针的对齐，使用 optional:parameter 这样同样能加快内存的读取。</p>

<h3 id="section-6">其他存取指令</h3>

<p>这里只介绍了结构化的存取指令，NEON 还提供了如下指令：</p>

<ul>
  <li>VLDR 和 VSTR，存取单个 64 位寄存器</li>
  <li>VLDM 和 VSTM，加载多个 64 位寄存器，方便从栈上存取数据。</li>
</ul>

<p>更多关于加载和存取操作的细节，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406b/index.html&amp;_ga=2.76337745.535197283.1547875098-60705264.1529324001">Arm Architecture Reference Manual</a>, 关于每条指令所占用的时钟周期数，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexa/index.html&amp;_ga=2.41000550.535197283.1547875098-60705264.1529324001">Technical Reference Manual for each core</a>.</p>

]]></content>
  </entry>
  
</feed>
