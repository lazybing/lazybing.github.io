<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 编程工具 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/bian-cheng-gong-ju/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-11-19T23:59:35-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何使用gprof]]></title>
    <link href="http://lazybing.github.io/blog/2016/09/22/how-to-use-gprof/"/>
    <updated>2016-09-22T09:52:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/09/22/how-to-use-gprof</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gprof">Gprof</a> 是一个 Unix 应用程序性能分析工具。
<!--more--></p>

<p><a href="https://sourceware.org/binutils/docs/gprof/index.html">Profiling</a> 可以使我们看到程序运行时程序的调用关系、函数的消耗时长等。这些信息可以使我们了解程序中那块代码耗时高于预期。</p>

<p>使用 Profiling 主要包括如下三步：</p>

<ul>
  <li>
    <p>编译链接程序时要使能 profiling 。</p>
  </li>
  <li>
    <p>执行编译处的可执行文件，产生 profile 数据文件。</p>
  </li>
  <li>
    <p>使用 gpro 分析 profile 数据。</p>
  </li>
</ul>

<p>根据产生的 profile ，可以产生各种不同实行的分析输出。如 The Flat Profile、The Call Graph、The Annotated Source Listing。</p>

<p>示例分析：
{% codeblock lang:c %}</p>

<h1 id="include-stdioh">include <stdio.h></stdio.h></h1>
<p>#include <stdlib.h>
#include <time.h></time.h></stdlib.h></p>

<p>void fun2()
{
    sleep(3);
}</p>

<p>void fun1()
{
    int index = 0;</p>

<pre><code>sleep(10);
for(index = 0; index &lt; 5; index++)
    fun2(); }
</code></pre>

<p>int main(int argc, char **argv)
{
    int index = 0;
    for(index = 0; index &lt; 10; index++)
    {
        fun1(); 
    }
}</p>

<p>{% endcodeblock %}</p>

<p>编译，注意要添加<code>-pg</code>选项，这样才能与后面的 gprof 结合使用。</p>

<p><code>
gcc -pg -o test test.c
</code></p>

<p>执行, 执行完毕后，会生成 gmon.out 文件，用于性能分析的文件。</p>

<p><code>
./test
</code></p>

<p>分析, 使用 gprof 分析。
<code>
gprof test gmon.out &gt; analysis.txt
</code></p>

<p>此时生成的分析文件 analysis.txt 中有两种形式的分析数据。</p>

<p>Flat Profile 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Flat_profile.png" /></p>

<p>Call Graph 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Call_graph.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim 使用技巧]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/07/how-to-use-vim/"/>
    <updated>2016-07-07T08:17:10-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/07/how-to-use-vim</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#mac-osx--gvim" id="markdown-toc-mac-osx--gvim">Mac OSX 下安装 gvim</a></li>
  <li><a href="#section" id="markdown-toc-section">基本设置</a></li>
  <li><a href="#vim-" id="markdown-toc-vim-">vim 寄存器</a></li>
  <li><a href="#vim--1" id="markdown-toc-vim--1">vim 分屏功能</a></li>
</ul>

<p>Vim 是一个学习成本比较高的编辑器。
<!--more--></p>

<h2 id="mac-osx--gvim">Mac OSX 下安装 gvim</h2>

<p>{% codeblock %}
brew install macvim
{% endcodeblock %}</p>

<h2 id="section">基本设置</h2>

<p>显示行号，在<code>.vimrc</code>中添加<code>set nu</code></p>

<h2 id="vim-">vim 寄存器</h2>

<p>使用 vim 时，不管是复制、删除或粘贴，在 vim 中都是借助 register 实现的，vim 共有 9 类寄存器。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">寄存器种类</th>
      <th style="text-align: center">寄存器</th>
      <th style="text-align: center">寄存器描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">无名寄存器</td>
      <td style="text-align: center">””</td>
      <td style="text-align: center">缓存最后一个操作内容</td>
    </tr>
    <tr>
      <td style="text-align: center">数字寄存器</td>
      <td style="text-align: center">“0~”9</td>
      <td style="text-align: center">缓存最近操作内容</td>
    </tr>
    <tr>
      <td style="text-align: center">行内寄存器</td>
      <td style="text-align: center">”-</td>
      <td style="text-align: center">缓存行内删除内容</td>
    </tr>
    <tr>
      <td style="text-align: center">具名寄存器</td>
      <td style="text-align: center">“a~”z或”A~”Z</td>
      <td style="text-align: center">指定时可用</td>
    </tr>
    <tr>
      <td style="text-align: center">只读寄存器</td>
      <td style="text-align: center">”:,”.,”%,”#</td>
      <td style="text-align: center">分别缓存最近命令，最近插入文本，当前文件名，当前交替文件名</td>
    </tr>
    <tr>
      <td style="text-align: center">表达式寄存器</td>
      <td style="text-align: center">”=</td>
      <td style="text-align: center">只读，用于执行表达式命令</td>
    </tr>
    <tr>
      <td style="text-align: center">选择及拖拽寄存器</td>
      <td style="text-align: center">“*,”+,”~</td>
      <td style="text-align: center">存取GUI选择文本</td>
    </tr>
    <tr>
      <td style="text-align: center">黑洞寄存器</td>
      <td style="text-align: center">“_</td>
      <td style="text-align: center">不缓存操作内容</td>
    </tr>
    <tr>
      <td style="text-align: center">模式寄存器</td>
      <td style="text-align: center">”/</td>
      <td style="text-align: center">缓存最近的搜索模式</td>
    </tr>
  </tbody>
</table>

<h2 id="vim--1">vim 分屏功能</h2>

<image src="http://lazybing.github.io/images/vim_split_screen.png">

vim 同时打开多个文件。

```
vim -o file1 file2              //小写 o 参数来水平分屏
vim -O file1 file2              //大写 O 参数来垂直分屏
```

vim 在多窗口打开。

```
:vs path/file       //在新的垂直分屏中打开文件
:sv path/file       //在新的水平分屏中打开文件
```

多窗口间切换的3方法：`Ctrl+w+方向键` `Ctrl+w+h/j/k/l` `Ctrl+ww`。

移动分屏的方法：`Ctrl+w L`向右移动分屏；`Ctrl+w H`向左移动分屏；`Ctrl+w K`向上移动分屏；`Ctrl+w J`向下移动分屏。

## vim 插件安装 

首先安装插件管理插件

```
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
```

其次在`.vimrc`下增加配置信息如下。

```
" vundle 环境设置
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
" vundle 管理的插件列表必须位于 vundle#begin() 和 vundle#end() 之间
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'
Plugin 'altercation/vim-colors-solarized'
Plugin 'tomasr/molokai'
Plugin 'vim-scripts/phd'
Plugin 'Lokaltog/vim-powerline'
Plugin 'octol/vim-cpp-enhanced-highlight'
Plugin 'nathanaelkane/vim-indent-guides'
Plugin 'derekwyatt/vim-fswitch'
Plugin 'kshenoy/vim-signature'
Plugin 'vim-scripts/BOOKMARKS—Mark-and-Highlight-Full-Lines'
Plugin 'majutsushi/tagbar'
Plugin 'vim-scripts/indexer.tar.gz'
Plugin 'vim-scripts/DfrankUtil'
Plugin 'vim-scripts/vimprj'
Plugin 'dyng/ctrlsf.vim'
Plugin 'terryma/vim-multiple-cursors'
Plugin 'scrooloose/nerdcommenter'
Plugin 'vim-scripts/DrawIt'
Plugin 'SirVer/ultisnips'
Plugin 'Valloric/YouCompleteMe'
Plugin 'derekwyatt/vim-protodef'
Plugin 'scrooloose/nerdtree'
Plugin 'fholgado/minibufexpl.vim'
Plugin 'gcmt/wildfire.vim'
Plugin 'sjl/gundo.vim'
Plugin 'Lokaltog/vim-easymotion'
Plugin 'suan/vim-instant-markdown'
Plugin 'lilydjwg/fcitx.vim'
" 插件列表结束
call vundle#end()
filetype plugin indent on`
```

最后，进入`vim`执行

```
:PluginInstall
```

## vim 浏览代码

## vim 浏览代码

vim 浏览代码一般会与 `catgs` `cscope` `taglist` 等一起使用。

</image>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Use GDB]]></title>
    <link href="http://lazybing.github.io/blog/2016/04/01/how-to-use-gdb/"/>
    <updated>2016-04-01T07:48:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/04/01/how-to-use-gdb</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">前期准备</a></li>
  <li><a href="#gdb" id="markdown-toc-gdb">启动GDB</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">查看源码</a></li>
  <li><a href="#break-" id="markdown-toc-break-">断点break 使用</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">查看运行时数据</a></li>
</ul>

<p><a href="https://www.gnu.org/software/gdb/">GDB</a>, The GNU Project debugger, allows you to see what is going on inside another program while it executes – or what another program was doing at the moment it crashed.</p>

<!--more-->

<h3 id="section">前期准备</h3>

<p>GDB 一般用于调试<code>C/C++</code>程序，要想能够使用<code>GDB</code>调试<code>C/C++</code>程序，首先必须将调试信息添加到可执行程序中。使用<code>gcc/g++</code>的<code>-g</code>参数可以做到这一点。如：</p>

<p><code>
gcc -g programe.c -o programe
</code>
此时，可执行程序<code>programe</code>中就包含了调试需要的各种信息，如程序函数名、变量名等。
对于 MAC OSX 系统，调试信息会包含在另外一个<code>programe.dSYM</code>（debug symbols）文件夹下面，可以使用<code>dwarfdump programe.dSYM</code>直接查看各符号信息。</p>

<h3 id="gdb">启动GDB</h3>

<p><code>
gdb programe
</code></p>

<h3 id="section-1">查看源码</h3>

<p><code>
list linenum  //查看linenum行的源码
list function //查看function的源码
</code></p>

<h3 id="break-">断点break 使用</h3>

<p>设置断点的方法
<code>
break linenum  //在 linenum 处设置断点
break function //在进入指定 function 时停住
break filename:linenum  //在源文件 filename 的 linenum 行处停住
break filename:function //在源文件 filename 的 function 函数的入口处停住
break *address          //在程序运行的内存地址处停住
</code></p>

<p>查看断点信息
<code>
info break    //查看所有 break 的信息
info break n //查看 n 断点号的信息
</code></p>

<h3 id="section-2">查看运行时数据</h3>

<p>当运行程序到某个位置时，我们希望看看此时程序的状态，比如某个变量的值是否按照预期改变、某块内存的值是否被改。此时就需要用到查看程序运行数据的集中方法。</p>

<p>查看格式 <code>print &lt;expr&gt;</code>或<code>print /&lt;f&gt; &lt;expr&gt;</code>，其中<code>&lt;expr&gt;</code>是要查看的表达式，可以是一个变量、数组、表达式等，<code>&lt;f&gt;</code>是输出时的格式，比如想要按照 16 进制输出，就使用<code>/x</code>。</p>

<p>可以使用 examine 命令查看内存地址中的值。格式是<code>x /&lt;n/f/u&gt; &lt;addr&gt;</code>，其中<code>&lt;addr&gt;</code>是内存地址。</p>

]]></content>
  </entry>
  
</feed>
