<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:总结积累 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/zong-jie-ji-lei/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2018-11-05T08:21:13-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux下C语言调用静态库和动态库简介]]></title>
    <link href="http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library/"/>
    <updated>2018-09-18T21:27:55-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">动态库和静态库简述</a></li>
  <li><a href="#endif" id="markdown-toc-endif">endif</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">静态库使用示例</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">动态库使用示例</a></li>
    </ul>
  </li>
  <li><a href="#define-lib-libsayhelloso" id="markdown-toc-define-lib-libsayhelloso">define LIB “./libsayhello.so”</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">动态库和静态库整合</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
    </ul>
  </li>
</ul>

<p>最近工作中遇到要把第三方静态库整合到自己的动态开里的问题，在此记录并整理一些关于静态库和动态库的知识，并用特定的例子。</p>

<!--more-->

<h3 id="section">动态库和静态库简述</h3>

<p>动态库和静态库本质上是一种可执行代码的二进制形式，它们可以被操作系统载入内存执行。两者的主要区别是，静态库是在编译过程中被载入可执行程序的，体积较大；动态库是在可执行程序在运行时被载入内存的，在编译过程中仅仅使用简单的引用，体积较小。</p>

<p>给出示例代码如下：</p>

<p>{% codeblock lang:c sayhello.c %}
#include <stdio.h>
#include "sayhello.h"</stdio.h></p>

<p>void helloworld(void)
{
    printf(“Hello World\n”);
}
{% endcodeblock %}</p>

<p>{% codeblock lang:c sayhello.h %}
#ifndef <em>SAYHELLO_H</em>
#define <em>SAYHELLO_H</em></p>

<p>void helloworld(void);</p>

<h1 id="endif">endif</h1>
<p>{% endcodeblock %}</p>

<h3 id="section-1">静态库使用示例</h3>

<p>编译静态库：</p>

<p><code>
$ gcc -Wall -O2 -fPIC -I./ -c -o sayhello.o sayhello.c
$ ar crv libsayhello.a sayhello.o
</code></p>

<p><code>ar</code>命令会生成<code>libsayhello.a</code>的静态库。该命令的参数如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">参数</th>
      <th style="text-align: center">意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">将objectfile 文件插入静态库尾或替换静态库中同名文件</td>
    </tr>
    <tr>
      <td style="text-align: center">-x</td>
      <td style="text-align: center">从静态库文件中抽取文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-t</td>
      <td style="text-align: center">打印静态库的成员文件列表</td>
    </tr>
    <tr>
      <td style="text-align: center">-d</td>
      <td style="text-align: center">从静态库中删除文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-s</td>
      <td style="text-align: center">重置静态库文件索引</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">创建文件冗余信息</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">创建静态库文件</td>
    </tr>
  </tbody>
</table>

<p>生成了静态库后，可以在可执行文件中调用静态库内的函数,示例代码：</p>

<p>{% codeblock lang: test_hello_stactic.c %}
#include <stdio.h>
extern void helloworld(void);</stdio.h></p>

<p>int main(int argc, char **argv)
{
    helloworld();
}
{% endcodeblock %}</p>

<p>编译命令:</p>

<p><code>
$ gcc test_hello_stactic.c -o test_hello_sta ./libsayhello.a
</code></p>

<h3 id="section-2">动态库使用示例</h3>

<p>编译动态库：</p>

<p><code>
$ gcc -O2 -fPIC -shared sayhello.c -o libsayhello.so
或
$ gcc -O2 -fPIC -c sayhello.c
$ gcc -shared -o libsayhello.so sayhello.o
</code></p>

<p>其中</p>

<ul>
  <li>fPIC:产生与位置无关码，全部使用相对地址</li>
  <li>shared:生成动态库</li>
</ul>

<p>调用动态库的示例代码：</p>

<p>{% codeblock lang: test_hello_shared.c %}
#include <stdio.h>
#include <dlfcn.h></dlfcn.h></stdio.h></p>

<h1 id="define-lib-libsayhelloso">define LIB “./libsayhello.so”</h1>
<p>int main(int argc, char **argv)
{
    void *dl = dlopen(LIB, RTLD_LAZY);
    if(dl == NULL)
    {
        fprintf(stderr, “Error:faile to load libary.\n”);
    }</p>

<pre><code>void (*func)() = dlsym(dl, "helloworld");
func();
dlclose(dl);

return 0; } {% endcodeblock %}
</code></pre>

<h3 id="section-3">动态库和静态库整合</h3>

<h3 id="section-4">参考文档</h3>

<ol>
  <li><a href="http://answerywj.com/2016/10/10/Linux%E4%B8%8BC%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">Linux下C调用静态库和动态库</a></li>
  <li><a href="https://liam0205.me/2017/04/03/not-to-link-libstdc-statically-and-why/">为什么不能再动态库里静态链接</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何理解内存对齐]]></title>
    <link href="http://lazybing.github.io/blog/2018/08/22/memory-alignment/"/>
    <updated>2018-08-22T08:23:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/08/22/memory-alignment</id>
    <content type="html"><![CDATA[<p>数据对齐会影响到计算机访问内存以及占用内存的空间大小。</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">对齐要求</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">填充</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结构体的对齐和填充</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">结构体成员重排</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可读性与缓存局部性</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">代码测试示例</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">参考文档</a></li>
</ul>

<h3 id="section">对齐要求</h3>

<p>在<code>X86</code>或<code>ARM</code>处理器中，基本 C 数据类型通常并不存储于内存中的随机字节地址。实际情况是，除<code>char</code>外，
所有其他类型都有对齐要求：<code>char</code>可起始于任意字节地址，2 字节的 short 必须从偶数字节地址开始，4 字节<code>int</code>或<code>float</code>必须
从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从
能被 8 整除的地址开始。无论<code>signed(有符号)</code>还是<code>unsigned(无符号)</code>都不受影响。</p>

<p>简言之，<code>X86</code>和<code>ARM</code>的基本 C 类型是<code>自对齐(self-aligned)</code>的。关于指针，无论 32 位还是 64 位也都是自对齐的。</p>

<p>自对齐可令访问速度更快，因为它有利于生成单指令(single-instruction)存取这些类型的数据。另一方面，如若没有对齐约束，可能
最终不得不通过两个或更多指令访问跨越机器字边界的数据。字符数据是种特殊情况，因其始终处在单一机器字中，所以无论存取何处的字符数据，
开销都是一致的。这也就是它不需要对齐的原因。</p>

<h3 id="section-1">填充</h3>

<p>假设我们有如下一段 C 代码：</p>

<p><code>
int function(void)
{
    char *pchar;
    char ch;
    int idx;
    ...
}
</code></p>

<p>这里的占用字节空间如下：</p>

<p><code>
char *pchar;    //4 or 8 bytes
char ch;        //1 byte
char pad[3];    //3 bytes, 3 个字节的空间被浪费掉了
int idx;        //4 bytes
...
</code></p>

<p>如果 <code>x </code>为 2 字节 short：</p>

<p><code>
char *p;
char c;
short x;
</code></p>

<p>时间分布为:</p>

<p><code>
char *p;    //4 or 8 bytes
char c;     //1 byte
char pad[1];    //1 byte, 1 字节的空间被浪费掉了
short x;        //2 bytes
</code></p>

<p>更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-2">结构体的对齐和填充</h3>

<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>

<p>思考如下的结构体：</p>

<p><code>
struct foo1{
    char *p;
    char c;
    long x;
};
</code></p>

<p>64 位系统中，任何<code>struct foo1</code>的实例都采用 8 字节对齐，其内存分布如下：</p>

<p><code>
struct foo1{
    char *p;    //8 bytes
    char c;     //1 byte
    char pad[7];    // 7 bytes
    long x;         // 8 bytes
};
</code>
更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-3">结构体成员重排</h3>

<p>理解了结构体成员的对齐后，可以看到，最简单的节省内存的方式，是按对齐递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为
在 64 为系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。</p>

<p>以简单的链表结构为例：</p>

<p><code>
struct foo7{
    char c;
    struct foo7 *p;
    short x;
};
</code>
<code>sizeof(foo7)</code>占用 24 字节。如果按照长度重排，可以得到:</p>

<p><code>
struct foo8{
    struct foo8 *p;
    short x;
    char c;
};
</code></p>

<p>重新打包后，空间降低为 16 字节。</p>

<h3 id="section-4">可读性与缓存局部性</h3>

<p>笨拙地、机械地重排结构体可能有损可读性。最好重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>

<h3 id="section-5">代码测试示例</h3>

<p>{% codeblock lang:c %}
#include <stdio.h>
#include <stdbool.h></stdbool.h></stdio.h></p>

<p>struct foo1 {
    char *p;
    char c;
    long x;
};</p>

<p>struct foo2 {
    char c;      /* 1 byte <em>/
    char pad[7]; /</em> 7 bytes <em>/
    char *p;     /</em> 8 bytes <em>/
    long x;      /</em> 8 bytes */
};</p>

<p>struct foo3 {
    char <em>p;     /</em> 8 bytes <em>/
    char c;      /</em> 1 byte */
};</p>

<p>struct foo4 {
    short s;     /* 2 bytes <em>/
    char c;      /</em> 1 byte */
};</p>

<p>struct foo5 {
    char c;
    struct foo5_inner {
        char *p;
        short x;
    } inner;
};</p>

<p>struct foo6 {
    short s;
    char c;
    int flip:1;
    int nybble:4;
    int septet:7;
};</p>

<p>struct foo7 {
    int bigfield:31;
    int littlefield:1;
};</p>

<p>struct foo8 {
    int bigfield1:31;
    int littlefield1:1;
    int bigfield2:31;
    int littlefield2:1;
};</p>

<p>struct foo9 {
    int bigfield1:31;
    int bigfield2:31;
    int littlefield1:1;
    int littlefield2:1;
};</p>

<p>struct foo10 {
    char c;
    struct foo10 *p;
    short x;
};</p>

<p>struct foo11 {
    struct foo11 *p;
    short x;
    char c;
};</p>

<p>struct foo12 {
    struct foo12_inner {
        char *p;
        short x;
    } inner;
    char c;
};</p>

<p>main(int argc, char *argv)
{
    printf(“sizeof(char *)        = %zu\n”, sizeof(char *));
    printf(“sizeof(long)          = %zu\n”, sizeof(long));
    printf(“sizeof(int)           = %zu\n”, sizeof(int));
    printf(“sizeof(short)         = %zu\n”, sizeof(short));
    printf(“sizeof(char)          = %zu\n”, sizeof(char));
    printf(“sizeof(float)         = %zu\n”, sizeof(float));
    printf(“sizeof(double)        = %zu\n”, sizeof(double));
    printf(“sizeof(struct foo1)   = %zu\n”, sizeof(struct foo1));
    printf(“sizeof(struct foo2)   = %zu\n”, sizeof(struct foo2));
    printf(“sizeof(struct foo3)   = %zu\n”, sizeof(struct foo3));
    printf(“sizeof(struct foo4)   = %zu\n”, sizeof(struct foo4));
    printf(“sizeof(struct foo5)   = %zu\n”, sizeof(struct foo5));
    printf(“sizeof(struct foo6)   = %zu\n”, sizeof(struct foo6));
    printf(“sizeof(struct foo7)   = %zu\n”, sizeof(struct foo7));
    printf(“sizeof(struct foo8)   = %zu\n”, sizeof(struct foo8));
    printf(“sizeof(struct foo9)   = %zu\n”, sizeof(struct foo9));
    printf(“sizeof(struct foo10)   = %zu\n”, sizeof(struct foo10));
    printf(“sizeof(struct foo11)   = %zu\n”, sizeof(struct foo11));
    printf(“sizeof(struct foo12)   = %zu\n”, sizeof(struct foo12));
}
{% endcodeblock %}</p>

<h3 id="section-6">参考文档</h3>

<ol>
  <li><a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">The Lost Art Of C Structure Packing</a></li>
  <li><a href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Memory Alignment</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data Structure Alignment</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELF格式分析手册]]></title>
    <link href="http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial/"/>
    <updated>2018-03-21T07:30:48-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#elf-data-type" id="markdown-toc-elf-data-type">ELF Data Type</a></li>
  <li><a href="#the-elf-header" id="markdown-toc-the-elf-header">The ELF Header</a></li>
  <li><a href="#define-elfmag0----0x7f---eidenteimag0" id="markdown-toc-define-elfmag0----0x7f---eidenteimag0">define ELFMAG0    0x7F   //e_ident[EI_MAG0]</a></li>
  <li><a href="#define-elfdata2lsb-1---little-endian" id="markdown-toc-define-elfdata2lsb-1---little-endian">define ELFDATA2LSB (1)   //Little Endian</a></li>
  <li><a href="#checking-the-elf-header" id="markdown-toc-checking-the-elf-header">Checking the ELF Header</a></li>
  <li><a href="#loading-the-elf-file" id="markdown-toc-loading-the-elf-file">Loading the ELF File</a></li>
</ul>

<p>本文主要记录目标文件是<code>i386(32位架构、小端序)ELF</code>文件的加载过程。本文中的所有代码都是 C 风格，所有代码段都会使用最简单的例子。后面可能会扩展到其他类型的 ELF 文件。
<!--more--></p>

<h1 id="elf-data-type">ELF Data Type</h1>

<p>{% codeblock lang:c %}
#include <stdint.h>
typedef uint16_t Elf32_Half;    //Unsigned half int
typedef uint32_t Elf32_Off;     //Unsigned offset
typedef uint32_t Elf32_Addr;    //Unsigned address
typedef uint32_t Elf32_Word;    //Unsigned int
typedef int32_t  Elf32_Sword;   //Signed int
{% endcodeblock %}</stdint.h></p>

<h1 id="the-elf-header">The ELF Header</h1>

<p>每个 ELF 格式文件都有位于文件开始的头部<code>Header</code>。</p>

<p>{% codeblock lang:c %}
#define ELF_NIDENT 16
typedef struct{
    uint8_t     e_ident[ELF_NIDENT];
    Elf32_Half  e_type;
    Elf32_Half  e_machine;
    Elf32_Word  e_version;
    Elf32_Addr  e_entry;
    Elf32_Off   e_phoff;
    Elf32_Off   e_shoff;
    Elf32_Word  e_flags;
    Elf32_Half  e_ehsize;
    Elf32_Half  e_phoff;
    Elf32_Half  e_shoff;
    Elf32_Word  e_flags;
    Elf32_Half  e_ehsize;
    Elf32_Half  e_phentsize;
    Elf32_Half  e_phnum;
    Elf32_Half  e_shentsize;
    Elf32_Half  e_shnum;
    Elf32_Half  e_shstrndx;
}ELF32_Ehdr;
{% endcodeblock %}</p>

<p>{% codeblock lang:c %}
enum Elf_Ident{
    EI_MAG0    = 0, //0x7F
    EI_MAG1    = 1, //‘E’
    EI_MAG2    = 2, //‘L’
    EI_MAG3    = 3, //‘F’
    EI_CLASS   = 4, //Architecture(32/64)
    EI_DATA    = 5,//Byte Order
    EI_VERSION = 6, //ELF Version
    EI_OSABI   = 7, //OS Specific
    EI_ABIVERSION = 8, //OS Specific
    EI_PAD        = 9  //Padding
};</p>

<h1 id="define-elfmag0----0x7f---eidenteimag0">define ELFMAG0    0x7F   //e_ident[EI_MAG0]</h1>
<p>#define ELFMAG1    ‘E’    //e_ident[EI_MAG1]
#define ELFMAG2    ‘L’    //e_ident[EI_MAG2]
#define ELFMAG3    ‘F’    //e_ident[EI_MAG3]</p>

<h1 id="define-elfdata2lsb-1---little-endian">define ELFDATA2LSB (1)   //Little Endian</h1>
<p>#define ELFCLASS32  (1)   //32-bit Architecture
{% endcodeblock %}</p>

<p>{% codeblock lang:c %}
enum Elf_Type{
    ET_NONE    = 0, //Unknown Type
    ET_REL     = 1, //Relocatable File
    ET_EXEC    = 2  //Executable File
};
#define EM_386     (3) //x86 Machine Type
#define EV_CURRENT (1) //ELF Current Version
{% endcodeblock %}</p>

<h1 id="checking-the-elf-header">Checking the ELF Header</h1>

<p>在对<code>ELF</code>文件进行加载、链接、重定向或其他操作之前，首先要确保机器是否支持上述的操作。
{% codeblock lang:c %}
bool elf_check_file(Elf32_Ehdr *hdr){
    if(!hdr) return false;
    if(hdr-&gt;e_ident[EI_MAG0] != ELFMAG0){
        ERROR(“ELF Header EI_MAG0 incorrect.\n”); 
        return false;
    }
    if(hdr-&gt;e_ident[EI_MAG1] != ELFMAG1){
        ERROR(“ELF Header EI_MAG1 incorrect.\n”); 
        return false;
    }
    if(hdr-&gt;e_ident[EI_MAG2] != ELFMAG2){
        ERROR(“ELF Header EI_MAG2 incorrect.\n”); 
        return false;
    }
    if(hdr-&gt;e_ident[EI_MAG3] != ELFMAG3){
        ERROR(“ELF Header EI_MAG2 incorrect.\n”); 
        return false;
    }
    return true;
}
{% endcodeblock %}</p>

<p>{% codeblock lang:c %}
bool elf_check_supported(ELF32_Ehdr *hdr){
    if(!elf_check_file(hdr)){
        ERROR(“Invalid ELF File.\n”);
        return false;
    }
    if(hdr-&gt;e_ident[EI_CLASS] != ELFCLASS32){
        ERROR(“Unsupported ELF File Class.\n”);
        return false;
    }
    if(hdr-&gt;e_ident[EI_DATA] != ELFDATA2LSB){
        ERROR(“Unsupported ELF File byte order.\n”);
        return false;
    }
    if(hdr-&gt;e_machine != EM_386){
        ERROR(“Unsupported ELF File target.\n”);
        return false;
    }
    if(hdr-&gt;e_ident[EI_VERSION] != EV_CURRENT){
        ERROR(“Unsupported ELF File version.\n”);
        return false;
    }
    if(hdr-&gt;e_type != ET_REL &amp;&amp; hdr-&gt;e_type != ET_EXEC){
        ERROR(“Unsupported ELF File type.\n”);
        return false;
    }
    return true;
}
{% endcodeblock %}</p>

<h1 id="loading-the-elf-file">Loading the ELF File</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程小技巧]]></title>
    <link href="http://lazybing.github.io/blog/2017/09/29/coding-tips/"/>
    <updated>2017-09-29T13:35:57-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/09/29/coding-tips</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">获取文件路径后缀名</a>    <ul>
      <li><a href="#c-" id="markdown-toc-c-">C 语言实现</a></li>
      <li><a href="#c--1" id="markdown-toc-c--1">C++ 语言实现</a></li>
      <li><a href="#shell-" id="markdown-toc-shell-">Shell 脚本实现</a></li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">调试信息分级打印</a></li>
  <li><a href="#define-logdefault-2" id="markdown-toc-define-logdefault-2">define LOG_DEFAULT 2</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">分析特定格式的文件</a></li>
      <li><a href="#fopen-" id="markdown-toc-fopen-">fopen 函数个数限制</a></li>
    </ul>
  </li>
</ul>

<p>本篇博客主要记录在写代码过程中遇到的一些小技巧，它并不是特别难以实现的复杂算法，也不是对某种特定语言的记录，而是在
工作中遇到某个问题时，自然而然能想到的解决方法，通常是一些比较通用的小技巧。</p>

<!--more-->

<h2 id="section">获取文件路径后缀名</h2>

<p>工作中经常遇到对一批视频文件进行统一处理的情况，有时会根据文件名的不同后缀名进行不同的处理操作。此时就需要首先获取文件的后缀名，
之后再根据后缀名的不同进行相应的操作。</p>

<h3 id="c-">C 语言实现</h3>

<p>实现思路：获取文件字符串的最后一个字符，依次向前寻找<code>.</code>，<code>.</code>后面即为后缀名。</p>

<p>{% codeblock lang:c get_filename_extension %}
static inline char *get_filename_extension( char *filename )
{
    char *ext = filename + strlen( filename );
    while( *ext != ‘.’ &amp;&amp; ext &gt; filename )
        ext–;
    ext += *ext == ‘.’;
    return ext;
}
{% endcodeblock %}</p>

<h3 id="c--1">C++ 语言实现</h3>

<p>实现思路：首先将文件或路径名转换为一个<code>string</code>类，使用它的成员函数<code>rfind</code>找到最后一个<code>.</code>的位置，最后使用<code>substr</code>成员函数返回<code>.</code>后的所有内容，即得后缀名。</p>

<p>{% codeblock lang:c++ get_filename_extension %}
using std::string;
string getFileExt(const string&amp; s)
{
    size_t i = s.rfind(‘.’, s.length());
    if(i != string::npos)
    {
        return(s.substr(i+1, s.length() - i));
    }
    return (“”);
}
{% endcodeblock %}</p>

<h3 id="shell-">Shell 脚本实现</h3>

<p>{% codeblock lang:sh get_filename_extension %}
#!/bin/sh
fullfilename=$1
filename=$(basename “$fullfilename”)
fname=”${filename%.<em>}”
ext=”${filename##</em>.}”</p>

<p>echo “Input File:$fullfilename”
echo “Filename without Path:$filename”
echo “Filename without Extension:$fname”
echo “File Extension without Name:$ext”
{% endcodeblock %}</p>

<h2 id="section-1">调试信息分级打印</h2>

<p>在工作中，经常遇到需要将调试信息分级打印的情况。比如在码流播放中可能默认要打印出码流的宽高、码流的 CODEC 类型等基本信息，可以定义此类信息级别为<code>LOG_INFO</code>级别；
码流播放时，可能会出现错误，此类信息级别为<code>LOG_ERROR</code>等。</p>

<p>实现思路：将需要打印的信息级别与默认打印信息级别进行比较，级别高时，将信息打印出来；级别低时，不打印信息。</p>

<p>{% codeblock lang:c log_level %}</p>

<h1 id="define-logdefault-2">define LOG_DEFAULT 2</h1>
<p>#define LOG_NONE    (-1)
#define LOG_ERROR   0
#define LOG_WARNING 1
#define LOG_INFO    2
#define LOG_DEBUG   3</p>

<p>void Printf(int i_level, const char *psz_fmt, va_list arg)
{
   char *psz_prefix;
   switch(i_level) 
   {
        case LOG_ERROR:
            psz_prefix = “error”;
            break;
        case LOG_WARNING:
            psz_prefix = “warning”;
            break;
        case LOG_INFO:
            psz_prefix = “info”;
            break;
        case LOG_DEBUG:
            psz_prefix = “debug”;
            brengak;
        default:
            psz_prefix = “unknown”;
            break;
   }
   vfprintf(stderr, psz_fmt, arg);
}</p>

<p>void LOG_PRINT(int i_level, const char *psz_fmt, …); 
void LOG_PRINT(int i_level, const char *psz_fmt, …)
{
    if(i_level &lt;= LOG_DEFAULT)
    {
        va_list arg;
        va_start(arg, psz_fmt);
        Printf(i_level, psz_fmt, arg);
        va_end(arg);
    }
}</p>

<p>{% endcodeblock %}</p>

<h2 id="section-2">分析特定格式的文件</h2>

<p>工作中在验证芯片的<code>vdec</code>模块是否正常工作时，需要大量的跑一些码流，这些码流通常会放到一个<code>filelist</code>中，因为需要测试的项不同，此时就可以
通过按照一定的格式并列存放这些码流，例如根据不同的<code>codec</code>、测试比较<code>YUV</code>或<code>CRC</code>，是要连续测试，还是要中途停止方便<code>Debug</code>问题，我们可以按照如下格式对<code>filelist</code>进行定义：</p>

<p><code>
Codec_Type  Compare_Type Test_Type Bitstream_Full_Path
</code></p>

<p>对于上面这种<code>filelist</code>，可以通过<code>fscanf</code>来逐个的获取特定的字符串，并通过<code>feof</code>来判断文件文件是否读取完毕， 之后使用<code>strcmp</code>来与特定的字符串进行匹配。例如，有如下的一个<code>filelist.txt</code>：</p>

<p><code>
HEVC Compare_CRC Debug F:\FFmpeg\hevc_bitstream1.bin
H264 Compare_YUV Release F:\FFmpeg\h264_bitstream2.bin
</code></p>

<p>分析<code>filelist.txt</code>示例代码：</p>

<p>{% codeblock lang:c parse_filelist %}
char Codec_Type[10];
char Compare_Type[10];
char Release_Type[10];
char Bitstream_Path[200];</p>

<p>FILE *pFile = fopen(“./filelist.txt”, “rb”);
if(pFile == NULL)
{
    fprintf(stderr, “open file fail %s”, strerror(errno));
}</p>

<p>while(!feof(pFile))
{
    fscanf(pFile, “%s %s %s %s”, Codec_Type, Compare_Type, Release_Type, Bitstream_Path);
}</p>

<p>if(!strcmp(“HEVC”, Codec_Type)) printf(“Codec Type is HEVC\n”);
if(!strcmp(“H264”, Codec_Type)) printf(“Codec Type is H264\n”);
…</p>

<p>if(!strcasecmp(“hevc”, Codec_Type)) printf(“Codec Type is HEVC\n”);
…
{% endcodeblock %}</p>

<p>注意上面表示出来了通过<code>strcmp</code>来判断<code>Codec_Type</code>的类型，后面的<code>Compare_Type</code>可以用同样的方法来给出。</p>

<p>在使用过程中，人们并不会特别在意字母的大小写，但要表达的意思通常是一样的，比如<code>HEVC</code><code>hevc</code><code>Hevc</code>通过都是一样的，如果此时还用<code>strcmp</code>来判断，会出错，为此，我们提出了<code>strcasecmp</code>的使用方法，来避免大小写带来的问题，这也算是编写类似代码的一个小技巧。</p>

<h2 id="fopen-">fopen 函数个数限制</h2>

<p>严格来讲，这个并不是编程的一些小的技巧，而是自己在工作中遇到的一个小问题，最近在每晚上跑测试时，经常遇到一晚上跑完 503 个测试后，程序就会崩溃掉，给出的提示信息是”Open File Fail”,起初是通过观察<code>errno</code>的类型来<code>Debug</code>出错的原因，最后定位到问题是，
对每个文件都打开了两次，而关闭只有一次，导致文件描述符的个数爆掉了。这个问题的原因是在不同的系统中，都会有对文件描述符的最大个数有一定的限制。</p>

<p>在&lt;UNIX环境高级编程:文件I/O&gt;中有这样的解释：</p>

<blockquote>
  <p>当读或写一个文件时，使用<code>open</code>返回的文件描述符标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。文件描述符的变化范围是<code>0~OPEN_MAX</code>。</p>
</blockquote>

<p>关于文件描述符的最大个数问题，从<code>stackoverflow</code>上找到了以下几个问题的回复，可参考：</p>

<p><a href="https://stackoverflow.com/questions/870173/is-there-a-limit-on-number-of-open-files-in-windows">1.Is there a limit on number of open files in Windows</a><br />
<a href="https://stackoverflow.com/questions/17931583/maximum-number-of-files-that-can-be-opened-by-c-fopen-in-linux">2.maximum-number-of-files-that-can-be-opened-by-c-fopen-in-linux</a><br />
<a href="https://stackoverflow.com/questions/3184345/fopen-problem-too-many-open-files">3.fopen-problem-too-many-open-files</a></p>

<p>关于<code>fopen</code>的使用，通常会判断返回值是否<code>NULL</code>来判断是否打开成功，其实除此之外，还可以继续监测出错的类型<code>errno</code>，并用<code>strerror()</code>函数直接显示出错的具体原因。技巧如下：</p>

<p>{% codeblock lang:c fopen_tips %}
#include <error.h></error.h></p>

<p>FILE *pFile = fopen(“file_full_path”, “rb”);
if(pFile == NULL)
{
    fprintf(stderr, “Open File Fail:%s\n”, strerror(errno));
}
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 使用小技巧总结]]></title>
    <link href="http://lazybing.github.io/blog/2017/05/01/linux-tips/"/>
    <updated>2017-05-01T19:03:52-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/05/01/linux-tips</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">快速搜索命令</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">命令行快捷键</a></li>
  <li><a href="#vmdk" id="markdown-toc-vmdk">清理虚拟机vmdk文件大小</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">其他技巧</a></li>
</ul>

<p>Linux 使用过程中，有些特殊的小技巧能够很好地提高效率。在此记录使用过程中的惊艳的小技巧。</p>

<!--more-->

<h2 id="section">快速搜索命令</h2>

<p>Linux 使用大部分是在命令行下进行的，某些命令是前面使用到的，此时我们不想重新完整的输入命令，而是想根据命令中的某些关键字搜索到该命令，然后直接执行。
此时第一个想到的方法可能是<code>history</code>命令，然后复制粘贴，其实还有一个更智能的命令搜索命令<code>Ctrl+r</code>。执行完<code>Ctrl+r</code>后，可直接输出要查找的命令中的某个
关键字。然后直接回车即可！非常方便，尤其是命令行比较长的时候。</p>

<h2 id="section-1">命令行快捷键</h2>

<p>Linux 命令行经常遇到输入错误，需要修改的时候，此时如果命令行特别长，想要用方向键或退格键来进行修改删除，速度会特别慢，其实 Linux 命令行也有
很多快捷键可以使用。具体有如下几个：</p>

<ul>
  <li><code>Ctrl+a</code> 移至命令行行首</li>
  <li><code>Ctrl+e</code> 移至命令行行尾</li>
  <li><code>Ctrl+u</code> 从光标处删除至命令行行首</li>
  <li><code>Ctrl+k</code> 从光标处删除至命令行行尾</li>
</ul>

<p>{% img /images/linux_tips/linuxcommandshortcut.png %}</p>

<h2 id="vmdk">清理虚拟机vmdk文件大小</h2>

<p>MacOS 虚拟机在使用过程中，占用空间越来越大，分配的40G竟然有点卡了，找了好多办法都没成功，最后还是通过<code>VMVare Tools</code>工具瘦身成功的，节省了接近 15G 的空间。方法很简单，只需要一条命令即可：</p>

<p><code>
sudo  /Library/Application\ Support/VMware\ Tools/vmware-tools-cli disk shrink  /
</code></p>

<h2 id="section-2">其他技巧</h2>

]]></content>
  </entry>
  
</feed>
