<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:总结积累 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/zong-jie-ji-lei/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-02-23T06:39:17-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAR、DAR、SAR分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse/"/>
    <updated>2016-11-16T08:11:53-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">Aspect Ratio</a> 是图片的宽高比。<br />
<!--more--></p>

<p>主要有 3 种<code>aspect ratio</code>：PAR(Pixel Aspect Ratio)、DAR(Display Aspect Ratio)、SAR(Sample Aspect Ratio)。</p>

<p>PAR(Pixel Aspect Ratio): 像素纵横比；<br />
DAR(Display Aspect Ratio):显示纵横比；<br />
SAR(Sample Aspect Ratio):采样纵横比；</p>

<p>三者的关系为PAR x SAR = DAR 或者 PAR = DAR / SAR。</p>

<p>PAR 示例如下：</p>

<p><img src="/images/PAR_DAR_SAR/220px-PAR-1to1.svg.png" title="‘1to1_PAR’" ></p>

<p><img src="/images/PAR_DAR_SAR/220px-PAR-2to1.svg.png" title="‘2to1_PAR’" ></p>

<p>DAR 示例如下：</p>

<p><img src="/images/PAR_DAR_SAR/Aspect_ratio_16_9_example3.jpg" title="‘16to9_DAR’" ></p>

<p><img src="/images/PAR_DAR_SAR/Aspect_ratio_4_3_example.jpg" title="‘4to3_DAR’" ></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之TS]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/26/ts-parse-format/"/>
    <updated>2016-07-26T04:57:15-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/26/ts-parse-format</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/MPEG_transport_stream">TS</a>是MPEG2-TS 的简称，是“Transport Stream”的缩写。一段 TS 流，必须包含 PAT 包、PMT 包、多个音频包、多个视频包、多个 PCR 包以及其他信息包。
<!--more--></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之MP4]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/26/mp4-parse-format/"/>
    <updated>2016-07-26T04:31:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/26/mp4-parse-format</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MP4</a>是由许多 Box 和 FullBox 组成的，每个 Box 是由 Header 和 Data 组成的，FullBox 是 Box 的扩展，Box 结构的基础上在 Header 中增加 8bits version 和 24bits flags。
<!--more--></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之AVI]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/24/avi-parse-format/"/>
    <updated>2016-07-24T01:04:52-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/24/avi-parse-format</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基本数据结构</a></li>
  <li><a href="#avi-" id="markdown-toc-avi-">AVI 文件类型</a></li>
  <li><a href="#avi--1" id="markdown-toc-avi--1">AVI 文件布局</a>    <ul>
      <li><a href="#mainaviheaderavih" id="markdown-toc-mainaviheaderavih">MainAVIHeader(avih)</a></li>
      <li><a href="#stream-header-list" id="markdown-toc-stream-header-list">Stream Header List</a></li>
      <li><a href="#stream-header-list-elementstrh" id="markdown-toc-stream-header-list-elementstrh">Stream Header List Element(strh)</a></li>
      <li><a href="#stream-header-list-elementstrf" id="markdown-toc-stream-header-list-elementstrf">Stream Header List Element(strf)</a></li>
      <li><a href="#stream-header-list-elementindx" id="markdown-toc-stream-header-list-elementindx">Stream Header List Element(indx)</a></li>
      <li><a href="#stream-header-list-elementstrn" id="markdown-toc-stream-header-list-elementstrn">Stream Header List Element(strn)</a></li>
    </ul>
  </li>
  <li><a href="#avi-indexes" id="markdown-toc-avi-indexes">AVI Indexes</a>    <ul>
      <li><a href="#old-style-index" id="markdown-toc-old-style-index">old style index</a></li>
      <li><a href="#open-dml-index" id="markdown-toc-open-dml-index">Open-DML Index</a></li>
      <li><a href="#using-the-open-dml-index" id="markdown-toc-using-the-open-dml-index">Using the Open-DML index</a></li>
    </ul>
  </li>
  <li><a href="#the-movi---lists" id="markdown-toc-the-movi---lists">The movi - Lists</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">参考文献</a></li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">AVI</a> 是音视频交错(Audio Video Interleaved)的缩写，它是 Microsoft 公司开发的一种符合 RIFF 文件规范的数字音频与视频文件格式。
<!--more--></p>

<h2 id="section">基本数据结构</h2>

<p>AVI 文件中有两种类型结构:Chunks 和 Lists。</p>

<p><code>
//Chunks
typedef struct {
    DWORD dwFourCC;
    DWORD dwSize;
    BYTE  data[dwSize];
}CHUNK;
//Lists
typedef struct{
    DWORD dwList;
    DWORD dwSize;
    DWORD dwFourCC;
    BYTE  data[dwSize - 4];
}LIST;
</code></p>

<p>一个包含了<code>video</code>、<code>audio</code>或<code>subtitle</code>数据的<code>chunk</code>使用一个<code>dwFourCC</code>，
<code>dwFourCC</code>包含 2 个十六进制数字表示 stream number，2 个字母表示数据类型( dc 表示 video， wb 表示 audio, tx 表示 text)。
<code>dwFourCC</code>和<code>dwSize</code>在<code>Chunks</code>和<code>Lists</code>中有相同的含义。</p>

<p><code>dwFourCC</code>描述chunk 的类型（如<code>hdrl</code>表示 <code>header list</code>），<code>dwSize</code>表示该 chunk 或 list 的大小，
包含<code>dwSize</code>后的所有 byte。在 List 中，<code>dwSize</code>包含了<code>dwFourCC</code>所占有的4 bytes.</p>

<p><code>dwList</code>的值可以是<code>RIFF（RIFF-List</code>或<code>LIST(List)</code>。</p>

<h2 id="avi-">AVI 文件类型</h2>

<p>通常来讲，有 3 种类型的 AVI 文件：</p>

<ul>
  <li>AVI 1.0, 最初始的 AVI 文件类型。</li>
  <li>Open-DML, AVI 文件格式的扩展。1.02版本相对于1.0版本有两个提高：基本没有文件大小的限制、负载降低了33%。</li>
  <li>Hybride-Files，Open-DML 文件因为兼容的原因有个额外的限制，Hybride-Files 虽然不是官方致命的文件类型，但确实是一个不错的类型。</li>
</ul>

<h2 id="avi--1">AVI 文件布局</h2>
<p>一个<code>dwFourCC=AVI</code>的<code>RIFF-List</code>称为<code>RIFF-AVI-List</code>，
一个<code>dwFourCC=AVIX</code>的<code>RIFF-List</code>称为<code>RIFF-AVIX-List</code>。</p>

<p>每个 AVI 文件都有如下布局：
<code>
RIFF AVI    //mandatory
{RIFF AVIX} //only for Open-DML files
</code></p>

<p>并非之受限于 uint32 的限制，文件大小的极限并非 4G,而是</p>

<ul>
  <li>对于 AVI 1.0: sizeof(RIFF-AVI) &lt; 2G</li>
  <li>对于 Open-DML, sizeof(RIFF-AVI) &lt; 1G(!!), sizeof(RIFF-AVIX) &lt; 2G</li>
</ul>

<p>一般来讲，RIFF-AVI-Lists被创建的越小越好。</p>

<h3 id="mainaviheaderavih">MainAVIHeader(avih)</h3>

<p><code>avih</code>结构定义如下：<br />
```
typedef struct
{
    DWORD dwMicroSecPerFrame;   //frame display rate(or 0)
    DWORD dwMaxBytesPerSec;     //max transfer rate
    DWORD dwPaddingGranularity; //pad to multiples of this size
    DWORD dwFlags               //the ever-present flags
    DWORD dwTotalFrames;        //frames in file
    DWORD dwInitialFrames;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;</p>

<pre><code>DWORD dwWidth;
DWORD dwHeight;

DWORD dwReserved[4]; }MainAVIHeader; ``` * dwMicroSecPerFrame 以微妙为单位，包含了一个视频帧的持续时间。该值可以被忽略。注意，某些程序中可能会把它写成 framerate 值，因此 dwMicroSecPerFrame 并不可靠。   * dwMaxBytesPerSec 文件中最大的数据率，该值同样的不是特别重要。   * dwPaddingGranularity 填充的数据。   * dwFlags `AVIF_HASINDEX`（该文件有index）、`AVIF_MUSTUSEINDEX`（）、`AVIF_ISINTERLEAVED` `AVIF_WASCAPTUREFILE` `AVIF_COPYRIGHTED` `AVIF_TRUSTCKTYPE`。   * dwTotalFrames 包含了`RIFF-AVI list`中视频帧数。如果文件中包含`RIFF-AVIX-Lists`，它不会包含其中的视频帧。因为某些`muxer`会写一些错误的值，因此该值同样的不可靠。   * dwInitialFrames 忽略 * dwStreams 文件中`streams`的数量。   * dwSuggestedBufferSize 文件chunks 所需要的内存大小。同样不要高估它的可靠性。   * dwWidth 视频的宽。   * dwHeight 视频的高。  
</code></pre>

<h3 id="stream-header-list">Stream Header List</h3>

<p>针对每个<code>stream</code>都有一个<code>strl</code>，如果<code>strl</code>的数量与<code>MainAVIHeader::dwStreams</code>不同，就需要发出一个<code>fatal error report</code>。</p>

<h3 id="stream-header-list-elementstrh">Stream Header List Element(strh)</h3>

<p><code>
typedef struct{
    FOURCC fccType;
    FOURCC fccHandler;
    DWORD  dwFlags;
    WORD   wPriority;
    WORD   wLanguage;
    DWORD  dwInitialFrames;
    DWORD  dwScale;
    DWORD  dwRate;  // dwRate / dwScale == samples /second
    DWORD  dwStart;
    DWORD  dwLength;  //In units above
    DWORD  dwSuggestedBufferSize;
    DWORD  dwQuality;
    DWORD  dwSampleSize;
    RECT   rcFrame;
}AVIStreamHeader;
</code></p>

<ul>
  <li>fccType <code>vids</code>代表 video, <code>auds</code>代表 audio, <code>txts</code>代表 subtitle。</li>
  <li>fccHandler</li>
  <li>dwFlags <code>AVISF_DISABLED</code> <code>AVISF_VIDEO_PALCHANGES</code></li>
  <li>dwInitialFrames</li>
  <li>dwRate / dwScale = samples / second(audio) or frames / second(video)</li>
  <li>dwStart</li>
  <li>dwLength</li>
  <li>dwSuggestedBufferSize</li>
  <li>dwQuality</li>
  <li>dwSampleSize</li>
</ul>

<h3 id="stream-header-list-elementstrf">Stream Header List Element(strf)</h3>

<p><code>strf</code>的结构依据媒体类型。对于 video，使用<code>BITMAPINFOHEADER</code>结构，而 audion，使用<code>WAVEFORMATEX</code>结构。</p>

<p><code>
typedef struct tagBITMAPINFOHEADER{
    DWORD biSize;
    LONG  biWidth;
    LONG  biHeight;
    WORD  biPlanes;
    WORD  biBitCount;
    DWORD biCompression;
    DWORD biSizeImage;
    LONG  biXPelsPerMeter;
    LONG  biYPelsPerMeter;
    DWORD biClrUsed;
    DWORD biClrImportant;
}BITMAPINFOHEADER, *PBITMAPINFOHEADER;
</code></p>

<ul>
  <li>biSize  该结构体所需要的 byte 大小。</li>
  <li>biWidth 图像的宽度。如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，<code>biWidth</code>成员相应的指解压缩后的<code>JPEG</code>或<code>PNG</code>图像文件的宽。</li>
  <li>biHeight 位图的高度。如果<code>biHeight</code>是正数，位图是自底向上的<code>DIB</code>,它的原点是右下角地点；。如果<code>biHeight</code>是正数，位图是自顶向下的<code>DIB</code>,它的原点是右上角地点；
如果<code>biHeight</code>是负数，<code>biCompression</code>要么是<code>BI_RGB</code>或<code>BI_BITFIELDS</code>，自顶向下的<code>DIB</code>不能被压缩。
如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，则<code>biHeight</code>程序分别指解压缩后的<code>JPEG</code>或<code>PNG</code>图像的高。</li>
  <li>biPlanes 目标设备的<code>planes</code>的数量，该值必须是1。</li>
  <li>biBitCount 每个像素所用的 bit 数，<code>BITMAPINFOHEADER</code>的成员<code>biBitCount</code>决定了每个 pixel 所占的 bit 数、以及位图中表示颜色所能用到的最大数。该值可以是<code>0/1/4/8/16/24/32</code>。</li>
  <li>biCompression 压缩的自底向上的位图的压缩类型，可以是<code>BI_RGB</code><code>BI_RLE8</code><code>BI_RLE4</code><code>BI_BITFIELDS</code><code>BI_JPEG</code><code>BI_PNG</code>.</li>
  <li>biSizeImage 图像的大小，单位 byte。如果是<code>BI_RGB</code>位图，该值被设置为0。如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，该值分别指示 JPEG 或 PNG 图像的大小。</li>
  <li>biXPelsPerMeter 水平分辨率。</li>
  <li>biYPelsPerMeter 垂直分辨率。</li>
  <li>biClrUsed 颜色表中该位图实际使用的颜色指针。</li>
  <li>biClrImportant</li>
</ul>

<p><code>
typedef struct{
    WORD  wFormatTag;
    WORD  nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD  nBlocAlign;
    WORD  wBitsPerSample;
    WORD  cbSize;
}WAVEFORMATEX;
</code>
(待续…)</p>

<h3 id="stream-header-list-elementindx">Stream Header List Element(indx)</h3>

<p>该结构请看下面的<code>AVI index</code>小结。</p>

<h3 id="stream-header-list-elementstrn">Stream Header List Element(strn)</h3>

<p>该部分包含了<code>stream</code>的的名字。该名字只能使用标准的<code>ASCII</code>，尤其不能使用<code>UTF-8</code>。</p>

<h2 id="avi-indexes">AVI Indexes</h2>

<h3 id="old-style-index">old style index</h3>

<p><code>
AVIINDEXENTRY index_entry[n]  
typedef struct{
    DWORD ckid;
    DWORD dwFlags;
    DWORD dwChunkOffset;
    DWORD dwChunkLength;
}AVIINDEXENTRY;
</code></p>

<h3 id="open-dml-index">Open-DML Index</h3>

<p><code>
typedef struct _aviindex_chunk{
    FOURCC fcc;
    DWORD  cb;
    WORD   wLongsPerEntry;
    BYTE   bIndexSubType;
    BYTE   bIndexType;
    DWORD  nEntriesInUse;
    DWORD  dwChunkId;
    DWORD  dwReserved[3];
    struct _aviindex_entry{
        DWORD adw[wLongsPerEntry];
    }aIndex[];
}AVIINDEXCHUNK;
</code></p>

<h3 id="using-the-open-dml-index">Using the Open-DML index</h3>

<h2 id="the-movi---lists">The movi - Lists</h2>

<p><code>Movi-List</code>包含<code>Video</code><code>Audio</code><code>Subtitle</code>和<code>index data</code>。它们可以打包进<code>rec-List</code>。如：</p>

<p><code>
LIST movi
    LIST rec
        01wb
        02wb
        03dc
    LIST rec
        01wb
        02wb
    LIST rec
        ...
        ...
        ix01
        ix02
        ...
</code>
其中的<code>chunks</code> ID 分别定义如下：</p>

<ul>
  <li>..wb : audio chunk</li>
  <li>..dc : video chunk</li>
  <li>..tx : subtitle chunk</li>
  <li>ix.. : standard index block</li>
</ul>

<h2 id="section-1">参考文献</h2>

<ol>
  <li><a href="http://www.ezr8.com/avi.html">What is avi?</a></li>
  <li><a href="http://pvdtools.sourceforge.net/aviformat.txt">BETA DOCUMENTATION OF RIFF-AVI FILE FORMAT</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">Audio Video Interleave</a></li>
  <li><a href="http://blog.csdn.net/jszj/article/category/614875">AVI 文件格式</a></li>
  <li><a href="http://blog.csdn.net/njuitjf/article/details/5680632">AVI 文件解析</a></li>
  <li><a href="https://www.ffmpeg.org/doxygen/0.6/avidec_8c-source.html">FFmpeg AVI</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之FLV]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/24/flv-parse/"/>
    <updated>2016-07-24T00:22:21-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/24/flv-parse</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Flash_Video">FLV</a> 是 FLASH VIDEO 的简称，FLV 流媒体是随着Flash MX 的推出发展而来的视频格式。FLV 一般由文件头(FLV header) 和文件体(FLV body) 组成。其中文件体(FLV body)由一些列tag组成，tag又可分成三类:audio/video/script，分别代表音频流、视频流、脚本流(关键字或文件信息之类)。
<!--more-->
在 FLV 文件中，每种 tag 类型都由一个单独的流组成，即在 FLV 文件中最多有一个视频流和一个音频流，对同一种类型的流，FLV 中不能够定义多个独立的流。
与 SWF 文件不同,FLV 文件以大字节序存储多字节。比如，0x300(0x12C) 在 SWF 文件中的字节序为 0x2C 0x01,在FLV 文件中则为 0x01 0x2C。</p>

<h2 id="flv-header">FLV Header</h2>
<p>以 FLV Header <code>46 4C 56 01 05 00 00 00 09</code>为例：</p>

<p><img src="/images/flvparse/flv_header.png"></p>

<p>FLV Header 的前三个字节是固定的<code>FLV</code>的 ASCII 码的值<code>0x46 0x4C 0x56</code>; 接下来的一个字节表示 FLV 的版本号,例如 0x01 代表 FLV 版本号为 1。第 5 个字节中的第0位和第2位分别表示video和audio的存在情况（1表示存在，0表示不存在）,其余6位必须为0.最后的4字节表示FLV Header的长度，对于version 1，此处为9.</p>

<h2 id="flv-file-body">FLV File Body</h2>
<p>FLV Header 之后，FLV 文件的剩余部分由tag组成，它们交替如下：</p>

<table>
  <tbody>
    <tr>
      <td>PreviousTagSize0</td>
      <td>Tag1</td>
      <td>PreviousTagSize1</td>
      <td>Tag2</td>
      <td>……</td>
      <td>PreviousTagSizeN-1</td>
      <td>TagN</td>
      <td>PreviousTagSizeN</td>
    </tr>
  </tbody>
</table>

<h2 id="flv-tags">FLV tags</h2>
<p>FLV tags 有以下几个字段构成：8bit的<code>TagType</code>、24bit的<code>DataSize</code>、24bit的<code>TimeStamp</code>、8bit的<code>TimeStampExtended</code>、24bit的<code>StreamID</code>以及最后的<code>Data</code>。</p>

<p><code>TagType</code>指该Tag的类型，8 代表 Audio，9 代表 Video，18 代表 Script Data。</p>

<p><code>DataSize</code>指定后面的<code>Data</code>字段的大小。</p>

<p>以 Tag <code>12 00 12 A9 00 00 00 00 00 00 00 02 00 0A……</code>为例，<code>0x12</code>代表该 tag 为script data，<code>00 12 A9</code>代表该 tag 的 DataSize 为 681 byte，<code>00 00 00</code>代表该 tag 的 TimeStamp 为 0，<code>00</code>代表该 tag 的 TimeStampExtended 为 0，StreamID 总是 0，接下来的 681 byte 为script data 的内容。</p>

<p>播放过程中，FLV tag的时间信息完全依赖于 FLV 时间戳，内置的其他时间信息都被忽略掉。</p>

<h3 id="audio-tags">Audio tags</h3>

<h3 id="video-tags">Video tags</h3>

<p>Video Tag 与 SWF 文件格式中的 VideoFrame Tag 类似，它们的 Payload 数据是同一的。关于 SWF 文件格式的介绍，请看<a href="www.adobe.com/go/swf_file_format">SWF(File Format Specification)</a>。</p>

<p>以<code>09 00 00 2D 00 00 00 00 00 00 00 17 00 00 00 00 01 4D 40 1F FF E1 00 19 67 4D 40 ……</code>为例，<code>09</code>表示 Tag Type 为 Video Tag;<code>00 00 2D</code>表示 DataSize 为 45；<code>00 00 00</code>表示 Timestamp 为 0；<code>00</code>表示 TimestampExtended 为 0；<code>00 00 00</code>表示 StreamID 为 0；<code>17</code>中的 8 bit，其中前 4 bit<code>1</code>表示 FrameType 为 keyframe,后 4 bit<code>7</code>表示 CodecID 为 AVC；之后的 45 byte 为 VideoData;</p>

]]></content>
  </entry>
  
</feed>
