<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 总结积累 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/zong-jie-ji-lei/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-01-12T07:54:01-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAR、DAR、SAR分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse/"/>
    <updated>2016-11-16T08:11:53-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">Aspect Ratio</a> 是图片的宽高比。<br />
<!--more--></p>

<p>主要有 3 种<code>aspect ratio</code>：PAR(Pixel Aspect Ratio)、DAR(Display Aspect Ratio)、SAR(Sample Aspect Ratio)。</p>

<p>PAR(Pixel Aspect Ratio): 像素纵横比；<br />
DAR(Display Aspect Ratio):显示纵横比；<br />
SAR(Sample Aspect Ratio):采样纵横比；</p>

<p>三者的关系为PAR x SAR = DAR 或者 PAR = DAR / SAR。</p>

<p>PAR 示例如下：</p>

<p><img src="/images/PAR_DAR_SAR/220px-PAR-1to1.svg.png" title="‘1to1_PAR’" ></p>

<p><img src="/images/PAR_DAR_SAR/220px-PAR-2to1.svg.png" title="‘2to1_PAR’" ></p>

<p>DAR 示例如下：</p>

<p><img src="/images/PAR_DAR_SAR/Aspect_ratio_16_9_example3.jpg" title="‘16to9_DAR’" ></p>

<p><img src="/images/PAR_DAR_SAR/Aspect_ratio_4_3_example.jpg" title="‘4to3_DAR’" ></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之TS]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/26/ts-parse-format/"/>
    <updated>2016-07-26T04:57:15-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/26/ts-parse-format</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/MPEG_transport_stream">TS</a>是MPEG2-TS 的简称，是“Transport Stream”的缩写。一段 TS 流，必须包含 PAT 包、PMT 包、多个音频包、多个视频包、多个 PCR 包以及其他信息包。
<!--more--></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之MP4]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/26/mp4-parse-format/"/>
    <updated>2016-07-26T04:31:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/26/mp4-parse-format</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MP4</a>是由许多 Box 和 FullBox 组成的，每个 Box 是由 Header 和 Data 组成的，FullBox 是 Box 的扩展，Box 结构的基础上在 Header 中增加 8bits version 和 24bits flags。
<!--more--></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之AVI]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/24/avi-parse-format/"/>
    <updated>2016-07-24T01:04:52-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/24/avi-parse-format</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基本数据结构</a></li>
  <li><a href="#avi-" id="markdown-toc-avi-">AVI 文件类型</a></li>
  <li><a href="#avi--1" id="markdown-toc-avi--1">AVI 文件布局</a>    <ul>
      <li><a href="#mainaviheaderavih" id="markdown-toc-mainaviheaderavih">MainAVIHeader(avih)</a></li>
      <li><a href="#stream-header-list" id="markdown-toc-stream-header-list">Stream Header List</a></li>
      <li><a href="#stream-header-list-elementstrh" id="markdown-toc-stream-header-list-elementstrh">Stream Header List Element(strh)</a></li>
      <li><a href="#stream-header-list-elementstrf" id="markdown-toc-stream-header-list-elementstrf">Stream Header List Element(strf)</a></li>
      <li><a href="#stream-header-list-elementindx" id="markdown-toc-stream-header-list-elementindx">Stream Header List Element(indx)</a></li>
      <li><a href="#stream-header-list-elementstrn" id="markdown-toc-stream-header-list-elementstrn">Stream Header List Element(strn)</a></li>
    </ul>
  </li>
  <li><a href="#avi-indexes" id="markdown-toc-avi-indexes">AVI Indexes</a></li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">AVI</a> 是音视频交错(Audio Video Interleaved)的缩写，它是 Microsoft 公司开发的一种符合 RIFF 文件规范的数字音频与视频文件格式。
<!--more--></p>

<h2 id="section">基本数据结构</h2>

<p>AVI 文件中有两种类型结构:Chunks 和 Lists。</p>

<p><code>
//Chunks
typedef struct {
    DWORD dwFourCC;
    DWORD dwSize;
    BYTE  data[dwSize];
}CHUNK;
//Lists
typedef struct{
    DWORD dwList;
    DWORD dwSize;
    DWORD dwFourCC;
    BYTE  data[dwSize - 4];
}LIST;
</code></p>

<p>一个包含了<code>video</code>、<code>audio</code>或<code>subtitle</code>数据的<code>chunk</code>使用一个<code>dwFourCC</code>，
<code>dwFourCC</code>包含 2 个十六进制数字表示 stream number，2 个字母表示数据类型( dc 表示 video， wb 表示 audio, tx 表示 text)。
<code>dwFourCC</code>和<code>dwSize</code>在<code>Chunks</code>和<code>Lists</code>中有相同的含义。</p>

<p><code>dwFourCC</code>描述chunk 的类型（如<code>hdrl</code>表示 <code>header list</code>），<code>dwSize</code>表示该 chunk 或 list 的大小，
包含<code>dwSize</code>后的所有 byte。在 List 中，<code>dwSize</code>包含了<code>dwFourCC</code>所占有的4 bytes.</p>

<p><code>dwList</code>的值可以是<code>RIFF（RIFF-List</code>或<code>LIST(List)</code>。</p>

<h2 id="avi-">AVI 文件类型</h2>

<p>通常来讲，有 3 种类型的 AVI 文件：</p>

<ul>
  <li>AVI 1.0, 最初始的 AVI 文件类型。</li>
  <li>Open-DML, AVI 文件格式的扩展。1.02版本相对于1.0版本有两个提高：基本没有文件大小的限制、负载降低了33%。</li>
  <li>Hybride-Files，Open-DML 文件因为兼容的原因有个额外的限制，Hybride-Files 虽然不是官方致命的文件类型，但确实是一个不错的类型。</li>
</ul>

<h2 id="avi--1">AVI 文件布局</h2>
<p>一个<code>dwFourCC=AVI</code>的<code>RIFF-List</code>称为<code>RIFF-AVI-List</code>，
一个<code>dwFourCC=AVIX</code>的<code>RIFF-List</code>称为<code>RIFF-AVIX-List</code>。</p>

<p>每个 AVI 文件都有如下布局：
<code>
RIFF AVI    //mandatory
{RIFF AVIX} //only for Open-DML files
</code></p>

<p>并非之受限于 uint32 的限制，文件大小的极限并非 4G,而是<br />
* 对于 AVI 1.0: sizeof(RIFF-AVI) &lt; 2G
* 对于 Open-DML, sizeof(RIFF-AVI) &lt; 1G(!!), sizeof(RIFF-AVIX) &lt; 2G<br />
一般来讲，RIFF-AVI-Lists被创建的越小越好。</p>

<h3 id="mainaviheaderavih">MainAVIHeader(avih)</h3>

<p><code>avih</code>结构定义如下：<br />
```
typedef struct
{
    DWORD dwMicroSecPerFrame;   //frame display rate(or 0)
    DWORD dwMaxBytesPerSec;     //max transfer rate
    DWORD dwPaddingGranularity; //pad to multiples of this size
    DWORD dwFlags               //the ever-present flags
    DWORD dwTotalFrames;        //frames in file
    DWORD dwInitialFrames;
    DWORD dwStreams;
    DWORD dwSuggestedBufferSize;</p>

<pre><code>DWORD dwWidth;
DWORD dwHeight;

DWORD dwReserved[4]; }MainAVIHeader; ``` * dwMicroSecPerFrame 以微妙为单位，包含了一个视频帧的持续时间。该值可以被忽略。注意，某些程序中可能会把它写成 framerate 值，因此 dwMicroSecPerFrame 并不可靠。   * dwMaxBytesPerSec 文件中最大的数据率，该值同样的不是特别重要。   * dwPaddingGranularity 填充的数据。   * dwFlags `AVIF_HASINDEX`（该文件有index）、`AVIF_MUSTUSEINDEX`（）、`AVIF_ISINTERLEAVED` `AVIF_WASCAPTUREFILE` `AVIF_COPYRIGHTED` `AVIF_TRUSTCKTYPE`。   * dwTotalFrames 包含了`RIFF-AVI list`中视频帧数。如果文件中包含`RIFF-AVIX-Lists`，它不会包含其中的视频帧。因为某些`muxer`会写一些错误的值，因此该值同样的不可靠。   * dwInitialFrames 忽略 * dwStreams 文件中`streams`的数量。   * dwSuggestedBufferSize 文件chunks 所需要的内存大小。同样不要高估它的可靠性。   * dwWidth 视频的宽。   * dwHeight 视频的高。  
</code></pre>

<h3 id="stream-header-list">Stream Header List</h3>

<p>针对每个<code>stream</code>都有一个<code>strl</code>，如果<code>strl</code>的数量与<code>MainAVIHeader::dwStreams</code>不同，就需要发出一个<code>fatal error report</code>。</p>

<h3 id="stream-header-list-elementstrh">Stream Header List Element(strh)</h3>

<p><code>
typedef struct{
    FOURCC fccType;
    FOURCC fccHandler;
    DWORD  dwFlags;
    WORD   wPriority;
    WORD   wLanguage;
    DWORD  dwInitialFrames;
    DWORD  dwScale;
    DWORD  dwRate;  // dwRate / dwScale == samples /second
    DWORD  dwStart;
    DWORD  dwLength;  //In units above
    DWORD  dwSuggestedBufferSize;
    DWORD  dwQuality;
    DWORD  dwSampleSize;
    RECT   rcFrame;
}AVIStreamHeader;
</code></p>

<ul>
  <li>fccType <code>vids</code>代表 video, <code>auds</code>代表 audio, <code>txts</code>代表 subtitle。</li>
  <li>fccHandler</li>
  <li>dwFlags <code>AVISF_DISABLED</code> <code>AVISF_VIDEO_PALCHANGES</code></li>
  <li>dwInitialFrames</li>
  <li>dwRate / dwScale = samples / second(audio) or frames / second(video)</li>
  <li>dwStart</li>
  <li>dwLength</li>
  <li>dwSuggestedBufferSize</li>
  <li>dwQuality</li>
  <li>dwSampleSize</li>
</ul>

<h3 id="stream-header-list-elementstrf">Stream Header List Element(strf)</h3>

<p><code>strf</code>的结构依据媒体类型。对于 video，使用<code>BITMAPINFOHEADER</code>结构，而 audion，使用<code>WAVEFORMATEX</code>结构。</p>

<h3 id="stream-header-list-elementindx">Stream Header List Element(indx)</h3>

<p>该结构请看下面的<code>AVI index</code>小结。</p>

<h3 id="stream-header-list-elementstrn">Stream Header List Element(strn)</h3>

<h2 id="avi-indexes">AVI Indexes</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之FLV]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/24/flv-parse/"/>
    <updated>2016-07-24T00:22:21-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/24/flv-parse</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Flash_Video">FLV</a> 是 FLASH VIDEO 的简称，FLV 流媒体是随着Flash MX 的推出发展而来的视频格式。FLV 一般由文件头(FLV header) 和文件体(FLV body) 组成。其中文件体(FLV body)由一些列tag组成，tag又可分成三类:audio/video/script，分别代表音频流、视频流、脚本流(关键字或文件信息之类)。
<!--more-->
在 FLV 文件中，每种 tag 类型都由一个单独的流组成，即在 FLV 文件中最多有一个视频流和一个音频流，对同一种类型的流，FLV 中不能够定义多个独立的流。
与 SWF 文件不同,FLV 文件以大字节序存储多字节。比如，0x300(0x12C) 在 SWF 文件中的字节序为 0x2C 0x01,在FLV 文件中则为 0x01 0x2C。</p>

<h2 id="flv-header">FLV Header</h2>
<p>以 FLV Header <code>46 4C 56 01 05 00 00 00 09</code>为例：<br />
<img src="http://lazybing.github.io/images/flvparse/flv_header.png" /></p>

<p>FLV Header 的前三个字节是固定的<code>FLV</code>的 ASCII 码的值<code>0x46 0x4C 0x56</code>; 接下来的一个字节表示 FLV 的版本号,例如 0x01 代表 FLV 版本号为 1。第 5 个字节中的第0位和第2位分别表示video和audio的存在情况（1表示存在，0表示不存在）,其余6位必须为0.最后的4字节表示FLV Header的长度，对于version 1，此处为9.</p>

<h2 id="flv-file-body">FLV File Body</h2>
<p>FLV Header 之后，FLV 文件的剩余部分由tag组成，它们交替如下：</p>

<table>
  <tbody>
    <tr>
      <td>PreviousTagSize0</td>
      <td>Tag1</td>
      <td>PreviousTagSize1</td>
      <td>Tag2</td>
      <td>……</td>
      <td>PreviousTagSizeN-1</td>
      <td>TagN</td>
      <td>PreviousTagSizeN</td>
    </tr>
  </tbody>
</table>

<h2 id="flv-tags">FLV tags</h2>
<p>FLV tags 有以下几个字段构成：8bit的<code>TagType</code>、24bit的<code>DataSize</code>、24bit的<code>TimeStamp</code>、8bit的<code>TimeStampExtended</code>、24bit的<code>StreamID</code>以及最后的<code>Data</code>。</p>

<p><code>TagType</code>指该Tag的类型，8 代表 Audio，9 代表 Video，18 代表 Script Data。</p>

<p><code>DataSize</code>指定后面的<code>Data</code>字段的大小。</p>

<p>以 Tag <code>12 00 12 A9 00 00 00 00 00 00 00 02 00 0A……</code>为例，<code>0x12</code>代表该 tag 为script data，<code>00 12 A9</code>代表该 tag 的 DataSize 为 681 byte，<code>00 00 00</code>代表该 tag 的 TimeStamp 为 0，<code>00</code>代表该 tag 的 TimeStampExtended 为 0，StreamID 总是 0，接下来的 681 byte 为script data 的内容。</p>

<p>播放过程中，FLV tag的时间信息完全依赖于 FLV 时间戳，内置的其他时间信息都被忽略掉。</p>

<h3 id="audio-tags">Audio tags</h3>

<h3 id="video-tags">Video tags</h3>

<p>Video Tag 与 SWF 文件格式中的 VideoFrame Tag 类似，它们的 Payload 数据是同一的。关于 SWF 文件格式的介绍，请看<a href="www.adobe.com/go/swf_file_format">SWF(File Format Specification)</a>。</p>

<p>以<code>09 00 00 2D 00 00 00 00 00 00 00 17 00 00 00 00 01 4D 40 1F FF E1 00 19 67 4D 40 ……</code>为例，<code>09</code>表示 Tag Type 为 Video Tag;<code>00 00 2D</code>表示 DataSize 为 45；<code>00 00 00</code>表示 Timestamp 为 0；<code>00</code>表示 TimestampExtended 为 0；<code>00 00 00</code>表示 StreamID 为 0；<code>17</code>中的 8 bit，其中前 4 bit<code>1</code>表示 FrameType 为 keyframe,后 4 bit<code>7</code>表示 CodecID 为 AVC；之后的 45 byte 为 VideoData;</p>

]]></content>
  </entry>
  
</feed>
