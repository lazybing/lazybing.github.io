<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:x264 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/x264/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-06-23T08:05:02-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SODB RBSP EBSP 的区别与联系]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/22/sodb-rbsp-ebsp/"/>
    <updated>2017-06-22T08:48:25-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/22/sodb-rbsp-ebsp</id>
    <content type="html"><![CDATA[
<p>简单总结 SODB、RBSP、EBSP、NALU 和 H.264 字节流的联系。</p>

<!--more-->

<ul>
  <li>SODB：String of Data Bits，数据比特串，它是最原始的编码数据。</li>
  <li>RBSP：Raw Byte Sequence Payload, 原始字节序列载荷，它是在 SODB 的后面添加了结尾比特和若干比特<code>0</code>，以便字节对齐。</li>
  <li>EBSP：Encapsulate Byte Sequence Payload，扩展字节序列载荷，它是在 RBSP 基础上添加了防校验字节<code>0x03</code>后得到的。</li>
</ul>

<p>关系大致如下：</p>

<p><code>SODB</code>+<code>RBSP Stop bit</code>+<code>0 bits</code>= <code>RBSP</code></p>

<p><code>RBSP part1</code>+<code>0x03</code>+<code>RBSP part2</code>+<code>0x03</code>+…+<code>RBSP partn</code> = <code>EBSP</code></p>

<p><code>NALU Header</code>+<code>EBSP</code>=<code>NALU</code></p>

<p><code>start code</code>+<code>NALU</code>+…+<code>start code</code>+<code>NALU</code>=<code>H.264 Byte Stream</code></p>

<p>在 H264 SPEC 中，SODB 定义如下：</p>

<blockquote>
  <p>3.149 string of data bits(SODB) : A sequence of some number of bits representing syntax elements present within a raw byte sequence payload prior to the raw byte sequnece payload stop bit.Within an SODB,the left-most bit is considered to be the first and most significant bit,and the right-most bit is considered to be the last and least significant bit。</p>
</blockquote>

<p>要组成一个 NALU 单元，首先要有原始数据，称之为 SODB 数据。它是原始的 H264 数据编码得到的，不包含 3 字节/4 字节的起始码，即不包含<code>0x000001</code>/<code>0x00000001</code>,同样的也不包括 1 字节的 NALU 头，NALU 头部信息包含了一些基础信息，比如 NALU 类型。</p>

<blockquote>
  <p>注意：起始码包括两种：3 字节(0x000001) 和 4 字节(0x00000001)，在 SPS、PPS 和 Access Unit 的第一个 NALU 使用 4 字节起始码，其余情况均使用 3 字节起始码。</p>
</blockquote>

<p>在 H264 SPEC 中，RBSP 定义如下：</p>

<blockquote>
  <p>3.118 raw byte sequence payload(RBSP): A syntax structure containing an integer number of bytes that is encapsulated in a NAL unit.An RBSP is either empty or has the form of a string of data bits containing syntax elements followed by an RBSp stop bit and followed by zero or more subsequent bits equal to 0.
3.119 raw byte sequence payload(RBSP) stop bit: A bit equal to 1 present within a raw byte sequence payload(RBSP) after a string of data bits.The location of the end of the string of data bits within an RBSP can be identified by searching from the end of the RBSP for the RBSP stop bit, which is the last non-zero bit in the RBSP.</p>
</blockquote>

<p>在 SODB 结束处添加表示结束的 bit 1 来表示 SODB 已经结束，因此添加的 bit 1 称为<code>rbsp_stop_one_bit</code>, <code>RBSP</code>也需要字节对齐，为此需要在<code>rbsp_stop_one_bit</code>后添加若干 0 补齐。<br />
简单说，要在 SODB 后面追加两样东西形成 RBSP ：</p>

<ol>
  <li>rbsp_stop_one_bit = 1</li>
  <li>rbsp_alignment_zero_bit(s) = 0(s)</li>
</ol>

<p>RBSP 的生成过程：首先，如果 SODB 的内容是空的，则 RBSP 的内容也是空的；其次，如果 SODB 的内容非空，RBSP 的第一个字节取自 SODB 的第 1 到第 8 个比特，RBSP 字节内部按照从左到右从高到低的顺序排列。
以此类推，RBSP 中的每个字节都直接取自 SODB 的相应比特。RBSP的最后一个字节包含 SODB 的最后几个比特，以及 trailing bits。其中，trailing bits 的第一个比特为 1，其余的比特为 0,保证字节对齐。最后，
在结尾添加 0x0000,即 CABAC_ZERO_WORD，从而形成 RBSP。</p>

<p><img src="/images/sodb_rbsp/sodb_rbsp.PNG"></p>

<p>EBSP 的生成过程：NALU 数据 + 起始码就形成了Annex B 格式，起始码包括两种，0x00000001 或 0x000001。为了不让NALU的主体与起始码之间产生竞争，在对 RBSP 进行扫描时，如果遇到连续的两个<code>0x00</code>字节，则在该两个字节后面添加一个<code>0x03</code>字节。在解码的时候将该<code>0x03</code>字节去掉，也成为脱壳操作。
通过该种方式形成 EBSP，这需要将近两倍的整帧图像码流大小。为了减少存储器需求，在每个 macroblock 结束后，即检查该 macroblock 的 SODB 的起始码竞争问题，并保留 SODB 的最后两个字节的零字节个数，以便与下一个 macroblock 的 SODB 的开始字节形成连续的起始码竞争检测。对一帧图像的最后一个 macroblock，先添加结尾停止 bit，在检查起始码竞争。</p>

<p>替换规则如下：</p>

<ul>
  <li>0x000000 =&gt; 0x00000300</li>
  <li>0x000001 =&gt; 0x00000301</li>
  <li>0x000002 =&gt; 0x00000302</li>
  <li>0x000003 =&gt; 0x00000303</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 下载、安装和使用]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/09/x264-download-install-and-use/"/>
    <updated>2017-06-09T08:51:11-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/09/x264-download-install-and-use</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#x264-" id="markdown-toc-x264-">x264 获取代码：</a></li>
  <li><a href="#x264--1" id="markdown-toc-x264--1">x264 编译和安装</a></li>
  <li><a href="#x264--2" id="markdown-toc-x264--2">x264 的使用</a></li>
</ul>

<p><a href="http://www.videolan.org/developers/x264.html">x264官网</a>对 x264 项目进行了简单的描述，包括
<!--more--></p>

<h2 id="x264-">x264 获取代码：</h2>

<p><code>
git clone http://git.videolan.org/git/x264.git
</code></p>

<h2 id="x264--1">x264 编译和安装</h2>

<p>此处记录的是在Linux下的编译和安装：</p>

<p><code>
cd x264
.configure
sudo make
sudo make install
</code></p>

<p>注意，如果想要在 Linux 下使用 GDB 进行逐步调试，需要修改<code>.configure</code>后生成的<code>config.mak</code>文件，将里面的<code>CC=gcc</code>改为<code>CC=gcc -g</code>。</p>

<p>之后就可以使用 X264 来进行编码 H264 格式的视频了。</p>

<h2 id="x264--2">x264 的使用</h2>
<p>x264 的使用可以通过命令行<code>x264 --help</code>来获取。格式一般为<br />
<code>
x264 [options] -o outfile infile
</code></p>

<p>其中的输入文件可以是<code>raw</code>文件、<code>.y4m</code>文件等，输出文件格式可以是<code>.264</code>、<code>.mkv</code>、<code>.flv</code>和<code>.mp4</code>；其中输入文件如果是<code>raw</code>文件，需要在 infile 后面通过输入参数（–input-res 640x360）来指定分辨率。</p>
]]></content>
  </entry>
  
</feed>
