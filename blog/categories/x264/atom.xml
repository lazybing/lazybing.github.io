<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:x264 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/x264/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2018-01-13T07:40:14-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之x264_macroblock_encode函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode/"/>
    <updated>2017-12-25T19:52:38-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#x264macroblockencode-" id="markdown-toc-x264macroblockencode-">x264_macroblock_encode 概述</a>    <ul>
      <li><a href="#ipcm-" id="markdown-toc-ipcm-">I_PCM 编码模式</a></li>
      <li><a href="#pskip--bskip-" id="markdown-toc-pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于<code>x264_macroblock_encode</code>函数的分析，该函数主要变换和量化，对应 X264 中的宏块编码模块。<br />
<!--more--></p>

<h2 id="x264macroblockencode-">x264_macroblock_encode 概述</h2>

<p>该函数主要在<code>x264_slice_write()</code>函数调用，它主要完成了编码器中的变换、量化部分，该函数主要是封装了<code>x264_macroblock_encode_internal()</code>函数，它包括如下几个步骤：</p>

<p>{% codeblock lang:c x264_macroblock_encode %}
void x264_macroblock_encode(x264_t *h)
{
    if(CHROMA444)
        x264_macroblock_encode_internal(h, 3, 0);
    else
        x264_macroblock_encode_internal(h, 1, 1);
}
{% endcodeblock %}</p>

<ol>
  <li>如果宏块类型为 PCM 类型，直接存储重建帧数据。</li>
  <li>如果宏块类型为 Skip 类型，调用<code>x264_macroblock_encode_skip()</code>编码 Skip 类型宏块，包括<code>P_SKIP</code>和<code>B_SKIP</code>类型。</li>
  <li>如果宏块类型为<code>I_16x16</code>，调用<code>x264_mb_encode_i16x16()</code>编码 Intra 16x16 类型的宏块，该函数除了进行 DCT 变换之外，还对 16 个小块的 DC 系数进行 Hadamard 变换。</li>
  <li>如果宏块类型为<code>I_4x4</code>，调用<code>x264_mb_encode_i4x4()</code>编码 Intra 4x4 类型的宏块。</li>
  <li>帧间宏块编码，该部分并没有单独的函数完成，而是写在了<code>x264_macroblock_encode_internal</code>函数内部。</li>
  <li>调用<code>x264_mb_encode_chroma()</code>函数编码色度卡。</li>
</ol>

<h3 id="ipcm-">I_PCM 编码模式</h3>

<p>I_PCM 是一种帧内编码模式，在该模式下，编码器直接传输图像的像素值，而不经过预测和变换。在一些特殊的情况下，特别是图像
内容不规则或者量化参数非常低时，该模式比常规的操作（帧内预测-变换-量化-编码）效率更高。</p>

<p>I_PCM 模式用于以下目的：</p>

<ol>
  <li>允许编码器精确地表示像素值。</li>
  <li>提供表示不规则图像内容的准确性，而不引起重大的数据量增加。</li>
  <li>严格限制宏块解码比特数，但不降低编码效率。</li>
</ol>

<p>对 I_PCM 类型的编码，实现代码如下：</p>

<p>{% codeblock lang:c %}
…
if(h-&gt;mb.i_type == I_PCM)
{
    //if PCM is chosen, we need to store reconstructed frame data
    for(int p = 0; p &lt; plane_count; p++)
    {
        h-&gt;mc.copy<a href="h-&gt;mb.pic.p_fdec[p], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[p], FENC_STRIDE, 16">PIXEL_16x16</a>;
    }
    if(chroma)
    {
        int height = 16 » CHROMA_V_SHIFT;
        h-&gt;mc.copy<a href="h-&gt;mb.pic.p_fdec[1], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[1], FENC_STRIDE, height">PIXEL_8x8</a>;
        h-&gt;mc.copy<a href="h-&gt;mb.pic.p_fdec[2], FDEC_STRIDE, h-&gt;mb.pic.p_fenc[2], FENC_STRIDE, height">PIXEL_8x8</a>;
    }
    return;
}
…
{% endcodeblock %}</p>

<h3 id="pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</h3>

<ul>
  <li>P_Skip 类型宏块：即 COPY 宏块，无像素残差，无运动矢量残差(MVD)。直接利用预测 MV 得到的像素预测值。像素重构值= 像素预测值。</li>
  <li>B_Skip 类型宏块：无像素残差，无运动矢量残差(MVD)。解码时，通过 Direct 预测模式(时间或空间)计算出前、后向 MV 后，直接利用前、后向 MV 得到像素预测值。像素重构值 = 像素预测值。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之x264_macroblock_analyse函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/11/13/x264-macroblock-analyse/"/>
    <updated>2017-11-13T07:06:23-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/11/13/x264-macroblock-analyse</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">宏块分析概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">帧内预测</a>    <ul>
      <li><a href="#intra16x16-" id="markdown-toc-intra16x16-">Intra16x16 预测模式分析</a></li>
      <li><a href="#intra4x4-" id="markdown-toc-intra4x4-">Intra4x4 预测模式分析</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">帧间预测</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">运动补偿块</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">运动矢量</a></li>
      <li><a href="#mv-" id="markdown-toc-mv-">MV 预测</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">帧间预测函数分析</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于<code>x264_macroblock_analyse</code>函数的分析，该函数主要完成 2 个任务：对于帧内宏块，分析帧内预测模式；对于帧间宏块，进行运动估计、分析帧间预测模式。 <br />
<!--more--></p>

<h2 id="section">宏块分析概述</h2>

<p>首先看一下<code>x264_macroblock_analyse</code>函数实现过程的大体过程：</p>

<p>```
void x264_macroblock_analyse(x264_t *)
{
    h-&gt;mb.i_qp = x264_ratecontrol_mb_qp(h); //get QP of the MB
    …
    x264_mb_analyse_init(h, &amp;analysis, h-&gt;mb.i_qp);</p>

<pre><code>if(h-&gt;sh.i_type == SLICE_TYPE_I)
{
    x264_mb_analyse_intra(h, &amp;analysis, CONST_MAX);
}
else if(h-&gt;sh.i_type == SLICE_TYPE_P)
{
    x264_macroblock_probe_pskip(h);

    x264_mb_analyse_inter_p16x16(h, &amp;analysis);

    x264_mb_analyse_inter_p8x8(h, &amp;analysis);

    x264_mb_analyse_inter_p4x4(h, &amp;analysis, i);
    
    x264_mb_analyse_inter_p8x4(h, &amp;analysis, i);

    x264_mb_analyse_inter_p4x8(h, &amp;analysis, i);

    x264_mb_analyse_inter_p16x8(h, &amp;analysis, i_cost);

    x264_mb_analyse_inter_p8x16(h, &amp;analysis, i_cost);

    x264_me_refine_qpel(h, &amp;analysis.xxxx);
}
else if(h-&gt;sh.i_type == SLICE_TYPE_B)
{
    x264_mb_analyse_inter_b16x16(h, &amp;analysis);
    x264_mb_analyse_inter_b8x8( h, &amp;analysis );
    x264_mb_analyse_inter_b16x8( h, &amp;analysis );
} } ```
</code></pre>

<p>上面只是给出了该函数中调用的函数，并没有给出实际编码中的逻辑判断。它的实现如下：</p>

<ol>
  <li>如果当前是I Slice, 调用<code>x264_mb_analyse_intra()</code>进行Intra宏块的帧内预测模式分析。</li>
  <li>如果当前是P Slice, 则进行下面流程的分析：</li>
</ol>

<blockquote>
  <p>a.调用<code>x264_macroblock_probe_pskip()</code>分析是否为skip宏块，如果是skip宏块，则不再进行下面分析。<br />
b.调用<code>x264_mb_analyse_inter_p16x16()</code>分析P16x16帧间预测的代价。<br />
c.调用<code>x264_mb_analyse_inter_p8x8</code>分析P8x8帧间预测的代价。<br />
d.如果 P8x8 代价值小于 P16x16，则依次对 4 个 8x8 的子宏块分割进行判断： <br />
 * 调用<code>x264_mb_analyse_inter_p4x4()</code>分析 P4x4 帧间预测的代价。<br />
 * 如果P4x4代价值小于P8x8，则调用<code>x264_mb_analyse_inter_p8x4()</code>和<code>x264_mb_analyse_inter_p4x8()</code>分析P8x4和P4x8帧间预测的代价。<br />
e.如果P8x8代价值小于P16x16,调用<code>x264_mb_analyse_inter_p16x8()</code>和<code>x264_mb_analyse_inter_p8x16()</code>分析P16x8和P8x16帧间预测的代价。<br />
f.此外，还要调用<code>x264_mb_analyse_intra()</code>，检查当前宏块作为 Intra 宏块编码的代价是否小于作为 P 宏块编码的代价。</p>
</blockquote>

<ol>
  <li>如果当前是B Slice，则进行和 P Slice 类似的处理。</li>
</ol>

<h2 id="section-1">帧内预测</h2>

<p>帧内预测模式种，预测块 P 是基于已编码重建块和当前块形成的，对亮度像素来说，P 块用于 4x4 子块或者 16x16 宏块的相关操作。其中 4x4 宏块，有 9 种可选预测模式，适用于
带有大量细节的图像编码；16x16 宏块适用于比较平坦的图像，该宏块有 4 种预测模式，预测整个 16x16 亮度块。色度块也有 4 种预测模式，与 16x16 亮度块预测模式类似。编码器
通常会选择使 P 块和编码块之间差异最小的预测模式。</p>

<p>除此之外，还有一种帧内预测模式称为 I_PCM 编码模式。该模式下，编码器直接传输图像像素值，而不经过预测和变换。在一些特殊的情况下，特别是
图像内容不规则或者量化参数非常低时该模式比常规操作(帧内预测-变换-量化-熵编码)效率更高。I_PCM 模式用于以下目的：</p>

<ol>
  <li>允许编码器精确的表示像素值</li>
  <li>提供表示不规则图像内容的准确值，而不引起重大的数据量增加</li>
  <li>严格限制宏块解码比特数，但不损害编码效率</li>
</ol>

<p>关于帧内预测的原理介绍部分，参考<a href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/">X264 源码解析之帧内预测</a>。</p>

<p><code>x264_mb_analyse_intra</code>中关于帧内预测模式的选择判断，整体思路是，遍历所有可能的预测模式，包括 4 种 16x16 的预测模式、9 种 4x4 的预测模式，具体流程如下：</p>

<h3 id="intra16x16-">Intra16x16 预测模式分析</h3>
<p>对于非<code>AVC-Intra Compat</code>，首先根据当前宏块左边、上边宏块的可参考情况，判断该宏块可能存在的预测模式。
对于每个宏块，根据重建宏块和预测模式，调用<code>predict_16x16[]</code>做帧内预测;调用<code>x264_pixel_function_t</code>中的<code>mbcmp[]</code>计算编码代价。
选择最小的编码代价，记录编码代价的值，并记录编码模式。核心代码如下：</p>

<p>{% codeblock lang:c %}
…
for(; *predict_mode &gt;= 0; predict_mode++)
{
    int i_satd;
    int i_mode = *predict_mode;</p>

<pre><code>if(h-&gt;mb.b_lossless)
    x264_predict_lossless_16x16(h, 0, i_mode);
else
    h-&gt;predict_16x16[i_mode](p_dst);

i_satd = h-&gt;pixf.mbcmp[PIXEL_16x16](p_dst, FDEC_STRIDE, psr, FENC_STRIDE) +
    lambda * bs_size_ue(x264_mb_pred_mode16x16_fix[i_mode]);
COPY2_IF_LT(a-&gt;i_satd_i16x16, i_satd, a-&gt;i_predict16x16, i_mode);
a-&gt;i_satd_i16x16_dir[i_mode] = i_satd; } ... {% endcodeblock %}
</code></pre>

<h3 id="intra4x4-">Intra4x4 预测模式分析</h3>

<p>循环处理 16 个 4x4 的块：首先调用<code>x264_mb_predict_intra4x4_mode()</code>函数根据周围宏块情况判断该宏块可用的预测模式。之后循环计算 9 种 Intra4x4 的帧内预测模式，调用<code>predict_4x4[]</code>函数根据重建帧宏块进行帧内预测，调用<code>x264_pixel_funtion_t</code>中的<code>mbcmp[]</code>计算编码代码。
获取最小代缴的 Intra4x4 模式。将 16 个 4x4 宏块的最小代价相加，得到总代价。核心代码如下：</p>

<p>{% codeblock lang:c %}
…
const int8_t *predict_mode = predict_4x4_mode_available(a-&gt;b_avoid_topright, h-&gt;mb.i_neighbour4[idx], idx);
…
for( ; *predict_mode &gt;= 0; predict_mode++ )
{
    int i_satd;
    int i_mode = *predict_mode;</p>

<pre><code>if( h-&gt;mb.b_lossless )
    x264_predict_lossless_4x4( h, p_dst_by, 0, idx, i_mode );
else
    h-&gt;predict_4x4[i_mode]( p_dst_by );

i_satd = h-&gt;pixf.mbcmp[PIXEL_4x4]( p_dst_by, FDEC_STRIDE, p_src_by, FENC_STRIDE );
if( i_pred_mode == x264_mb_pred_mode4x4_fix(i_mode) )
{
    i_satd -= lambda * 3;
    if( i_satd &lt;= 0 )
    {
        i_best = i_satd;
        a-&gt;i_predict4x4[idx] = i_mode;
        break;
    }
}

COPY2_IF_LT( i_best, i_satd, a-&gt;i_predict4x4[idx], i_mode ); } ... {% endcodeblock %}
</code></pre>

<h2 id="section-2">帧间预测</h2>

<p>帧间预测时指利用视频时间域相关性，使用临近已编码图像像素预测当前图像的像素，以达到有效去除视频时域冗余的目的。
由于视频序列通常包括较强的时域相关性，因此预测残差值接近于0，将残差信号作为后续模块的输入进行变换、量化、扫描、熵编码，可实现对视频信号的高效压缩。</p>

<p>接下来主要介绍基于<code>Baseline Profile</code>支持的 P 帧预测模式工具以及<code>Main Profile</code>和<code>Extended Profile</code>支持的 B 帧和加权预测等帧间预测工具。</p>

<h3 id="section-3">运动补偿块</h3>

<p>每个宏块(16x16 像素)可分割为 4 种方式：一个 16x16,两个 16x8, 两个 8x16,四个 8x8。其运动补偿也有相应的四种。8x8 模式的每个子宏块还
可以继续分割，分割方式为：一个 8x8，两个 4x8，两个 8x4，四个 4x4。</p>

<p>每个分割或子宏块都有一个独立的运动补偿。每个 MV 必须被编码、传输，分割的选择也需要编码到压缩码流中。对于大的尺寸而言，MV 选择和分割
类型只需少量的比特，但运动补偿残差在多细节区域能量将非常高。小尺寸分割运动补偿残差能量低，但需要较多的比特表示 MV 和分割选择。分割
尺寸的选择影响了压缩性能。整体而言，大的分割尺寸适合平坦的区域，而小尺寸适合多细节区域。</p>

<p>宏块的色度成分(Cr 和 Cb)则为相应亮度的一半(水平和垂直各一半)。色度块采用和亮度块同样的分割模式，只是尺寸减半(水平和垂直方向都减半)。
例如，8x16 的亮度块相应色度块尺寸为 4x8，8x4 亮度块相应色度块尺寸为 4x2 等等。色度块的 MV 也是通过相应亮度 MV 水平和垂直分量减半而得。</p>

<h3 id="section-4">运动矢量</h3>

<p>帧间编码宏块的每个分割或子宏块都是从参考图像某一相同尺寸区域预测而得。两者之间的差异(MV)对亮度成分采用 1/4 像素精度，色度 1/8 像素精度。
亚像素位置的亮度和色度像素并不存在于参考图像中，需利用临近已编码点进行内插而得。如果 MV 的垂直和水平分量为正数，则参考块相应像素实际存在，
如果其中一个或两个为分数，则预测像素要通过参考帧中相应像素内插获得。</p>

<h3 id="mv-">MV 预测</h3>

<p>每个分割 MV 的编码需要相当数目的比特，特别是使用小分割尺寸时。为了减少传输比特数，可利用邻近分割的 MV 较强的相关性，MV 可由邻近已编码分割
的 MV 预测而得。预测矢量 MVp 基于已计算 MV 和 MVD（预测与当前的差异）并被编码和传送。MVp 则取决于运动补偿尺寸和邻近 MV 的有无。</p>

<p>示例如下：</p>

<p>{% img /images/macroblock_analyse/mv_prediction_macroblock.png %}</p>

<p>E 为当前宏块或宏块分割子宏块。A、B、C 分别为 E 的左、上、右上方的三个相对应块。如果 E 的左边不止一个分割，取其中最上的一个为 A；上方
不止一个分割时，取最左边一个为 B。</p>

<p>1)  传输分割不包括 16x8 和 8x16 时，MVP 为 A、B、C 分割 MV 的中值；<br />
2） 16x8 分割，上面部分 MVp 由 B 预测，下面部分 MVp 由 A 预测；<br />
3） 8x16 分割，左面部分 MVp 由 A 预测，右面部分 MVp 由 B 预测；<br />
4） skipped MB 类型同 1 。</p>

<h3 id="section-5">帧间预测函数分析</h3>

<p>帧间预测的帧类型大多是 P 帧或 B 帧。对于 P 帧，它的宏块分析流程为：</p>

<ol>
  <li>调用<code>x264_macroblock_probe_pskip()</code>分析是否为 Skip 宏块，如果是则不进行后面的分析。</li>
  <li>调用<code>x264_mb_analyse_inter_p16x16()</code>分析 P16x16 帧间预测的代价。</li>
  <li>调用<code>x264_mb_analyse_inter_p8x8()</code>分析 P8x8 帧间预测的代价。</li>
  <li>如果 P8x8 代价小于 P16x16, 则依次对 4 个 8x8 的子宏块分割进行判断：<br />
 i. 调用<code>x264_mb_analyse_inter_p4x4()</code>分析 P4x4 的帧间预测代价。<br />
 ii. 如果 P4x4 代价值小于 P8x8，则调用<code>x264_mb_analyse_inter_p8x4()</code>和<code>x264_mb_analyse_inter_p4x8()</code>分析 P8x4 和 P4x8 帧间预测的代价。</li>
  <li>如果 P8x8 代价值小于 P16x8，调用<code>x264_mb_analyse_inter_p16x8()</code>和<code>x264_mb_analyse_inter_p8x16()</code>分析 P16x8 和 P8x16 帧间预测的代价。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264源码解析之x264_bitstream_init函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/11/12/bitstream-init/"/>
    <updated>2017-11-12T06:48:31-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/11/12/bitstream-init</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#h264-spec-annex-b" id="markdown-toc-h264-spec-annex-b">H264 SPEC Annex B</a></li>
  <li><a href="#jm--annexb-" id="markdown-toc-jm--annexb-">JM 中关于 AnnexB 的源码分析</a></li>
  <li><a href="#if-trace" id="markdown-toc-if-trace">if TRACE</a>    <ul>
      <li><a href="#x264--bitstream-" id="markdown-toc-x264--bitstream-">X264 中 Bitstream 的源码分析</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于 bitstream 的处理方法，它主要实现 SPEC 中<code>Annex B:Byte stream format</code>中的规定。
<!--more--></p>

<h2 id="h264-spec-annex-b">H264 SPEC Annex B</h2>

<p>首先看一下，H264 的 SPEC 中关于 Bitstream 中的规定。</p>

<p>{% codeblock lang:c AnndexB %}
byte_stream_nal_unit(NumBytesInNALunit)
{
    while(next_bits(24) != 0x000001 &amp;&amp;
          next_bits(32) != 0x00000001)
        leading_zero_8bits //equal to 0x00 f(8)</p>

<pre><code>if(next_bits(24) != 0x000001)
    zero_byte  //equal to 0x00 f(8)

start_code_prefix_one_3bytes //equal to 0x000001 f(24)

nal_unit(NumBytesInNALunit)

while(more_data_in_byte_stream() &amp;&amp;
      next_bits(24) != 0x000001 &amp;&amp;
      next_bits(32) != 0x00000001)
    trailing_zero_8bits //equal to 0x00 f(8) } {% endcodeblock %}
</code></pre>

<p>SPEC 中定义的解码的部分，因为我们根据上面的描述，可以理出 H264 的大致解析过程：</p>

<ol>
  <li>解码过程开始时，解码器把其当前的位置初始化为字节流的起始位置。然后提取，并丢弃每一个<code>leading_zero_8bits</code>语法元素(如果存在的话)，移动当前位置至某一时刻的字节处，直到比特流的当前位置紧接的四个字节为四字节序列<code>0x00000001</code>。</li>
  <li>当字节流里的紧接的四个字节构成四字节序列<code>0x00000001</code>，对比特流中下一个字节(为 zero_byte 语法元素)进行提取并丢弃时，字节流的当前位置设为紧接被丢弃的字节的字节位置。</li>
  <li>提取与丢弃比特流中下一个三字节序列(为 start_code_prefix_one_3bytes)，且比特流当前位置设为此紧接被丢弃的 3 字节序列的字节的位置。</li>
  <li>NumBytesInNALunit 设为自当前字节位置起至下述条件前的位置的最后一个字节，且包括最后一个字节的编号。
a. 一个三字节序列的排列等于<code>0x000000</code>，或
b. 字一个三字节序列的排列等于<code>0x000001</code>，或 
c. 字节流的结束，由未规定的方式判决。</li>
  <li>NumBytesInNALunit 字节从比特流中移除，字节流的当前位置前移 NumBytesInNALunit 字节。这个字节序列为 <code>nal_unit(NumBytesInNALunit)</code>,并用 NAL 单元解码过程进行解码。</li>
  <li>当字节流中的当前位置不为字节流的结尾(由未规定的方式判决)，且字节流中的下一个字节不是等于<code>0x000001</code>开始的三字节序列，也不是等于<code>0x00000001</code>开始的四字节序列。解码器提取并丢弃每一个<code>trailing_zero_8bits</code>语法元素，移动字节流中的当前位置到某一时刻的一个字节处，直到字节流里的当前位置接下来的四个字节构成四字节的序列<code>0x00000001</code>或已至字节流的结尾(由未规定的当时判决)。</li>
</ol>

<h2 id="jm--annexb-">JM 中关于 AnnexB 的源码分析</h2>

<p>在看<code>X264</code>源码之前，让我们先看一下 JM 中关于 AnnexB 的解码的源码实现部分。</p>

<p><code>JM</code>中关于 AnnexB 部分的描述在<code>jm\decod\src\annexb.c</code>中,首先看一下其中最重要的一个函数<code>int GetAnnexbNALU(NALU_t *nalu)</code>,该函数的声明如下：</p>

<p><code>
/*
 * Brief: Returns the size of the NALU( bits between start codes in case of
 *        Annex B, nalu-&gt;buf and nalu-&gt;len are filled. Other field in
 *        nalu-&gt;remain uninitialized( will be taken care of by NALUtoRBSP.
 * Return: 0 if there is nothing any more to read(EOF)
 *         -1 in case of any error
 * note Side-effect: Returns length of start-code in bytes.
 * 
 * Note: GetAnnexbNALU expects start codes at byte aligned positions in the file
 */
int GetAnnexbNALU(NALU_t *nalu);
</code></p>

<p><code>GetAnnexbNALU</code>的定义如下：</p>

<p>{% codeblock lang:c GetAnnexbNALU %}
int GetAnnexbNALU(NALU_t *nalu)
{
  int info2, info3, pos = 0;
  int StartCodeFound, rewind;
  char *Buf;
  int LeadingZero8BitsCount=0, TrailingZero8Bits=0;</p>

<p>if ((Buf = (char*)calloc (nalu-&gt;max_size , sizeof(char))) == NULL) no_mem_exit(“GetAnnexbNALU: Buf”);</p>

<p>//如果start_code前还有数据，丢弃start_code前leading_zero_8bits
  while(!feof(bits) &amp;&amp; (Buf[pos++]=fgetc(bits))==0);</p>

<p>if(feof(bits))
  {
    if(pos==0)
    return 0;
    else
    {
      printf( “GetAnnexbNALU can’t read start code\n”);
      free(Buf);
      return -1;
    }
  }</p>

<p>if(Buf[pos-1]!=1)
  {
    printf (“GetAnnexbNALU: no Start Code at the begin of the NALU, return -1\n”);
    free(Buf);
    return -1;
  }</p>

<p>if(pos&lt;3)
  {
    printf (“GetAnnexbNALU: no Start Code at the begin of the NALU, return -1\n”);
    free(Buf);
    return -1;
  }
  else if(pos==3)
  {
    nalu-&gt;startcodeprefix_len = 3;
    LeadingZero8BitsCount = 0;
  }
  else
  {
    LeadingZero8BitsCount = pos-4;
    nalu-&gt;startcodeprefix_len = 4;
  }</p>

<p>//the 1st byte stream NAL unit can has leading_zero_8bits, but subsequent ones are not
  //allowed to contain it since these zeros(if any) are considered trailing_zero_8bits
  //of the previous byte stream NAL unit.
  //字节流数据的第一个 NAL 单元才会有leading_zero_8bits;后面的 NALU 不会包含 leading_zero_8bits,
  //因为这些 leading_zero_8bits 会被看做前一个 NAL 单元后面的 trailing_zero_8bits
  if(!IsFirstByteStreamNALU &amp;&amp; LeadingZero8BitsCount&gt;0)
  {
    printf (“GetAnnexbNALU: The leading_zero_8bits syntax can only be present in the first byte stream NAL unit, return -1\n”);
    free(Buf);
    return -1;
  }
  IsFirstByteStreamNALU=0;</p>

<p>StartCodeFound = 0;
  info2 = 0;
  info3 = 0;</p>

<p>while (!StartCodeFound)
  {
    if (feof (bits))
    {
      //Count the trailing_zero_8bits
      while(Buf[pos-2-TrailingZero8Bits]==0)
        TrailingZero8Bits++;
      nalu-&gt;len = (pos-1)-nalu-&gt;startcodeprefix_len-LeadingZero8BitsCount-TrailingZero8Bits;
      memcpy (nalu-&gt;buf, &amp;Buf[LeadingZero8BitsCount+nalu-&gt;startcodeprefix_len], nalu-&gt;len);   <br />
      nalu-&gt;forbidden_bit = (nalu-&gt;buf[0]»7) &amp; 1;
      nalu-&gt;nal_reference_idc = (nalu-&gt;buf[0]»5) &amp; 3;
      nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;</p>

<p>// printf (“GetAnnexbNALU, eof case: pos %d nalu-&gt;len %d, nalu-&gt;reference_idc %d, nal_unit_type %d \n”, pos, nalu-&gt;len, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);</p>

<h1 id="if-trace">if TRACE</h1>
<p>fprintf (p_trace, “\n\nLast NALU in File\n\n”);
  fprintf (p_trace, “Annex B NALU w/ %s startcode, len %d, forbidden_bit %d, nal_reference_idc %d, nal_unit_type %d\n\n”,
    nalu-&gt;startcodeprefix_len == 4?”long”:”short”, nalu-&gt;len, nalu-&gt;forbidden_bit, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);
  fflush (p_trace);
#endif
      free(Buf);
      return pos-1;
    }
    //找 start_code，先找0x00000001,后找0x000001
    Buf[pos++] = fgetc (bits);
    info3 = FindStartCode(&amp;Buf[pos-4], 3);
    if(info3 != 1)
      info2 = FindStartCode(&amp;Buf[pos-3], 2);
    StartCodeFound = (info2 == 1 || info3 == 1);
  }</p>

<p>//Count the trailing_zero_8bits
  //计算 trailing_zero_8bits,如果start_code为0x000001,trailing_zero_8bits 肯定不存在
  if(info3==1)	//if the detected start code is 00 00 01, trailing_zero_8bits is sure not to be present
  {
    while(Buf[pos-5-TrailingZero8Bits]==0)
      TrailingZero8Bits++;
  }
  // Here, we have found another start code (and read length of startcode bytes more than we should
  // have.  Hence, go back in the file
  rewind = 0;
  if(info3 == 1)
    rewind = -4;
  else if (info2 == 1)
    rewind = -3;
  else
    printf(“ Panic: Error in next start code search \n”);</p>

<p>if (0 != fseek (bits, rewind, SEEK_CUR))
  {
    snprintf (errortext, ET_SIZE, “GetAnnexbNALU: Cannot fseek %d in the bit stream file”, rewind);
    free(Buf);
    error(errortext, 600);
  }</p>

<p>// Here the leading zeros(if any), Start code, the complete NALU, trailing zeros(if any)
  // and the next start code is in the Buf.
  // The size of Buf is pos, pos+rewind are the number of bytes excluding the next
  // start code, and (pos+rewind)-startcodeprefix_len-LeadingZero8BitsCount-TrailingZero8Bits
  // is the size of the NALU.</p>

<p>nalu-&gt;len = (pos+rewind)-nalu-&gt;startcodeprefix_len-LeadingZero8BitsCount-TrailingZero8Bits;
  memcpy (nalu-&gt;buf, &amp;Buf[LeadingZero8BitsCount+nalu-&gt;startcodeprefix_len], nalu-&gt;len);
  nalu-&gt;forbidden_bit = (nalu-&gt;buf[0]»7) &amp; 1;
  nalu-&gt;nal_reference_idc = (nalu-&gt;buf[0]»5) &amp; 3;
  nalu-&gt;nal_unit_type = (nalu-&gt;buf[0]) &amp; 0x1f;</p>

<p>//printf (“GetAnnexbNALU, regular case: pos %d nalu-&gt;len %d, nalu-&gt;reference_idc %d, nal_unit_type %d \n”, pos, nalu-&gt;len, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);
#if TRACE
  fprintf (p_trace, “\n\nAnnex B NALU w/ %s startcode, len %d, forbidden_bit %d, nal_reference_idc %d, nal_unit_type %d\n\n”,
    nalu-&gt;startcodeprefix_len == 4?”long”:”short”, nalu-&gt;len, nalu-&gt;forbidden_bit, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);
  fflush (p_trace);
#endif</p>

<p>free(Buf);</p>

<p>return (pos+rewind);
}
{% endcodeblock %}</p>

<p>找<code>start_code</code>的定义如下,该函数的参数<code>zeros_in_startcode</code>可能为 3 或 4,寻找<code>0x000001</code>或<code>0x00000001</code>。</p>

<p>{% codeblock lang:c FindStartCode %}
/<em>!
 <strong>**</strong></em><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>***
 * \brief
 *    returns if new start code is found at byte aligned position buf.
 *    new-startcode is of form N 0x00 bytes, followed by a 0x01 byte.
 *
 *  \return
 *     1 if start-code is found or                      \n
 *     0, indicating that there is no start code
 *
 *  \param Buf
 *     pointer to byte-stream
 *  \param zeros_in_startcode
 *     indicates number of 0x00 bytes in start-code.
 **</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>**
 */
static int FindStartCode (unsigned char *Buf, int zeros_in_startcode)
{
  int info;
  int i;</p>

<p>info = 1;
  for (i = 0; i &lt; zeros_in_startcode; i++)
    if(Buf[i] != 0)
      info = 0;</p>

<p>if(Buf[i] != 1)
    info = 0;
  return info;
}
{% endcodeblock %}</p>

<h2 id="x264--bitstream-">X264 中 Bitstream 的源码分析</h2>

<p><code>X264</code>中关于<code>AnnexB</code>部分的描述主要是在<code>common/bitstream.c</code>中的<code>void x264_bitstream_init(int cpu, x264_bitstream_function_t *pf)</code>完成。
其中的<code>x264_bitstream_function_t</code>结构体定义如下：</p>

<p>{% codeblock lang:c x264_bitstream_function_t %}
typedef struct
{
    uint8_t <em>(</em>nal_escape) ( uint8_t <em>dst, uint8_t *src, uint8_t *end );
    void (</em>cabac_block_residual_internal)( dctcoef <em>l, int b_interlaced,
                                           intptr_t ctx_block_cat, x264_cabac_t *cb );
    void (</em>cabac_block_residual_rd_internal)( dctcoef <em>l, int b_interlaced,
                                              intptr_t ctx_block_cat, x264_cabac_t *cb );
    void (</em>cabac_block_residual_8x8_rd_internal)( dctcoef *l, int b_interlaced,
                                                  intptr_t ctx_block_cat, x264_cabac_t *cb );
} x264_bitstream_function_t;
{% endcodeblock %}</p>

<p>其中<code>x264_bitstream_init</code>的定义如下：</p>

<p>{% codeblock lang:c X264_bitstream_init %}
void X264_bitstream_init(int cpu, x264_bitstream_function_t <em>pf)
{
    memset(pf, 0, sizeof(</em>pf));
    pf-&gt;nal_escape = x264_nal_escape_c;
    pf-&gt;cabac_block_residual_internal = x264_cabac_block_residual_internal_sse2;
    pf-&gt;cabac_block_residual_rd_internal = x264_cabac_block_residual_rd_internal_sse2;
    pf-&gt;cabac_block_residual_8x8_rd_internal = x264_cabac_block_residual_8x8_rd_internal_sse2;
}
{% endcodeblock %}</p>

<p>其中的<code>x264_nal_escape_c</code>定义如下：</p>

<p>{% codeblock lang:c x264_nal_escape_c %}
static uint8_t *x264_nal_escape_c( uint8_t *dst, uint8_t *src, uint8_t *end )
{
    if( src &lt; end ) *dst++ = *src++;
    if( src &lt; end ) *dst++ = *src++;
    while( src &lt; end )
    {
        if( src[0] &lt;= 0x03 &amp;&amp; !dst[-2] &amp;&amp; !dst[-1] )
            *dst++ = 0x03;
        *dst++ = *src++;
    }
    return dst;
}
{% endcodeblock %}</p>

<p>最后，给出 X264 中关于每个 NALU 的编码的实现：</p>

<p>{% codeblock lang:c x264_nal_encode %}
/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**
 * x264_nal_encode:
 **</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/
void x264_nal_encode( x264_t *h, uint8_t *dst, x264_nal_t *nal )
{
    uint8_t *src = nal-&gt;p_payload;
    uint8_t *end = nal-&gt;p_payload + nal-&gt;i_payload;
    uint8_t *orig_dst = dst;</p>

<pre><code>if( h-&gt;param.b_annexb )
{
    if( nal-&gt;b_long_startcode )
        *dst++ = 0x00;
    *dst++ = 0x00;
    *dst++ = 0x00;
    *dst++ = 0x01;
}
else /* save room for size later */
    dst += 4;

/* nal header */
*dst++ = ( 0x00 &lt;&lt; 7 ) | ( nal-&gt;i_ref_idc &lt;&lt; 5 ) | nal-&gt;i_type;

dst = h-&gt;bsf.nal_escape( dst, src, end );
int size = (dst - orig_dst) - 4;

/* Write the size header for mp4/etc */
if( !h-&gt;param.b_annexb )
{
    /* Size doesn't include the size of the header we're writing now. */
    orig_dst[0] = size&gt;&gt;24;
    orig_dst[1] = size&gt;&gt;16;
    orig_dst[2] = size&gt;&gt; 8;
    orig_dst[3] = size&gt;&gt; 0;
}

nal-&gt;i_payload = size+4;
nal-&gt;p_payload = orig_dst;
x264_emms(); } {% endcodeblock %}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之参考帧]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/19/reference-frame/"/>
    <updated>2017-10-19T07:53:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/19/reference-frame</id>
    <content type="html"><![CDATA[
<p>本篇博客主要记录<code>X264</code>中关于参考帧管理。</p>

<!--more-->

<p><code>X264</code>中的帧可以大致分为以下几类：参考帧(ference frame)、当前编码帧(current frame)、未使用帧(unused frame)等。对帧的管理操作
的基本操作由两种：从队列中获取帧(<code>x264_frame_pop</code>)、向队列中添加帧(<code>x264_frame_push_unused</code>)。</p>

<p>关于帧队列的管理是通过数组来的，下面先介绍最基本的帧队列的一些基本操作。</p>

<p>首先将<code>frame</code>帧插入到<code>list</code>队列中，实现代码如下：</p>

<p>{% codeblock lang:c x264_frame_push %}
void x264_frame_push(x264_frame_t **list, x264_frame_t *frame)
{
    int i = 0;
    while(list[i]) i++;
    list[i] = frame;
}
{% endcodeblock %}</p>

<p>从<code>list</code>队列中获取<code>frame</code>帧，实现代码如下：</p>

<p>{% codeblock lang:c x264_frame_pop %}
x264_frame_t *x264_frame_pop( x264_frame_t **list )
{
    x264_frame_t *frame;
    int i = 0;
    assert( list[0] );
    while( list[i+1] ) i++;
    frame = list[i];
    list[i] = NULL;
    return frame;
}
{% endcodeblock %}</p>

<p>当编码帧类型为<code>IDR</code>帧时，需要重置整个参考帧队列，<code>X264</code>中重置参考队列是通过<code>x264_reference_reset</code>函数完成，实现过程即为将<code>reference</code>队列
所有的参考帧设置为<code>unused</code>队列中的<code>unused</code>帧；实现代码如下：</p>

<p>{% codeblock lang:c x264_reference_reset %}
static inline void x264_reference_reset( x264_t *h )
{
    while( h-&gt;frames.reference[0] )
        x264_frame_push_unused( h, x264_frame_pop( h-&gt;frames.reference ) );
    h-&gt;fdec-&gt;i_poc =
    h-&gt;fenc-&gt;i_poc = 0;
}
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之判断帧类型]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/11/x264-slicetype-decide/"/>
    <updated>2017-10-11T08:59:17-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/11/x264-slicetype-decide</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
