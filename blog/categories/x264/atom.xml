<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:x264 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/x264/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2021-12-11T04:58:43-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[H264 CABAC Alogrithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/11/01/h264-cabac-alogrithm/"/>
    <updated>2021-11-01T16:25:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2021/11/01/h264-cabac-alogrithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cabac-" id="markdown-toc-cabac-">CABAC 框图</a>    <ul>
      <li><a href="#a-" id="markdown-toc-a-">A. 二值化</a></li>
    </ul>
  </li>
</ul>

<p>基于上下文的自适应二进制算术编码(CABAC)是 ITU-T/ISO/IEC 视频压缩标准 H.264/AVC 的一个标准部分。通过将自适应二进制算术编码技术与上下文建模相结合，实现了高度的自适应并降低冗余。CABAC 框架还包括一种用于用于二进制算术编码和概率估计的新的低复杂度方法，非常适合高效的硬件和软件实现。对于预期目标应用的典型领域，CABAC 显著优于H.264/AVC的 baseline 熵编码方法。对于代表广播应用中使用的典型材料的一组测试序列，以及大约30到38 dB 的可接受视频质量范围，平均比特流节省9%-14%。</p>

<!--more-->

<h2 id="cabac-">CABAC 框图</h2>

<p><img src="/images/h264_cabac/h264_cabac.png"></p>

<p>图1显示了在 CABAC 中编码单个语法元素的通用框图。编码过程最多由三个基本步骤组成：1) 二值化 2）上下文建模 3）二进制算术编码</p>

<p>第一步中，将给定的非二进制值语法元素唯一地映射到二进制序列，即所谓的 bin string。当给定一个二进制语法元素时，这个初始步骤被忽略，如图 1 所示。对于 bin string 的每个元素或每个二进制语法元素，根据编码模式可能会遵循一个或两个后续步骤。</p>

<p>在所谓的常规编码模式中，在实际算术编码过程之前，给定的二进制决策(在下文中，我们称之为bin)进入上下文建模阶段，在此阶段选择概率模型，以便相应的选择可能取决于先前编码的语法元素或bin。然后，在分配上下文模型之后，bin 值及其相关模型被传递到常规编码引擎，在该引擎中进行算术编码的最后阶段以及随后的模型更新(参见图1)。</p>

<p>或者，为所选择的bins选择 bypass编码模式，以便通过简化的编码引擎而不使用明确分配的模型来允许整个编码(和解码)过程的加速，如图1中开关的右下分支所示。</p>

<p>接下来，将更详细地讨论三个主要功能构建块，即二值化、上下文建模和二值算术编码，以及它们之间的相互依赖关系。</p>

<h3 id="a-">A. 二值化</h3>

<p>1) 普通方法：为了在视频编码中成功应用上下文建模和自适应算术编码，我们发现应满足以下两个要求：</p>

<p>a) 条件概率的快速和准确估计，必须在 slice 编码单元的相对较短的时间间隔内实现。<br />
b) 执行概率估计和后续算术编码的每个基本操作所涉及的计算复杂度，必须保持在最低水平，以促进这些固有的顺序组织过程的足够高的吞吐量。</p>

<p>为了满足这两个要求，我们引入了重要的”预处理”步骤，即首先减少要编码的语法元素的字母表大小。CABAC 中的字母表缩减是通过对每个非二进制语法元素应用二值化方案来执行的，从而给定语法元素生成唯一的中间二进制码字，称为二进制字符串。这种方法的优点在于建模和实现。</p>

<p>首先，重要的是要注意，在建模方面没有任何损失，因为可以通过使用 bin 字符串的各个 bin 的概率来恢复单个(非二进制)符号概率。为了说明这一点，让我们考虑P/SP slice的语法元素mb_type的二值化。</p>

<p>CABAC(Context-Based Adaptive Binary Arithmetic Coding) 主要包括三步：二值化、上下文建模、二进制算术编码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264/AVC 视频编码：工具、性能和复杂性]]></title>
    <link href="http://lazybing.github.io/blog/2021/07/26/video-coding-with-h264-tools-performance-and-complexity/"/>
    <updated>2021-07-26T01:59:05-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/07/26/video-coding-with-h264-tools-performance-and-complexity</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">摘要</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">1. 引言</a></li>
</ul>

<h1 id="section">摘要</h1>

<p>H.264/AVC 是 ISO/IEC 运动图像专家组与 ITU-T 视频编码专家组合作的产物，是最新的视频编码标准。这项标准化工作的目标是提高压缩效率、交互式(视频电话)和非交互式应用（广播、流媒体、存储、视频点播）的网络友好视频表示。与以前的标准相比，H.264/AVC 在较宽的比特率和视频分辨率范围内提供高达 50% 的压缩效率增益。与以前的标准相比，解码器的复杂度是 MPEG-2 的 4 倍，是 MPEG-4 的 2 倍。本文概述了 H.264/AVC 的新工具、特性和复杂性。</p>

<!--more-->

<h1 id="section-1">1. 引言</h1>

<p>ITU-T 的新视频编码标准建议，H.264/AVC，是视频编码标准序列中的最新标准。这些先前的标准反映了视频压缩的技术进步以及视频编码对不同应用和网络的适应性。应用范围从可视电话(H.261)到消费者 CD 视频（MPEG-1）以及标准清晰度或高清晰度电视（MPEG-2）的广播。用于视频通信的网络包括诸如 PSTN（H.263、MPEG-4）或 ISDN（H.261）之类的交换网络和诸如 ATM（MPEG-2、MPEG-4）、因特网（H.263、MPEG-4）或移动网络（H.263、MPEG-4）之类的分组网络。有线调制解调器、XDSL 和 UMTS 等新网络技术的重要性，对新的视频编码标准 H.264/AVC 产生了需求，针对交互式应用（如要求低延迟系统的视频电话）和非交互式应用（如存储、广播，标准清晰度电视的流媒体，其重点是高编码效率）时，必须特别考虑性能。将H.264/AVC 视频编码工具（如多参考帧、1/4 像素运动补偿、去块滤波或整数变换等）与以前的视频编码标准相比，H.264/AVC 在标准话视频编码的发展过程中带来了最多的算法不连续性。同时，H.264/AVC 在编码性能上实现了五年前还没有预见到的飞跃。2001 年 12 月，ITU-T 和 MPEG 的视频专家成立了联合视频团队（JVT）来开发这个 H.264/AVC 视频编码标准，这使得这一进展成为可能。H.264/AVC 于 2003 年 3月定稿，并于 2003 年 5 月获得 ITU-T 的批准。</p>

<p>现代视频通信使用的数字视频（从相机捕捉或使用适当的工具(如动画软件)合成)。在可选的预处理步骤(图1)中，发送者可以选择使用格式转换或增强技术对视频进行预处理。然后编码器对视频进行编码，并将视频表示为位流。在通过通信网络传输比特流之后，解码器解码视频,视频在可选的后处理步骤之后显示，后处理步骤可以包括格式转换、滤波以一致编码伪影、错误隐藏或视频增强。</p>

<p>该标准定义了位流的语法和语义，以及解码器在将位流解码为视频时需要执行的处理。因此，视频解码器制造商只能在成本和硬件要求等领域展开竞争。可选的解码视频的后处理是不同制造商将提供竞争工具以创建针对目标应用优化的解码前视频流的另一个领域。该标准没有定义如何进行编码或其他视频预处理，从而使制造商能够在成本、编码效率、错误恢复能力或硬件要求等领域与编码器竞争。同时，位流和解码器的标准化保留了任何通信标准互操作性的基本要求。</p>

<p>为了在不同的环境中进行高效的传输，不仅需要提高编码效率，而且还需要将编码后的视频无缝、方便地集成到所有当前和未来的协议和网络体系结构中。这包括尽最大努力交付的公共互联网，以及预计将成为新视频编码标准主要应用的无线网络。</p>

<p>本文给出了H.264/AVC的工作原理、性能和硬件需求。第 2 节介绍了标准化视频编码方案的概念。在第 3 节中，我们介绍了 H.264/AVC 在视频编码性能方面取得这一进展的主要工具。视频编码器优化不是标准的一部分。然而，编码器的成功使用需要第 4 节中介绍的编码器控制知识。H.264/AVC 可用于具有非常不同约束的不同应用，如计算资源、错误恢复能力和视频分辨率。第 5 节描述了 H.264/AVC 的 profiles 和 levels，这些 profiles 和 level 允许解码器复杂度适应不同的应用。在第 6 节中，我们比较了 H.264/AVC 和以前的视频编码标准的编码效率和硬件复杂度。H.264/AVC 使用了许多国际专利，第 7 节解释了 H.264/AVC 商业使用的当前许可模式。编码视频表示或比特流对不同传输网络的适配，通常在先前 MPEG 标准或诸如 H.320 或 H.324 的单独标准中的系统规范中定义。然而，只有网络适配和视频编码的紧密结合才能带来视频通信系统的最佳性能。因此，H.264/AVC 由两个概念层组成。视频编码层(VCL)定义视频的有效表示，网络适配层(NAL)将 VCL 表示转换为适合特定传输层或存储介质的格式。对于像 H.320、H.324 或 MPEG-2 这样的电路交换传输，NAL 将编码视频作为包含起始码的有序字节流传送，使得这些传输层和解码器能够可靠且简单地识别比特流的结构。对于像 RTP/IP 或 TCP/IP 这样的分组交换网络，NAL 在没有这些起始码的情况下以分组的形式传送编码视频。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[x264码率控制之VBV详解]]></title>
    <link href="http://lazybing.github.io/blog/2021/07/21/x264-rate-control-vbv-algorithm/"/>
    <updated>2021-07-21T05:43:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/07/21/x264-rate-control-vbv-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#vbv-buffer" id="markdown-toc-vbv-buffer">为什么需要 VBV Buffer</a></li>
  <li><a href="#section" id="markdown-toc-section">基本参数</a></li>
</ul>

<p>VBV 作为 H264 中码率控制的重要模块，它的作用是确保码率不会超过某个最大值。</p>

<!--more-->

<p>先来看一下，VBV 的作用，如图所示。分别设置<code>vbv-maxrate 2000</code>/<code>vbv-maxrate 1500</code>/<code>vbv-bufsize 2000</code>/<code>vbv-bufsize 1500</code>。</p>

<p><img src="/images/h264_vbv/ratecontrol_vbv.PNG" title="‘VBV’" ></p>

<h2 id="vbv-buffer">为什么需要 VBV Buffer</h2>

<p>假设我们的编码是面向存储的，那么就无需这个 buffer，编码出来的码率随便你怎么波动，我只存在本地就 OK。现在问题是我们是面向传输的，要考虑到网络的带宽问题，以及网络的抖动，如果我们编码出来的码率变化非常大，那么很不利于传输，比如为了帧的质量，突然编出来一个很大的帧，需要传输很久，那么解码端就会需要等很久，体现在播放时上是长时间卡住。因此需要这个 buffer 来平滑码率，它通过码率控制模块来进行反馈，当码率控制模块检测 buffer 时发现 buffer 很满了，就通过调节 QP 的方法，使编码的码率降下来。另外关于时延的问题，必须说明的是，引入 vbv buffer 模型并不是为了降低时延，相反它反而会引入时延，但它可以有效防止时延抖动，让你看视频不卡（只要防止下溢就行），通过把初始充盈度调大一点就能做的很好。引自<a href="https://blog.csdn.net/ccc_cccd/article/details/114042493">假想参考解码器 vbv HRD</a></p>

<h2 id="section">基本参数</h2>

<ul>
  <li>vbv-bufsize <integer> Set size of the VBV buffer (kbit)</integer></li>
  <li>vbv-maxrate <integer> Max local bitrate &lt;kbit/s&gt;</integer></li>
  <li>vbv-init    <float>   Initial VBV buffer occupancy</float></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264 Rate Control Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/"/>
    <updated>2021-06-22T06:49:35-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基础知识</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">模糊复杂度估计</a></li>
  <li><a href="#vbv-algorithm" id="markdown-toc-vbv-algorithm">VBV Algorithm</a>    <ul>
      <li><a href="#lookahead-vbv-" id="markdown-toc-lookahead-vbv-">Lookahead vbv 调整</a></li>
      <li><a href="#vbv-" id="markdown-toc-vbv-">实时 VBV 调整</a></li>
      <li><a href="#mingop-vbv-" id="markdown-toc-mingop-vbv-">minGOP vbv 调整</a></li>
    </ul>
  </li>
  <li><a href="#mb-tree-algorithm" id="markdown-toc-mb-tree-algorithm">MB-Tree Algorithm</a>    <ul>
      <li><a href="#macroblock-tree-" id="markdown-toc-macroblock-tree-">Macroblock-Tree 的高层概述</a></li>
      <li><a href="#x264-lookahead" id="markdown-toc-x264-lookahead">x264 lookahead</a></li>
      <li><a href="#macroblock-tree-algorithm-mb-tree-" id="markdown-toc-macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</a></li>
    </ul>
  </li>
  <li><a href="#adaptive-quantization-algorithm" id="markdown-toc-adaptive-quantization-algorithm">Adaptive Quantization Algorithm</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">优化方法</a>    <ul>
      <li><a href="#vbr-" id="markdown-toc-vbr-">VBR 情况下的码率优化</a></li>
    </ul>
  </li>
</ul>

<p>码率控制是 H.264 编码器中非常重要的一个模块。码率控制主要包括两部分：码率分配(Bit Allocation)、量化参数调整(Quantitative Parameter Adjustment)。X264 的码率控制算法大致分为帧级码率控制、宏块级码率控制。帧级码率控制算法比如：VBV 调整。宏块级别码率控制比如：MBTree 算法、VAQ 感知量化算法。</p>

<!--more-->

<h1 id="section">基础知识</h1>

<p>码率控制的主要过程是：</p>

<ol>
  <li>根据前面已经编好的帧计算 SATD 值来预测当前帧的复杂度(第一帧 I 帧除外)；</li>
  <li>计算好复杂度后，根据复杂度和线性量化控制参数(qcomp)来计算 qpscale。qpscale 会影响最终编码时所用的 qp。</li>
  <li>根据目标码率和之前编码所用的比特数可以确定一个 rate_factor，若之前编码的比特数多与目标实际产生，则 rate_factor 减小。这个 rate_factor 是调整 qpscale 用的，还有 overflow 来对qpscale 来做溢出补偿处理来控制文件大小。</li>
  <li>最后根据计算公式得到 qp。</li>
</ol>

<p>参考文档：</p>

<p><a href="https://pianshen.com/article/4198342118">x264 码率控制算法原理</a></p>

<p>编码所需的 bits 与实际编码的复杂度和量化参数有关，复杂度越复杂，量化参数越小，所需 bits 越少。复杂度用运动补偿后残差的 SATD 表示。</p>

<p>qscale = 0.85 * 2^((qp - 12)/6.0)   (1) <br />
qp = 12 + 6 * log2(qscale / 0.85)   (2)</p>

<p>x264 中的代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">qp2scale</span><span class="p">(</span><span class="kt">float</span> <span class="n">qp</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">powf</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span> <span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">))</span> <span class="o">/</span> <span class="mf">6.0f</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="n">qscale2qp</span><span class="p">(</span><span class="kt">float</span> <span class="n">qscale</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">)</span> <span class="o">+</span> <span class="mf">6.0f</span> <span class="o">*</span> <span class="n">log2f</span><span class="p">(</span><span class="n">qscale</span> <span class="o">/</span> <span class="mf">0.85f</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h1 id="section-1">模糊复杂度估计</h1>

<p>One Pass 编码中，由经过运动补偿后残差的 SATD 代表一帧的复杂度，SATD 是将残差做  Hadrmard 变换后再取绝对值的总和，它作为一种简单的时频交换，能在一定程度上衡量生产码流的大小。</p>

<p>模糊复杂度是基于已编码帧的复杂度加权得到的。使用复杂度加权，相对于使用单独一帧的复杂度，能避免 QP 的波动：</p>

<p>blurred_complexity = cplxsum/cplxcount  <br />
cplxsum[i]   = cplxsum[i - 1] * 0.5 + satd[i - 1]<br />
cplxcount[i] = cplxcount[i - 1] * 0.5 + 1</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">double</span> <span class="n">wanted_bits</span><span class="p">,</span> <span class="n">overflow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span> <span class="o">=</span> <span class="n">x264_rc_analyse_slice</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxsum</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxcount</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxsum</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLIP_DURATION</span><span class="p">(</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">fenc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_duration</span><span class="p">)</span> <span class="o">/</span> <span class="n">BASE_FRAME_DURATION</span><span class="p">);</span>
</span><span class='line'><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxcount</span><span class="o">++</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">rce</span><span class="p">.</span><span class="n">text_bits</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span><span class="p">;</span>
</span><span class='line'><span class="n">rce</span><span class="p">.</span><span class="n">blurred_complexity</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxsum</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">short_term_cplxcount</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<h1 id="vbv-algorithm">VBV Algorithm</h1>

<p>VBV 是一种帧级别的码率控制算法，它是这样一种机制: VBV 相当于一个容器，每编码一帧，都从容器内取走对应 bit 的数据；与此同时，往容器内以固定的速度输入 bit。每编码完一帧，根据容器内的充盈状态(上溢/下溢)，更新接下来编码参数，使得容器的充盈程都总是处于合理的范围内。</p>

<p>视频缓冲检测器(VBV, Video Buffer Verifer)是 MPEG 视频缓冲模型，可以确保码率不会超过某个最大值。VBV Buffer Size 通常设置为 maximum rate 的两倍;如果客户端缓存比较小，设置 bufsize 等于 maxrate;如果想要限制码流的码率，设置 buffersize 为 maximum rate 的一半或更小。</p>

<p>先来看一下，x264 中关于 VBV 的几个变量定义：<br />
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="kt">x264_ratecontrol_t</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">b_vbv</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">b_vbv_min_rate</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/*VBV stuff*/</span>
</span><span class='line'><span class="kt">double</span> <span class="n">buffer_size</span><span class="p">;</span>     <span class="c1">//VBV buffer size, 容器的总容量</span>
</span><span class='line'><span class="kt">int64_t</span> <span class="n">buffer_fill_final</span><span class="p">;</span>
</span><span class='line'><span class="kt">int64_t</span> <span class="n">buffer_fill_final_min</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">buffer_fill</span><span class="p">;</span> <span class="c1">//planned buffer, if all in-progress frames hit their bit budget</span>
</span><span class='line'><span class="n">doublt</span> <span class="n">buffer_rate</span><span class="p">;</span> <span class="c1">//# of bits added to buffer_fill after each frame</span>
</span><span class='line'><span class="kt">double</span> <span class="n">vbv_max_rate</span><span class="p">;</span><span class="c1">//# of bits added to buffer_fill per second</span>
</span><span class='line'><span class="kt">predictor_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>  <span class="c1">//predict frame size from satd</span>
</span><span class='line'><span class="kt">int</span> <span class="n">single_frame_vbv</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">rate_factor_max_increment</span><span class="p">;</span> <span class="c1">//Don&#39;t allow RF above(CRF + this value) } </span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>X264 中，关于 VBV 的调整在 clip_qscale 中。根据是否有 lookahead，可以分为 lookahead vbv 调整和实时 VBV 调整两种。</p>

<h2 id="lookahead-vbv-">Lookahead vbv 调整</h2>

<p>从 lookahead 模块可以得到未来若干帧的复杂度。vbv 算法的原理是：根据相同的帧类型，使用相同的 qscale 应用到 lookahead 中的帧中，检测会不会有帧使得 VBV 缓存下溢，并且 lookahead 中所有帧编码结束后，缓存填充度在一个合理的范围内(0.5-0.8)，小步调整 qscale 直到满足上述要求。注意，代码中的对于 X264_TYPE_B 和 X264_TYPE_BREF 使用相同的 qscale，这里并步准确，其实可以设置不同的值，只需要使得 BREF 在 B 和 P 之间即可。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">terminate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">Avoid</span> <span class="n">an</span> <span class="n">infinite</span> <span class="n">loop</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iterations</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1000</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">terminate</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">iterations</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">buffer_fill_cur</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">target_fill</span><span class="p">;</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">total_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>	<span class="kt">double</span> <span class="n">last_duration</span> <span class="o">=</span> <span class="n">fenc_cpb_duration</span><span class="p">;</span>
</span><span class='line'>	<span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">?</span> <span class="n">q</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="nl">f_ip_factor</span> <span class="p">:</span> <span class="n">q</span><span class="p">;</span>
</span><span class='line'>	<span class="n">frame_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_pb_factor</span><span class="p">;</span>
</span><span class='line'>	<span class="n">frame_q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_ip_factor</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/* Loop over the planned future frames. */</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer_fill_cur</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">buffer_fill_cur</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">total_duration</span> <span class="o">+=</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class='line'>    <span class="n">buffer_fill_cur</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i_type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">fenc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">i_planned_type</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i_satd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">fenc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">i_planned_satd</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="n">i_type</span> <span class="o">==</span> <span class="n">X264_TYPE_AUTO</span> <span class="p">)</span>
</span><span class='line'>	<span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="n">i_type</span> <span class="o">=</span> <span class="n">IS_X264_TYPE_I</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_I</span> <span class="p">:</span> <span class="n">IS_X264_TYPE_B</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_B</span> <span class="p">:</span> <span class="n">SLICE_TYPE_P</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pred</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">frame_q</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">i_satd</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">buffer_fill_cur</span> <span class="o">-=</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class='line'>    <span class="n">last_duration</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">fenc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_planned_cpb_duration</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cm">/* Try to get to get the buffer at least 50% filled, but don&#39;t set an impossible goal. */</span>
</span><span class='line'><span class="n">target_fill</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span> <span class="o">+</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">buffer_fill_cur</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">*=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class='line'>    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cm">/* Try to get the buffer no more than 80% filled, but don&#39;t set an impossible goal. */</span>
</span><span class='line'><span class="n">target_fill</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span> <span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">b_vbv_min_rate</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">buffer_fill_cur</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">/=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class='line'>    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h2 id="vbv-">实时 VBV 调整</h2>

<p>如果没有 lookahead，未来帧的复杂度未知，只能根据当前帧的复杂度，控制缓存的充盈程度。算法主要流程如下：</p>

<ol>
  <li>对于 P 帧和第一个 I 帧，让当前帧编码完成后，缓存区至少还有一半容量。</li>
  <li>限制每帧大小不能超过当前缓存量的一半。</li>
  <li>限制每帧大小至少是 buffer_rate 的一半。buffer_rate = vbv-maxrate/fps。</li>
  <li>限制 qscale 不能小于输入 qscale。</li>
</ol>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_P</span> <span class="o">||</span>
</span><span class='line'>        <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_non_b_pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span>
</span><span class='line'>        <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mf">0.5</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">q</span> <span class="o">/=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="cm">/* Now a hard threshold to make sure the frame fits in VBV.</span>
</span><span class='line'><span class="cm"> * This one is mostly for I-frames. */</span>
</span><span class='line'><span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class='line'><span class="cm">/* For small VBVs, allow the frame to use up the entire VBV. */</span>
</span><span class='line'><span class="kt">double</span> <span class="n">max_fill_factor</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_buffer_size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_max_bitrate</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">fps</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="cm">/* For single-frame VBVs, request that the frame use up the entire VBV. */</span>
</span><span class='line'><span class="kt">double</span> <span class="n">min_fill_factor</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">single_frame_vbv</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">max_fill_factor</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="p">(</span><span class="n">max_fill_factor</span><span class="o">*</span><span class="n">bits</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">/=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class='line'>    <span class="n">bits</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_rate</span><span class="o">/</span><span class="n">min_fill_factor</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">bits</span><span class="o">*</span><span class="n">min_fill_factor</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_rate</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h2 id="mingop-vbv-">minGOP vbv 调整</h2>

<p>B 帧 QP 不直接被 VBV 调整，它由 P 帧加一个偏移量得到。这一步检查当前 P 帧和（编码顺序）到下一个 P 帧之前的 B 帧的复杂度。适当调低 qscale (调高码率预算)，使得本 minGOPher 过后，缓存区没有上溢。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">last_satd</span><span class="p">);</span>
</span><span class='line'><span class="kt">double</span> <span class="n">frame_size_maximum</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frame_size_maximum</span><span class="p">,</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buffer_fill</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">));</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">frame_size_maximum</span><span class="p">)</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">*=</span> <span class="n">bits</span> <span class="o">/</span> <span class="n">frame_size_maximum</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">b_vbv_min_rate</span><span class="p">)</span>
</span><span class='line'>    <span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>参考文档:<br />
<a href="https://codesequoia.wordpress.com/2010/04/19/what-are-cbr-vbv-and-cpb/">What are CBR, VBV and CPB</a>  <br />
<a href="https://www.youtube.com/watch?v=Mn8v1ojV80M">The Hypothetical Reference Decoder(HRD)</a></p>

<h1 id="mb-tree-algorithm">MB-Tree Algorithm</h1>

<h2 id="macroblock-tree-">Macroblock-Tree 的高层概述</h2>

<p>MB-tree 算法的目的是预测信息量，该信息量表示每个宏块对未来帧的贡献。该信息允许MB-tree基于其贡献，加权每个树的质量宏块。为此，MB-tree的工作方向与预测方向相反，将信息从将来的帧传播回要编码的当前帧。</p>

<p>为此，MB-tree 需要知道多种信息，或者至少近似的信息量。首先，它必须知道即将分析的未来帧的帧类型。其次，它必须知道这些帧的运动向量。第三，它必须知道每个步骤要传播多少信息量，这会根据帧内和帧间消耗来计算。接下来描述的lookahead会说明如何获取这些信息。</p>

<h2 id="x264-lookahead">x264 lookahead</h2>

<p>x264 有个复杂的lookahead模块，该模块设计用来，在真正的编码模块分析之前，预测帧的编码消耗。它用这些预测信息来做很多的决定，比如自适应的B帧的位置、显示加权预测、以及缓冲区受阻的码率控制的比特分配。因为性能的原因，它的操作是对一半分辨率进行的，并且仅仅计算SATD残差，并不做量化和重建。</p>

<p>lookahead的核心是<code>x264_slicetype_frame_cost</code>函数，它会被重复的调用来计算p0/p1/b的帧代价。p0是被分析帧的前向预测帧，p1是被分析帧的后向预测帧，b是被分析的帧。如果p1等于b，则分析的帧是P帧。如果p0等于b，则分析的帧是I帧。因为<code>x264_slicetype_frame_cost</code>可能会在算法中被重复调用很多次，每次调用的结果都要保存下来以备未来使用。</p>

<p><code>x264_slicetype_frame_cost</code>针对每个宏块调用<code>x264_slicetype_mb_cost</code>。因为帧只有一半的分辨率，每个宏块是<code>8x8</code>的，而不是<code>16x16</code>的。<code>x264_slicetype_mb_cost</code>对每个参考帧执行向量搜索。向量搜索是典型的六边形运动搜索。</p>

<p>对于B帧，它还会检查一些可能的双向模式：一个模式类似于264的时间方向，零向量；一个模式使用运动矢量结果来自list0和list1运动搜索。<code>x264_slicetype_mb_cost</code>同样计算合适的帧内代价。所有的这些代价被保存下来，用于将来使用。这对于MB-tree非常重要，它需要这些信息用于计算。</p>

<p>这些分析的结果主要用于Viterbi算法中自适应B帧的放置。Viterbi 算法的输出不仅仅在下一帧的类型判断时使用到，而且在后面N帧的类型判断中会用到，其中N是lookahead的大小。该计划实际上是一个队列：it changes over time as frames are pulled from one end and encoded using the specified frame types, frames are added to the other end as new frames enter the encoder, and the plan is recalculated. 该计划的存在对于宏块树非常重要：它意味着很多需要知道未来帧帧类型的算法，有个可信赖的精准预测。即使GOP的结构是变化的。</p>

<p>结果，MB-tree知道未来N帧的帧类型，即近似的运动矢量和模式决策以及帧内/帧间模式代价。这样的计算成本接近于零，因为这些数据在做其他任务时，在编码器内部已经计算完了。即使这样，相对于总的编码时间，lookahead的计算消耗也是成本很低的。</p>

<h2 id="macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</h2>

<p>对于每一帧，我们在所有宏块上执行 propagate step，MacroBlock-Tree 操作的 propagate step 如下：</p>

<ol>
  <li>对于当前宏块，读取下面变量的值：
    <ul>
      <li>intra_cost: 该宏块的帧内模式的预测 SATD 代价。</li>
      <li>inter_cost: 该宏块的帧间模式的预测 SATD 代价。如果该值比 intra_cost 大，设置其为 intra_cost。</li>
      <li>propatate_in: 该宏块的 propagate_cost。因为没有任何信息，执行 propagate 的第一帧，它的 propagate_cost 值为 0。</li>
    </ul>
  </li>
  <li>计算要执行 propagate 的当前宏块对其参考帧的宏块的信息的分数，称为 propagate_fraction。计算方法为 1 - intra_cost / inter_cost。例如，如果 inter_cost 是 intra_cost 的 80%，我们说该宏块有 20% 的信息来自于它的参考帧。</li>
  <li>和当前宏块有关的所有信息总和大约为 intra_cost + propagate_cost（自身信息和提供给后续帧的信息），使用这个总和乘以继承率 propagate fraction, 可以得到来继承自参考帧的信息量 propagate amount。</li>
  <li>将 propagate_amount 划分给参考帧中相关的宏块，由于当前宏块在参考帧中运动搜索得到的补偿区域可能涉及多个宏块，即参考帧中的多个宏块都参与了当前宏块的运动补偿，所以我们根据参考帧宏块参与补偿的部分尺寸大小来分配 propagate amount。特别的，对于 B 帧，我们把 propatate amount 先平分给两个参考帧，再进一步分配给参考帧中的宏块。参考帧中的宏块最终被分到的 propagate amount 加起来就是它的 propagate cost。</li>
  <li>从前向预测的最后一帧向前一直计算到当前帧，可以得到当前帧中每个宏块对后续 n 帧的 propagate_cost，最后根据当前帧每个宏块的 propatate_cost，计算相应的偏移系数 qp_offset，所使用的公式如下：</li>
</ol>

<p>MacroblockQP = -strength * log2((intra_cost + propagate_cost) / intra_cost)。</p>

<p>其中强度系数 strength 为常量，对于未被参考的宏块而言，propagate_cost = 0, qp_offset = 0。</p>

<p>X264 源码中实现MB-Tree 的函数为 macroblock_tree，其中调用了如下三个函数来实现上述步骤：</p>

<ol>
  <li>slicetype_frame_cost():计算宏块的帧内代价和帧间代价。</li>
  <li>macroblock_tree_propagate():计算当前宏块的遗传代价。</li>
  <li>macroblock_tree_finish():计算量化参数偏移系数。</li>
</ol>

<p>参考文档：<br />
<a href="https://download.csdn.net/download/To_Be_IT_1/19848868?spm=1001.2014.3001.5501">A novel macroblock-tree algorithm for high-performance optimization of.pdf</a></p>

<h1 id="adaptive-quantization-algorithm">Adaptive Quantization Algorithm</h1>

<p>自适应量化就是根据宏块的复杂度来调整每个宏块量化时的量化参数。自适应量化的基本原理是：根据当前宏块的复杂度 SSD，与当前帧的平均复杂度做对比，若高于平均，则分配更多的码率，即用小于当前帧 QP 值的量化步长；低于平均值则分配更少的码率，即用大于当前帧的 QP 值的量化步长。</p>

<p>自适应量化主要有两个参数：aq-mode（自适应量化模式）、aq-strength（自适应量化强度）。自适应量化强度决定码率偏向于低细节(SSD)部分的强度。</p>

<p>X264 中，自适应量化的实现在<code>x264_adaptive_quant_frame</code>中：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* constants chosen to result in approximately the same overall bitrate as without AQ.</span>
</span><span class='line'><span class="cm"> * FIXME: while they’re written in 5 significant digits, they’re only tuned to 2. */</span>
</span><span class='line'><span class="kt">float</span> <span class="n">strength</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">avg_adj</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">bias_strength</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">bit_depth_correction</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="err">« </span><span class="p">(</span><span class="mi">2</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class='line'>    <span class="kt">float</span> <span class="n">avg_adj_pow2</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">powf</span><span class="p">(</span> <span class="n">energy</span> <span class="o">*</span> <span class="n">bit_depth_correction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.125f</span> <span class="p">);</span>
</span><span class='line'>            <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class='line'>            <span class="n">avg_adj</span> <span class="o">+=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class='line'>            <span class="n">avg_adj_pow2</span> <span class="o">+=</span> <span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="n">avg_adj</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class='line'>    <span class="n">avg_adj_pow2</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class='line'>    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class='line'>    <span class="n">avg_adj</span> <span class="o">=</span> <span class="n">avg_adj</span> <span class="o">-</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="n">avg_adj_pow2</span> <span class="o">-</span> <span class="mf">14.f</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class='line'>    <span class="n">bias_strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="mf">1.0397f</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">float</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">mb_xy</span> <span class="o">=</span> <span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">)</span> <span class="o">+</span> <span class="n">bias_strength</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="mf">14.f</span> <span class="o">/</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">x264_log2</span><span class="p">(</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">14.427f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">quant_offsets</span> <span class="p">)</span>
</span><span class='line'>            <span class="n">qp_adj</span> <span class="o">+=</span> <span class="n">quant_offsets</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class='line'>        <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">f_qp_offset_aq</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frames</span><span class="p">.</span><span class="n">b_have_lowres</span> <span class="p">)</span>
</span><span class='line'>            <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">i_inv_qscale_factor</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">x264_exp2fix8</span><span class="p">(</span><span class="n">qp_adj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<h1 id="section-2">优化方法</h1>

<h2 id="vbr-">VBR 情况下的码率优化</h2>

<p>通常情况下，CRF 的值与 QP 都是严格一对一的，这里其实是并不准确的。比如当前帧画面复杂，人眼对其并不敏感，此时可以选择更大的 QP。基于此，优化思路是：根据当前帧的复杂度，优化 CRF 与 QP 之间的映射关系。这个在纯 CRF 下可以节省 3% 的码率。基本思想就是让更多的码率用于人眼敏感的平坦区域。这就实现了<strong>帧级别的内容自适应</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264 Loop Filter Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/09/h264-loop-filter/"/>
    <updated>2021-06-09T17:05:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/09/h264-loop-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">引入环路滤波的原因</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">环路滤波的介绍</a></li>
</ul>

<p>本文将从去块滤波的引入原因出发，分析去块滤波的原理、强度、决策、实现，并给出一个具体的实例，最后会给出 x264 中关于 Deblock 的代码实现。</p>

<!--more-->

<h2 id="section">引入环路滤波的原因</h2>

<p>在编码过程中，会因如下原因引入块效应：</p>

<ol>
  <li>每个宏块的变换、量化过程都是独立进行的，采用的量化参数不同，这就会引入量化误差，导致相邻块边界步连续。</li>
  <li>在运动补偿中，相邻块的预测值可能来自不同图像的不同位置，导致预测残差信号在边界产生数值不连续。</li>
</ol>

<p>环路滤波的引入，可以调整相邻宏块边缘上的像素值，降低不连续性，使其看起来更平滑。</p>

<h2 id="section-1">环路滤波的介绍</h2>

<p>下面给出两篇论文中，关于环路滤波部分的介绍：首先给出<code>Overview of the H.264/AVC Video Coding Standard</code> 中的<code>K. In-Loop Deblocking Filter</code>的介绍。我把它翻译成长中文如下。</p>

<blockquote>
  <p>基于块的编码的一个特殊特征是偶然产生可见的块结构。块边缘通常以低于内部像素的精度重建，块通常被认为是当前压缩方法中最明显的伪影之一。为此，H.264/AVC 定义了一种自适应的环路去块滤波器，其中滤波的强度由若干语法元素的值控制。有关自适应去块滤波器的详细说明，请参阅<a href="">Adaptive deblocking filter</a>;</p>

  <p>图 16 给出了使用一维边缘的可视化的去块滤波器的原理。样本 p0 和 q0 以及 p1 和 q1 是否被滤波取决于使用的量化参数(QP)和量化阈值α(QP)和β(QP)。因此，仅当满足以下每个条件时，才进行 p0 和 q0 的滤波：<br />
1. |p0 - q0 | &lt; α(QP) <br />
2. |p1 - p0 | &lt; β(QP)<br />
3. |q1 - q0 | &lt; β(QP) <br />
其中 β(QP) 比 α(QP) 小的多。如果满足相应的以下条件，则进行 p1 或 q1 的滤波： |p2 - p0| &lt; β(QP) 或者 |q2 - q0| &lt; β(QP)</p>

  <p>基本思想是，如果测量块边缘附近的样本之间相对较大的绝对差，则很可能是块伪影，因此应减少。然而，如果该差异的幅度太大以致不能用编码中使用的量化的粗糙度来解释，则边缘更可能反映源图片的实际行为，并且不应被平滑。</p>

  <p>块效应降低，而内容的锐化程度基本不变。因此，主观质量显著提高。滤波器通常将比特率降低 5%-10%，同时产生与未滤波视频相同的客观质量。</p>
</blockquote>

]]></content>
  </entry>
  
</feed>
