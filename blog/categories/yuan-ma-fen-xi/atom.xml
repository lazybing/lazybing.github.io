<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/yuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-07-03T01:59:56-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AVCodec 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avcodec-structure/"/>
    <updated>2016-07-03T01:11:57-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avcodec-structure</id>
    <content type="html"><![CDATA[<p>AVCodec是存储编解码器信息的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVCodec{</p>

<pre><code>const char *name;
const char *long_name;
enum AVMediaType type;
enum AVCodecID id;
int capabilities;
const AVRational *supported_framerates; ///&lt; array of supported framerates, or NULL if any, array is terminated by {0,0}
const enum AVPixelFormat *pix_fmts;     ///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1
const int *supported_samplerates;       ///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0
const enum AVSampleFormat *sample_fmts; ///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1
const uint64_t *channel_layouts;         ///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0
uint8_t max_lowres;                     ///&lt; maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()
const AVClass *priv_class;              ///&lt; AVClass for the private context
const AVProfile *profiles;              ///&lt; array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
int priv_data_size;
struct AVCodec *next;
int (*init_thread_copy)(AVCodecContext *);
int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);
const AVCodecDefault *defaults;
void (*init_static_data)(struct AVCodec *codec);

int (*init)(AVCodecContext *);
int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,
int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,
               int *got_packet_ptr);
int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);
int (*close)(AVCodecContext *);
void (*flush)(AVCodecContext *);
int caps_internal;
</code></pre>

<p>}
{% endblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVIOContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/02/aviocontext/"/>
    <updated>2016-07-02T17:15:20-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/02/aviocontext</id>
    <content type="html"><![CDATA[<p>AVIOContext 是FFMPEG管理输入输出数据的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}</p>

<p>typedef struct AVIOContext{
    const AVClass <em>av_class;
    unsigned char </em>buffer;  /<strong>&lt; Start of the buffer. */
    int buffer_size;        /</strong>&lt; Maximum buffer size <em>/
    unsigned char </em>buf_ptr; /<strong>&lt; Current position in the buffer <em>/
    unsigned char </em>buf_end; /</strong>&lt; End of the data <em>/
    int (</em>read_packet)(void <em>opaque, uint8_t </em>buf, int buf_size);
    int (<em>write_packet)(void </em>opaque, uint8_t <em>buf, int buf_size);
    int64_t (</em>seek)(void <em>opaque, int64_t offset, int whence);
    int64_t pos;            /**&lt; position in the file of the current buffer </em>/
    int must_flush;         /<strong>&lt; true if the next seek should flush */
    int eof_reached;        /</strong>&lt; true if eof reached <em>/
    int write_flag;         /**&lt; true if open for writing </em>/
    int max_packet_size;
    unsigned long checksum;
    unsigned char <em>checksum_ptr;
    unsigned long (</em>update_checksum)(unsigned long checksum, const uint8_t <em>buf, unsigned int size);
    int error;              /**&lt; contains the error code or 0 if no error happened </em>/
    int (<em>read_pause)(void </em>opaque, int pause);
    int64_t (<em>read_seek)(void </em>opaque, int stream_index,
                         int64_t timestamp, int flags);
    int seekable;
    int64_t maxsize;
    int direct;
    int64_t bytes_read;
    int seek_count;
    int writeout_count;
    int orig_buffer_size;
    int short_seek_threshold;
}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVCodecContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/01/avcodeccontext-structure/"/>
    <updated>2016-07-01T10:16:42-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/01/avcodeccontext-structure</id>
    <content type="html"><![CDATA[<p>AVCodecContext 可能是最复杂的结构体了。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVCodecContext{
    const AVClass <em>av_class;
    int log_level_offset;
    enum AVMediaType codec_type;
    const struct AVCodec </em>codec;
    enum AVCodecID     codec_id;
    unsigned int codec_tag;
    void <em>priv_data;
    struct AVCodecInternal </em>internal;
    void <em>opaque;
    int bit_rate;
    int bit_rate_tolerance;
    int global_quality;
    int compression_level;
    int flags;
    int flags2;
    uint8_t </em>extradata;
    int extradata_size;
    AVRational time_base;
    int ticks_per_frame;
    int delay;
    int width, height;
    int coded_width, coded_height;
    int gop_size;
    enum AVPixelFormat pix_fmt;
    void (<em>draw_horiz_band)(struct AVCodecContext </em>s,
                            const AVFrame <em>src, int offset[AV_NUM_DATA_POINTERS],
                            int y, int type, int height);
    enum AVPixelFormat (</em>get_format)(struct AVCodecContext <em>s, const enum AVPixelFormat * fmt);
    int max_b_frames;
    float b_quant_factor;
    int b_frame_strategy;
    float b_quant_offset;
    int has_b_frames;
    int mpeg_quant;         /</em>decoding: unused<em>/
    float i_quant_factor;   /</em>decoding: unused<em>/
    float i_quant_offset;   /</em>decoding: unused<em>/
    float lumi_masking;     /</em>decoding: unused<em>/
    float temporal_cplx_masking; /</em>decoding: unused<em>/
    float spatial_cplx_masking;  /</em>decoding: unused<em>/
    float p_masking;        /</em>decoding: unused<em>/
    float dark_masking;     /</em>decoding: unused<em>/
    int slice_count;
    int prediction_method;  /</em>decoding: unused<em>/
    int </em>slice_offset;
    AVRational sample_aspect_ratio;
    int me_cmp;             /<em>decoding: unused</em>/
    int me_sub_cmp;         /<em>decoding: unused</em>/
    int mb_cmp;             /<em>decoding: unused</em>/
    int ildct_cmp;          /<em>decoding: unused</em>/
    int dia_size;           /<em>decoding: unused</em>/
    int last_predictor_count;   /<em>decoding: unused</em>/
    int pre_me;             /<em>decoding: unused</em>/
    int me_pre_cmp;         /<em>decoding: unused</em>/
    int pre_dia_size;       /<em>decoding: unused</em>/
    int me_subpel_quality;  /<em>decoding: unused</em>/
    int me_range;           /<em>decoding: unused</em>/
    int slice_flags;
    int mb_decision;
    uint16_t <em>intra_matrix;
    uint16_t </em>inter_matrix;
    int scenechange_threshold;  /<em>decoding: unused</em>/
    int noise_reduction;        /<em>decoding: unused</em>/
    int intra_dc_precision;
    int skip_top;
    int skip_bottom;
    int mb_lmin;            /<em>decoding: unused</em>/
    int mb_lmax;            /<em>decoding: unused</em>/
    int me_penalty_compensation;    /<em>decoding: unused</em>/
    int bidir_refine;       /<em>decoding: unused</em>/
    int brd_scale;          /<em>decoding: unused</em>/
    int keyint_min;         /<em>decoding: unused</em>/
    int refs;
    int chromaoffset;       /<em>decoding: unused</em>/
    int mv0_threshold;      /<em>decoding: unused</em>/
    int b_sensitivity;      /<em>decoding: unused</em>/
    enum AVColorPrimaries color_primaries;
    enum AVColorTransferCharacteristic color_trc;
    enum AVColorSpace colorspace;
    enum AVColorRange color_range;
    enum AVChromaLocation chroma_sample_location;
    int slices;             /<em>decoding: unused</em>/
    enum AVFieldOrder field_order;
    int sample_rate;        /<em> audio only </em>/
    int channels;           /<em> audio only </em>/
    enum AVSampleFormat sample_fmt;
    int frame_size;
    int frame_number;
    int block_align;
    int cutoff;             /<em>decoding: unused</em>/
    uint64_t channel_layout;    /<em> audio </em>/
    uint64_t request_channel_layout;
    enum AVAudioServiceType audio_service_type;
    enum AVSampleFormat request_sample_fmt;
    int (<em>get_buffer2)(struct AVCodecContext </em>s, AVFrame <em>frame, int flags);
    int refcounted_frames;
    float qcompress;    /</em> - encoding parameters <em>/
    float qblur;        /</em> - encoding parameters <em>/
    int qmin;           /</em>decoding: unused<em>/
    int qmax;           /</em>decoding: unused<em>/
    int max_qdiff;      /</em>decoding: unused<em>/
    int rc_buffer_size;     /</em>decoding: unused<em>/
    int rc_override_count;  /</em>decoding: unused<em>/
    RcOverride </em>rc_override;/<em>decoding: unused</em>/
    int rc_max_rate;
    float rc_max_available_vbv_use; /<em>decoding: unused</em>/
    float rc_min_vbv_overflow_use;  /<em>decoding: unused</em>/
    int rc_initial_buffer_occupancy;/<em>decoding: unused</em>/
    int coder_type;             /<em>decoding: unused</em>/
    int context_model;          /<em>decoding: unused</em>/
    int frame_skip_threshold;   /<em>decoding: unused</em>/
    int frame_skip_factor;      /<em>decoding: unused</em>/
    int frame_skip_exp;         /<em>decoding: unused</em>/
    int frame_skip_cmp;         /<em>decoding: unused</em>/
    int trellis;                /<em>decoding: unused</em>/
    int min_prediction_order;   /<em>decoding: unused</em>/
    int max_prediction_order;   /<em>decoding: unused</em>/
    int64_t timecode_frame_start;
    void (<em>rtp_callback)(struct AVCodecContext </em>avctx, void *data, int size, int mb_nb);
    int rtp_payload_size;</p>

<pre><code>/* statistics, used for 2-pass encoding */
int mv_bits;
int header_bits;
int i_tex_bits;
int p_tex_bits;
int i_count;
int p_count;
int skip_count;
int misc_bits;

int frame_bits;     /*decoding: unused*/
char *stats_out;    /*decoding: unused*/
char *stats_in;     /*decoding: unused*/

int workaround_bugs;
int strict_std_compliance;
int error_concealment;
int debug;
int64_t reordered_opaque;
struct AVHWAccel *hwaccel;
void *hwaccel_context;
uint64_t error[AV_NUM_DATA_POINTERS]; /*decoding: unused*/
int dct_algo;   /*decoding: unused*/
int idct_algo;
int bits_per_coded_sample;
int bits_per_raw_sample;
int thread_count;
int thread_type;
int active_thread_type;
int thread_safe_callbacks;
int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void *arg2, int *ret, int count, int size);
int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);
int nsse_weight;    /*decoding: unused*/
int profile;
int level;
enum AVDiscard skip_loop_filter;
enum AVDiscard skip_idct;
enum AVDiscard skip_frame;
uint8_t *subtitle_header;
int subtitle_header_size;
uint64_t vbv_delay;     /*decoding: unused*/
int side_data_only_packets;
int initial_padding;
AVRational framerate;
enum AVPixelFormat sw_pix_fmt;
AVRational pkt_timebase;
const AVCodecDescriptor *codec_descriptor;

int64_t pts_correction_num_faulty_pts; /// Number of incorrect PTS values so far
int64_t pts_correction_num_faulty_dts; /// Number of incorrect DTS values so far
int64_t pts_correction_last_pts;       /// PTS of the last frame
int64_t pts_correction_last_dts;       /// DTS of the last frame

char *sub_charenc;
int sub_charenc_mode;
int skip_alpha;
int seek_preroll;
int debug_mv;
uint16_t *chroma_intra_matrix;
uint8_t *dump_separator;
char *codec_whitelist;
unsigned properties;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVFormatContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/06/30/avformatcontext-structure/"/>
    <updated>2016-06-30T07:42:13-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/06/30/avformatcontext-structure</id>
    <content type="html"><![CDATA[<p>AVFormatContext 是包含码流参数比较多的结构体，它是 FFmpege 解封装(flv、mp4、rmvb、avi)功能的结构体。一般使用 avformat_alloc_context() 来创建该结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVFormatContext {
    const AVClass <em>av_class;
    struct AVInputFormat </em>iformat;
    struct AVOutputFormat <em>oformat;
    void </em>priv_data;
    AVIOContext <em>pb;
    int ctx_flags;
    unsigned int nb_streams;
    AVStream **streams;
    char filename[1024];
    int64_t start_time;
    int64_t duration;
    int bit_rate;
    unsigned int packet_size;
    int max_delay;
    int flags;
    const uint8_t </em>key;
    int keylen;</p>

<pre><code>unsigned int nb_programs;
AVProgram **programs;

enum AVCodecID video_codec_id;
enum AVCodecID audio_codec_id;
enum AVCodecID subtitle_codec_id;

unsigned int max_index_size;
unsigned int max_picture_buffer;
unsigned int nb_chapters;
AVChapter **chapters;
AVDictionary *metadata;
int64_t start_time_realtime;
int fps_probe_size;
int error_recognition;
AVIOInterruptCB interrupt_callback;
int64_t max_interleave_delta;
int strict_std_compliance;
int event_flags;
int max_ts_probe;
int avoid_negative_ts;
int ts_id;
int audio_preload;
int max_chunk_duration;
int max_chunk_size;
int use_wallclock_as_timestamps;
int avio_flags;
enum AVDurationEstimationMethod duration_estimation_method;
int64_t skip_initial_bytes;
unsigned int correct_ts_overflow;
int seek2any;
int probe_score;
int format_probesize;
char *codec_whitelist;
char *format_whitelist;
AVFormatInternal *internal;
int io_repositioned;
AVCodec *video_codec;
AVCodec *audio_codec;
AVCodec *subtitle_codec;
AVCodec *data_codec;
int metadata_header_padding;
void *opaque;
av_format_control_message control_message_cb;
int64_t output_ts_offset;
uint8_t *dump_separator;
enum AVCodecID data_codec_id;
int (*open_cb)(struct AVFormatContext *s, AVIOContext **p, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options);  
</code></pre>

<p>}
{% endcodeblock lang:c %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVFrame 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/06/28/avframe-structure/"/>
    <updated>2016-06-28T09:10:38-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/06/28/avframe-structure</id>
    <content type="html"><![CDATA[<p><code>AVFrame</code> 这个结构体主要描述了解码后的未压缩的视频和音频数据。</p>

<!--more-->


<hr />

<p><code>AVFrame</code>必须使用<code>av_frame_alloc()</code>函数来分配，注意该函数只能分配<code>AVFrame</code>，对于分配出的内存需要靠其他方法来管理。<code>AVFrame</code>必须由<code>av_frame_free()</code>函数释放。<code>AVFrame</code>只需分配一次，即可多次重复使用来存储不停的数据data——一个<code>AVFrame</code>可以可以存储解码出的多张 frame。</p>

<p>{% codeblock lang:c AVFrame%}</p>

<p>typedef struct AVFrame{</p>

<h1>define AV_NUM_DATA_POINTERS 8</h1>

<pre><code>uint8_t *data[AV_NUM_DATA_POINTERS];
int linesize[AV_NUM_DATA_POINTERS];
uint8_t **extended_data;
int width, height;
int nb_samples; /* number of audio samples(per channel) described by this frame */
int format;
int key_frame; /* 1-&gt;keyframe, 0-&gt;not*/
enum AVPictureType pict_type;
AVRational sample_aspect_ratio;
int64_t pts;
int64_t pkt_pts;
int64_t pkt_dts;
int coded_picture_number;
int display_picture_number;
int quality;
void *opaque; /* for some private data of the user */
uint64_t error[AV_NUM_DATA_POINTERS];
int repeat_pict;
int interlaced_frame;
int top_field_first;    /* If the content is interlaced, is top field displayed first */
int palette_has_changed;
int64_t reordered_opaque;
int sample_rate;    /*Sample rate of the audio data*/
uint64_t channel_layout; /*channel layout of the audio data*/
AVBufferRef *buf[AV_NUM_DATA_POINTERS];
AVBufferRef **extended_buf;
int nb_exteneded_buf;
AVFrameSideData **side_data;
int nb_side_data;
</code></pre>

<h1>define AV_FRAME_FLAG_CORRUPT   (1&lt;&lt;0)</h1>

<pre><code>int flags;
enum AVColorRange color_range;
enum AVColorPrimaries color_primaries;
enum AVColorTransferCharacteristic color_trc;
enum AVColorSpace colorspace;
enum AVChromaLocation chroma_location;

int64_t best_effort_timestamp;
int64_t pkt_pos;
int64_t pkt_duration;
AVDictionary *metadata;
int decode _error_flags;
</code></pre>

<h1>define FF_DECODE_ERROR_INVALID_BITSTREAM   1</h1>

<h1>define FF_DECODE_ERROR_MISSING_REFERENCE   2</h1>

<pre><code>int channels;
int pkt_size;
AVBufferRef *qp_table_buf;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
