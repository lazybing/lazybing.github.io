<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:ffmpeg源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/ffmpegyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-07-04T09:03:21-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FFMpeg 实现视频编码、解码、封装、解封装、转码、缩放以及添加水印]]></title>
    <link href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/"/>
    <updated>2017-01-01T07:17:10-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ffmpeg-" id="markdown-toc-ffmpeg-">FFMpeg 编码实现</a></li>
  <li><a href="#ffmpeg--1" id="markdown-toc-ffmpeg--1">FFMpeg 解码实现</a></li>
  <li><a href="#ffmpeg--2" id="markdown-toc-ffmpeg--2">FFMpeg 封装实现</a></li>
  <li><a href="#ffmpeg--3" id="markdown-toc-ffmpeg--3">FFMpeg 解封装实现</a></li>
  <li><a href="#ffmpeg--4" id="markdown-toc-ffmpeg--4">FFMpeg 转码的实现</a></li>
  <li><a href="#ffmpeg--5" id="markdown-toc-ffmpeg--5">FFMpeg 视频缩放实现</a></li>
  <li><a href="#ffmpeg--6" id="markdown-toc-ffmpeg--6">FFMpeg 添加水印实现</a></li>
</ul>

<p><a href="&quot;https://ffmpeg.org/&quot;">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理，本文主要利用 FFMpeg 官方提供的 SDK 实现音视频最简单的几个实例：编码、解码、封装、解封装、转码、缩放以及添加水印。<br />
<!--more-->
接下来会由发现问题－＞分析问题－＞解决问题－＞实现方案，循序渐进的完成。<br />
参考代码：<a href="&quot;https://github.com/lazybing/ffmpeg-study-recording&quot;">ｌａｚｙｂｉｎｇ</a></p>

<h2 id="ffmpeg-">FFMpeg 编码实现</h2>

<p>本例子实现的是将视频域 YUV 数据编码为压缩域的帧数据，编码格式包含了 H.264/H.265/MPEG1/MPEG2 四种 CODEC 类型。
实现的过程，可以大致用如下图表示:</p>

<p><img src="/images/ffmpeg_sdk/encoder.png"></p>

<p>从图中可以大致看出视频编码的流程:</p>

<ul>
  <li>首先要有未压缩的 YUV 原始数据。</li>
  <li>其次要根据想要编码的格式选择特定的编码器。</li>
  <li>最后编码器的输出即为编码后的视频帧。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>存放待压缩的 YUV 原始数据。此时可以利用 FFMpeg 提供的 AVFrame 结构体，并根据 YUV 数据来填充 AVFrame　结构的视频宽高、像素格式；根据视频宽高、像素格式可以分配存放数据的内存大小，以及字节对齐情况。</li>
  <li>获取编码器。利用想要压缩的格式，比如　H.264/H.265/MPEG1/MPEG2 等，来获取注册的编解码器，编解码器在 FFMpeg 中用 AVCodec 结构体表示，对于编解码器，肯定要对其进行配置，包括待压缩视频的宽高、像素格式、比特率等等信息，这些信息，FFMpeg 提供了一个专门的结构体 AVCodecContext 结构体。</li>
  <li>存放编码后压缩域的视频帧。FFMpeg 中用来存放压缩编码数据相关信息的结构体为 AVPacket。最后将 AVPacket 存储的压缩数据写入文件即可。</li>
</ul>

<hr />

<p>AVFrame 结构体的分配使用<code>av_frame_alloc()</code>函数，该函数会对 AVFrame 结构体的某些字段设置默认值，它会返回一个指向 AVFrame 的指针或 NULL指针(失败)。AVFrame 结构体的释放只能通过<code>av_frame_free()</code>来完成。注意，该函数只能分配 AVFrame 结构体本身，不能分配它的 data buffers 字段指向的内容，该字段的指向要根据视频的宽高、像素格式信息手动分配，本例使用的是<code>av_image_alloc()</code>函数。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//allocate AVFrame struct</span>
</span><span class='line'><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Frame</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//fill AVFrame struct fields</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">AV_PIX_FMT_YUV420P</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//allocate AVFrame data buffers field point</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">linesize</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//write input file data to frame-&amp;gt;data buffer</span>
</span><span class='line'><span class="n">fread</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">widht</span><span class="o">*</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="n">av_frame_free</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<hr />

<p>编解码器相关的 AVCodec 结构体的分配使用<code>avcodec_find_encoder(enum AVCodecID id)</code>完成，该函数的作用是找到一个与 AVCodecID 匹配的已注册过得编码器；成功则返回一个指向 AVCodec ID 的指针，失败返回 NULL 指针。该函数的作用是确定系统中是否有该编码器，只是能够使用编码器进行特定格式编码的最基本的条件，要想使用它，至少要完成两个步骤：</p>

<ol>
  <li>根据特定的视频数据，对该编码器进行特定的配置；</li>
  <li>打开该编码器。</li>
</ol>

<p>针对第一步中关于编解码器的特定参数，FFMpeg 提供了一个专门用来存放 AVCodec 所需要的配置参数的结构体 AVCodecContext 结构。它的分配使用<code>avcodec_alloc_context3(const AVCodec *codec)</code>完成，该函数根据特定的 CODEC 分配一个 AVCodecContext 结构体，并设置一些字段为默认参数，成功则返回指向 AVCodecContext 结构体的指针，失败则返回 NULL 指针。分配完成后，根据视频特性，手动指定与编码器相关的一些参数，比如视频宽高、像素格式、比特率、GOP 大小等。最后根据参数信息，打开找到的编码器，此处使用<code>avcodec_open2()</code>函数完成。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//register all encoder and decoder</span>
</span><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//find the encoder</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_encoder</span><span class="p">(</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">Not</span> <span class="n">Find</span> <span class="n">the</span> <span class="n">Encoder</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//allocate the AVCodecContext and fill it’s fields</span>
</span><span class='line'><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecCtx</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="mi">4000000</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span>    <span class="o">=</span> <span class="n">frameWidth</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span>   <span class="o">=</span> <span class="n">frameHeight</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">time_base</span><span class="o">=</span> <span class="p">(</span><span class="n">AVRational</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//open the encoder</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Encoder</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<hr />

<p>存放编码数据的结构体为 AVPacket，使用之前要对该结构体进行初始化，初始化函数为<code>av_init_packet(AVPacket *pkt)</code>，该函数会初始化 AVPacket 结构体中一些字段为默认值，但它不会设置其中的 data 和 size 字段，需要单独初始化,如果此处将 data 设为 NULL、size 设为 0，编码器会自动填充这两个字段。</p>

<p>有了存放编码数据的结构体后，我们就可以利用编码器进行编码了。FFMpeg 提供的用于视频编码的函数为<code>avcodec_encode_video2</code>,它作用是编码一帧视频数据，该函数比较复杂，单独列出如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avcodec_encode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">,</span>
</span><span class='line'>                          <span class="k">const</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_packet_ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>它会接收来自 AVFrame-&gt;data 的视频数据，并将编码数据放到 AVPacket-&gt;data 指向的位置，编码数据大小为 AVPacket-&gt;size。</p>

<p>其参数和返回值的意义：</p>

<ul>
  <li>avctx: AVCodecContext 结构，指定了编码的一些参数；</li>
  <li>avPkt: AVPacket对象的指针，用于保存输出的码流；</li>
  <li>frame：AVFrame结构，用于传入原始的像素数据；</li>
  <li>got_packet_ptr:输出参数，用于标识是否已经有了完整的一帧；</li>
  <li>返回值：编码成功返回 0， 失败返回负的错误码；</li>
</ul>

<p>编码完成后就可将AVPacket-&gt;data内的编码数据写到输出文件中；代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//init AVPacket</span>
</span><span class='line'><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//encode the image</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_encode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">got_output</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Encode</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="err">｝</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">got_output</span><span class="p">){</span>
</span><span class='line'>	<span class="n">fwrite</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>编码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/encoder.c">编码实现</a>。</p>

<h2 id="ffmpeg--1">FFMpeg 解码实现</h2>

<p>解码实现的是将压缩域的视频数据解码为像素域的 YUV 数据。实现的过程，可以大致用如下图所示。</p>

<p><img src="/images/ffmpeg_sdk/decoder.png"></p>

<p>从图中可以看出，大致可以分为下面三个步骤：</p>

<ul>
  <li>首先要有待解码的压缩域的视频。</li>
  <li>其次根据压缩域的压缩格式获得解码器。</li>
  <li>最后解码器的输出即为像素域的 YUV 数据。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>关于输入数据。首先，要分配一块内存，用于存放压缩域的视频数据；之后，对内存中的数据进行预处理，使其分为一个一个的 AVPacket 结构（AVPacket 结构的简单介绍如上面的编码实现）。最后，将 AVPacket 结构中的 data 数据给到解码器。</li>
  <li>关于解码器。首先，利用 CODEC_ID 来获取注册的解码器；之后，将预处理过得视频数据给到解码器进行解码。</li>
  <li>关于输出。FFMpeg 中，解码后的数据存放在 AVFrame 中；之后就将 AVFrame 中的 data 字段的数据存放到输出文件中。</li>
</ul>

<hr />

<p>对于输入数据，首先，通过 fread 函数实现将固定长度的输入文件的数据存放到一块 buffer 内。H.264中一个包的长度是不定的，读取固定长度的码流通常不可能刚好读出一个包的长度；对此，FFMpeg 提供了一个 AVCoderParserContext 结构用于解析读到 buffer 内的码流信息，直到能够取出一个完整的 H.264 包。为此，FFMpeg 提供的函数为<code>av_parser_parse2</code>，该函数比较复杂，定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">poutbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">poutbuf_size</span><span class="p">,</span>
</span><span class='line'>                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_size</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">int64_t</span> <span class="n">pts</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dts</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>函数的参数和返回值含义如下：</p>

<ul>
  <li>AVCodecParserContext *s:初始化过的 AVCodecParserContext 对象，决定了码流该以怎样的标准进行解析；</li>
  <li>AVCodecContext *avctx：预先定义好的 AVCodecContext 对象；</li>
  <li>uint8_t **poutbuf：AVPacket：：data 的地址，保存解析完成的包数据。</li>
  <li>int *poutbuf_size：AVPacket 的实际数据长度，如果没有解析出完整的一个包，该值为 0；</li>
  <li>const uint8_t *but:待解码的码流的地址；</li>
  <li>int buf_size:待解码的码流的长度；</li>
  <li>int64_t pts, int64_t dts:显示和解码的时间戳；</li>
  <li>int64_t pos:码流中的位置；</li>
  <li>返回值为解析所使用的比特位的长度；</li>
</ul>

<p>FFMpeg 中为我们提供的该函数常用的使用方式为：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">in_len</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">myparser</span><span class="p">.</span> <span class="n">AVCodecContext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">size</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">in</span> <span class="n">len</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">dts</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">in_data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'><span class="n">in_len</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>	<span class="n">decode_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。</p>

<p>因此，关于输入数据的处理，代码大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//open input file</span>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="n">pInput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Input_FileName</span><span class="p">,</span> <span class="err">“</span><span class="n">rb</span><span class="o">+</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInput_File</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Input</span> <span class="n">File</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class='line'><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class='line'>							<span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class='line'>							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class='line'>	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="n">decode_frame</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>注意，上面提到的<code>av_parser_parse2</code>函数用的几个参数，其实是与具体的编码格式有关的，它们应该在之前已经分配好了，我们只是放到后面来讲一下，因为它们是与具体的解码器强相关的。</p>

<hr />

<p>对于解码器。与上面提到的编码实现类似，首先，根据 CODEC_ID 找到注册的解码器 AVCodec，FFMpeg 为此提供的函数为<code>avcodec_find_decoder()</code>；其次，根据找到的解码器获取与之相关的解码器上下文结构体 AVCodecC，使用的函数为编码中提到的<code>avcodec_alloc_context3</code>；再者，如上面提到的要获取完整的一个 NALU，解码器需要分配一个 AVCodecParserContext 结构，使用函数<code>av_parser_init</code>；最后，前面的准备工作完成后，打开解码器，即可调用 FFMpeg 提供的解码函数<code>avcodec_decode_video2</code>对输入的压缩域的码流进行解码，并将解码数据存放到 AVFrame-&gt;data 中。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//register all encoder and decoder</span>
</span><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate AVFrame to Store the Decode Data</span>
</span><span class='line'><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Frame</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Find the  AVCodec Depending on the CODEC_ID</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Find</span> <span class="n">the</span> <span class="n">Decoder</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate the AVCodecContext </span>
</span><span class='line'><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecCtx</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate the AVCodecParserContext </span>
</span><span class='line'><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="n">av_parser_init</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pCodecParserCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecParserContext</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Open the Decoder</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">Open</span> <span class="n">the</span> <span class="n">Decoder</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class='line'><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class='line'>							<span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class='line'>							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class='line'>	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="c1">//decode start</span>
</span><span class='line'><span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">got_frame</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>注意，上面解码的过程中，针对具体的实现，可能要做一些具体参数上的调整，此处只是理清解码的流程。</p>

<hr />

<p>对于输出数据。解码完成后，解码出来的像素域的数据存放在 AVFrame 的 data 字段内，只需要将该字段内存放的数据之间写文件到输出文件即可。解码函数<code>avcodec_decode_video2</code>函数完成整个解码过程，对于它简单介绍如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class='line'>                         <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>                         <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>该函数各个参数的意义：</p>

<ul>
  <li>AVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成；</li>
  <li>AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好；</li>
  <li>int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了;</li>
  <li>const AVPacket *avpkt: 前面解析好的码流包；</li>
</ul>

<p>由此可见，当标识位为1时，代表解码一帧结束，可以写数据到文件中。代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pOutput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Output_FileName</span><span class="p">,</span> <span class="err">“</span><span class="n">wb</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pOutput_File</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Output</span> <span class="n">File</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">){</span>
</span><span class='line'>	<span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span> <span class="n">Len</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>解码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/decoder.c">解码实现</a>。</p>

<h2 id="ffmpeg--2">FFMpeg 封装实现</h2>

<p>本例子实现的是将视频数据和音频数据，按照一定的格式封装为特定的容器，比如FLV、MKV、MP4、AVI等等。实现的过程，可以大致用如下图表示：</p>

<p><img src="/images/ffmpeg_sdk/muxer.png"></p>

<p>从图中可以大致看出视频封装的流程：</p>

<ul>
  <li>首先要有编码好的视频、音频数据。</li>
  <li>其次要根据想要封装的格式选择特定的封装器。</li>
  <li>最后利用封装器进行封装。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>利用给定的YUV数据编码得到某种 CODEC 格式的编码视频（可以参见上面提到的<a href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/#ffmpeg-">编码实现</a>），同样的方法得到音频数据。</li>
  <li>获取输出文件格式。获取输出文件格式可以直接指定文件格式，比如FLV/MKV/MP4/AVI等，也可以通过输出文件的后缀名来确定，或者也可以选择默认的输出格式。根据得到的文件格式，其中可能有视频、音频等，为此我们需要为格式添加视频、音频、并对格式中的一些信息进行设置（比如头）。</li>
  <li>利用设置好的音频、视频、头信息等，开始封装。</li>
</ul>

<hr />

<p>对于由 YUV 数据得到编码的视频数据部分，不再重复。直接看与 Muxer 相关的部分，与特定的 Muxer 相关的信息，FFMpeg 提供了一个 AVFormatContext 的结构体描述，并用<code>avformat_alloc_output_context2()</code>函数来分配它。该函数的声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avformat_alloc_output_context2</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">oformat</span><span class="p">,</span>
</span><span class='line'>                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中：</p>

<ul>
  <li>ctx:输出到 AVFormatContext 结构的指针，如果函数失败则返回给该指针为 NULL。</li>
  <li>oformat：指定输出的 AVOutputFormat 类型，如果设为 NULL，则根据 format_name 和 filename 生成。</li>
  <li>format_name:输出格式的名称，如果设为 NULL，则使用 filename 默认格式。</li>
  <li>filename：目标文件名，如果不使用，可以设为 NULL。</li>
  <li>返回值：&gt;=0 则成功，否则失败。</li>
</ul>

<p>代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
</span><span class='line'><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="cm">/* allocate the output media context */</span>
</span><span class='line'><span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">deduce</span> <span class="n">output</span> <span class="n">format</span> <span class="n">from</span> <span class="n">file</span> <span class="nl">extension</span><span class="p">:</span> <span class="n">using</span> <span class="n">MPEG</span><span class="p">.</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="err">“</span><span class="n">mpeg</span><span class="err">”</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">oformat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>有了表示媒体文件格式的 AVFormatContext 结构后，就需要根据媒体格式来判断是否需要往媒体文件中添加视频流、音频流（有的媒体文件，这两种流并不是必须的）；以 MP4 格式的媒体文件为例，我们需要一路视频流、一路音频流。因此需要创建一路流，FFMpeg 提供的创建流的函数为<code>avformat_new_stream()</code>，该函数完成向 AVFormatContext 结构体中所代码的媒体文件中添加数据流，函数声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVStream</span> <span class="o">*</span><span class="nf">avformat_new_stream</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中：</p>

<ul>
  <li>s:AVFormatContext 结构，表示要封装生成的视频文件。</li>
  <li>c：视频或音频流的编码器的指针。</li>
  <li>返回值：指向生成的 stream 对象的指针；失败则返回 NULL。</li>
</ul>

<p>注意：对于 Muxer，该函数必须在调用<code>avformat_write_header()</code>前调用。使用完成后，需要调用<code>avcodec_close()</code>和<code>avformat_free_context()</code>来清理由它分配的内容。</p>

<p>该函数调用完成后，一个新的 AVStream 便已经加入到输出文件中，下面就需要设置 stream 的 id 和 codec 等参数。以视频流为例，代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">OutputStream</span> <span class="o">*</span><span class="n">ost</span><span class="p">;</span>
</span><span class='line'><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodec</span> <span class="o">**</span><span class="n">codec</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="n">AVStream</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">st</span> <span class="o">=</span> <span class="n">avformat_new_stream</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">allocate</span> <span class="n">stream</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">st</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">id</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">nb_streams</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>参数设置完成后，就可以打开编码器并为编码器分配必要的内存。步骤跟之前的类似，以视频为例，示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//open the codec</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">opt</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">open</span> <span class="n">video</span> <span class="nl">codec</span><span class="p">:</span> <span class="o">%</span><span class="n">s</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//allocate and init a re-usable frame</span>
</span><span class='line'><span class="n">ost</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">alloc_picture</span><span class="p">(</span><span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>接下来进行真正的封装：首先，为媒体文件添加头部信息,FFMpeg 为此提供的函数为<code>avformat_write_header()</code>。其次，将编码好的音视频 AVPacket 包添加到媒体文件中去，FFMpeg 为此提供的函数为<code>av_interleaved_write_frame()</code>。最后，写入文件尾的数据，FFMpeg 为此提供的函数为<code>av_write_trailer()</code>。</p>

<p>封装的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/muxer.c">封装实现</a>。</p>

<p><video width='640' height='320' preload='metadata' controls ><source src='https://github.com/lazybing/lazybing.github.io/blob/source/images/ffmpeg.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'></video></p>

<h2 id="ffmpeg--3">FFMpeg 解封装实现</h2>

<h2 id="ffmpeg--4">FFMpeg 转码的实现</h2>

<h2 id="ffmpeg--5">FFMpeg 视频缩放实现</h2>

<h2 id="ffmpeg--6">FFMpeg 添加水印实现</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avformat_find_stream_info]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info/"/>
    <updated>2016-12-25T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">调用关系</a></li>
</ul>

<p><code>avformat_find_stream_info</code>主要是读媒体文件的包(packets)，然后从中提取出流的信息。
对于没有头部信息的文件格式尤其有用，比如<code>MPEG</code>。文件的逻辑位置不会被改变，读取出来
的包会被缓存起来供以后处理。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
</code>
返回值：&gt;=0–&gt;OK,或出错返回AVERROR_xxx</p>

<p>注意，该函数并不保证能够打开所有的 codec，因此将options 设置为非NULL用于返回一些信息是非常好的行为。</p>

<h2 id="section-1">调用关系</h2>

<p><img src="http://lazybing.github.io/images/avformat_find_stream_info/avformat_find_stream_info.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_decode_video2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video/"/>
    <updated>2016-12-20T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a></li>
</ul>

<p><code>avcodec_decode_video</code>函数的作用是解码<code>AVPacket</code>中的压缩数据，解码为图像数据。
某些解码器支持在一个<code>AVPacket</code>中包含多帧，这类的解码器只解码第一帧。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                         int *got_picture_ptr,
                         const AVPacket *avpkt);
</code></p>

<p>注意，输入内存的对齐字节(AV_INPUT_BUFFER_PADDING_SIZE)比实际读取字节要大，因为某些
最优流可能会读取 32 或 64 bits 每次。</p>

<p>在将压缩数据packets给到解码器之前，<code>AVCodecContext</code>必须用<code>avcodec_open2</code>设置过。</p>

<p>函数参数：</p>

<ul>
  <li><code>AVCodecContext *</code>。</li>
  <li><code>AVFrame *</code>存放解码的视频数据，它使用<code>av_frame_alloc</code>获得一个<code>AVFrame</code>。解码器会调用
<code>AVCodecContext.get_buffer2</code>回调函数为实际的位图分配内存。</li>
  <li><code>got_picture_ptr</code>,如果没有帧可以解码，该值被设为0。否则，它是非零值。</li>
  <li><code>AVPacket *</code>包含输入缓存。该结构体使用<code>av_init_packet</code>创建后会设置<code>data</code>和<code>size</code>，某些
解码器可能需要更多的字段,如<code>flags &amp; AV_PKT_FLAG_KEY</code>。解码器被设置为使用最少的字段。</li>
</ul>

<p>返回值：如果解码出错，返回负值；否则返回使用的字节数。</p>

<h2 id="section-1">源码分析</h2>

<p><code>avcodec_decode_video2</code>函数比较简单，主要做了以下几个工作：</p>

<ol>
  <li>对输入的字段进行一些列的检查工作，比如宽高是否正确，输入是否为视频等等。</li>
  <li>真正的解码，通过<code>avctx-&gt;codec-&gt;decode</code>实现，它会调用相应的<code>AVCodec</code>的 decode 函数，完成解码。</li>
  <li>对得到的<code>AVFrame</code>进行一些字段进行赋值，例如宽高、像素格式等等。</li>
</ol>

<p><figure class='code'><figcaption><span>avcodec_decode_video2 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">attribute_align_arg</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class='line'>                                              <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>                                              <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="err">…</span>
</span><span class='line'>    <span class="c1">//检测输入参数</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="err">“</span><span class="n">Invalid</span> <span class="n">media</span> <span class="n">type</span> <span class="k">for</span> <span class="n">video</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="n">got_picture_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">((</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_width</span> <span class="o">||</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_height</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">av_image_check_size</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_width</span><span class="p">,</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avctx</span><span class="p">))</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">//真正的解码</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">decode</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">picture</span><span class="p">,</span> <span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">//设置参数</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">capabilities</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_CODEC_CAP_DR1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>    <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">)</span>                      <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span>               <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">)</span>                     <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">format</span> <span class="o">==</span> <span class="n">AV_PIX_FMT_NONE</span><span class="p">)</span>   <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">format</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>以H.265解码器为例，解码示例如下：</p>

<p><figure class='code'><figcaption><span>ff_hevc_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="err">“</span><span class="n">hevc</span><span class="err">”</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="err">“</span><span class="n">HEVC</span> <span class="p">(</span><span class="n">High</span> <span class="n">Efficiency</span> <span class="n">Video</span> <span class="n">Coding</span><span class="p">)</span><span class="err">”</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class='line'>    <span class="err">…</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中<code>hevc_decode_frame</code>是解码器的真正的解码函数，定义如下：<br />
<figure class='code'><figcaption><span>hevc_decode_frame </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">hevc_decode_frame</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_output</span><span class="p">,</span>
</span><span class='line'>                             <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="n">HEVCContext</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">priv_data</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">ff_hevc_output_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">ret</span>    <span class="o">=</span> <span class="n">decode_nal_units</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">hwaccel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">hwaccel</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">end_frame</span><span class="p">(</span><span class="n">avctx</span><span class="p">))</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span>
</span><span class='line'>               <span class="s">&quot;hardware accelerator failed to decode picture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* verify the SEI checksum */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">err_recognition</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_EF_CRCCHECK</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span>
</span><span class='line'>        <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_md5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ret</span> <span class="o">=</span> <span class="n">verify_md5</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">err_recognition</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_EF_EXPLODE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_md5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_DEBUG</span><span class="p">,</span> <span class="s">&quot;Decoded frame with POC %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">poc</span><span class="p">);</span>
</span><span class='line'>    <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">output_frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">av_frame_move_ref</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">output_frame</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：av_read_frame]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/15/av_read_frame/"/>
    <updated>2016-12-15T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/15/av_read_frame</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数调用关系</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">源码分析</a></li>
</ul>

<p><code>av_read_frame</code>函数的作用是返回文件中保存的数据。它会文件中保存的数据分成不同的帧，
每次调用都会返回一帧。注意，该函数不会忽略帧与帧之间无效数据(非帧数据)，目的是给解码器
最多的信息用于解码。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int av_read_frame(AVFormatContext *s, AVPacket *pkt);
</code></p>

<p>如果<code>pkt-&gt;buf</code>是 NULL,包直到下一次调用<code>av_read_frame</code>或<code>avformat_close_input</code>时都是有效的。
不需要时，包必须通过<code>av_free_packet</code>释放。对于视频，<code>packet</code>只包含一帧；对于音频，如果每帧有固定大小(如 PCM 或 ADPCM 数据)，
<code>packet</code>可以包含多个音频帧（必须是整数帧）,如果音频帧大小可变(如MPEG 音频)，它只能包含一帧数据。</p>

<p><code>pkt-&gt;pts</code><code>pkt-&gt;dts</code><code>pkt-&gt;duration</code>都是以<code>AVStream.time_base_units</code>为单位的。
如果视频格式里包含 B 帧，<code>pkt-&gt;pts</code>可以是<code>AV_NOPTS_VALUE</code>,因此如果不解压缩数据，最好
查看<code>pkt-&gt;dts</code>。</p>

<p>如果函数返回0，正确；小于0，则为到文件尾或出错。</p>

<h2 id="section-1">函数调用关系</h2>

<p><img src="http://lazybing.github.io/images/av_read_frame/av_read_frame.png" /></p>

<h2 id="section-2">源码分析</h2>

<p><code>av_read_frame</code>函数会判断在未解码缓存中是否有数据，如果有数据则调用<code>read_from_packet_buffer</code>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_open2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/10/avcodec-open2/"/>
    <updated>2016-12-10T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/10/avcodec-open2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数使用示例</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">函数源码分析</a></li>
</ul>

<p><code>avcodec_open2</code>函数实现的功能为利用给定的<code>AVCodec</code>结构初始化<code>AVCodecContext</code>结构。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>avcodec_open2</code>的声明如下:</p>

<p><code>
int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);
</code></p>

<p>函数参数说明：</p>

<ul>
  <li>avctx:需要初始化的context.</li>
  <li>codec:</li>
  <li>options:</li>
  <li>返回值：如果返回0，正确。失败则返回负数。</li>
</ul>

<p>该函数利用给定的<code>AVCodec</code>结构初始化<code>AVCodecContext</code>结构，在使用该函数之前，<code>AVCodecContext</code>
必须已经用<code>avcodec_alloc_context3()</code>函数分配出来。</p>

<p><code>AVCodec</code>结构在使用该函数之前，由<code>avcodec_find_decoder_by_name</code><code>avcodec_find_encoder_by_name</code>
<code>avcodec_find_decoder</code>或<code>avcodec_find_encoder</code>提前得到。</p>

<p>注意，在正式解码之前(比如使用<code>avcodec_decode_video2()</code>之前)，必须调用<code>avcodec_open2</code>函数。</p>

<h2 id="section-1">函数使用示例</h2>

<p>示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class='line'><span class="n">av_dict_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">opt</span><span class="p">,</span> <span class="err">“</span><span class="n">b</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="mf">2.5</span><span class="n">M</span><span class="err">”</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2 id="section-2">函数源码分析</h2>

<p><code>avcodec_open2</code>的逻辑非常简单，首先是进行一些参数检测、之后调动<code>AVCodec</code>的init函数。大概步骤如下：</p>

<ul>
  <li>各种函数参数检测。</li>
  <li>各种结构体分配内存。</li>
  <li>将输入的<code>AVDictionary</code>形式的选项设置到<code>AVCodecContext</code>。</li>
  <li>其他一些零散的查，检查输入参数是否符合编码器的要求。</li>
  <li>调用<code>AVCodec</code>的init函数初始化具体的解码器。</li>
</ul>

<p>此处重点分析调用<code>AVCodec</code>的init函数处。 以 HEVC 解码器为例。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="err">“</span><span class="n">hevc</span><span class="err">”</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="err">“</span><span class="n">HEVC</span> <span class="p">(</span><span class="n">High</span> <span class="n">Efficiency</span> <span class="n">Video</span> <span class="n">Coding</span><span class="p">)</span><span class="err">”</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">update_thread_context</span> <span class="o">=</span> <span class="n">hevc_update_thread_context</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">init_thread_copy</span>      <span class="o">=</span> <span class="n">hevc_init_thread_copy</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">capabilities</span>          <span class="o">=</span> <span class="n">AV_CODEC_CAP_DR1</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_DELAY</span> <span class="o">|</span>
</span><span class='line'>                             <span class="n">AV_CODEC_CAP_SLICE_THREADS</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_FRAME_THREADS</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">profiles</span>              <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="n">profiles</span><span class="p">),</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中 init 函数定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">av_cold</span> <span class="kt">int</span> <span class="nf">hevc_decode_init</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">HEVCContext</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">priv_data</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ff_init_cabac_states</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">internal</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">allocate_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">hevc_init_context</span><span class="p">(</span><span class="n">avctx</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">enable_parallel_tiles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">picture_struct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">active_thread_type</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">FF_THREAD_SLICE</span><span class="p">)</span>
</span><span class='line'>    <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">threads_number</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">thread_count</span><span class="p">;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>    <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">threads_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">extradata_size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">extradata</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">hevc_decode_extradata</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">hevc_decode_free</span><span class="p">(</span><span class="n">avctx</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">((</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">active_thread_type</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">FF_THREAD_FRAME</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">thread_count</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">threads_type</span> <span class="o">=</span> <span class="n">FF_THREAD_FRAME</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">threads_type</span> <span class="o">=</span> <span class="n">FF_THREAD_SLICE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

]]></content>
  </entry>
  
</feed>
