<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ffmpeg源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/ffmpegyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-12-06T07:24:00-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_find_decoder和avcodec_find_encoder]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/06/av-find-encdec/"/>
    <updated>2016-12-06T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/06/av-find-encdec</id>
    <content type="html"><![CDATA[<p><code>avcodec_find_decoder</code>和<code>avcodec_find_encoder</code> 主要是查找 FFmpeg 的解码器和编码器。<br />
<!--more--></p>

<p>avcodec_find_decoder 和 avcodec_find_encoder 主要是利用 AVCodecID 来查找编解码器。<br />
其实质是遍历AVCodec 链表并且获得符合AVCodecID的元素。</p>

<p>avcodec_find_decoder 定义如下：</p>

<p>{% codeblock [lang:c] avcodec_find_decoder %}
AVCodec *avcodec_find_decoder(enum AVCodecID id)
{
    return find_encdec(id, 0);
}
{% endcodeblock %}</p>

<p>由定义可以看出，该函数利用 AVCodecID 查找 AVCodec，并将找到的 AVCodec 返回。
<code>find_encdec</code>定义如下：<br />
{% codeblock [lang:c] find_encdec %}
static AVCodec *find_encdec(enum AVCodecID id, int encoder)
{
    AVCodec *p, *experimental = NULL;
    p = first_avcodec;
    id= remap_deprecated_codec_id(id);
    while (p) {
        if ((encoder ? av_codec_is_encoder(p) : av_codec_is_decoder(p)) &amp;&amp;
            p-&gt;id == id) {
            if (p-&gt;capabilities &amp; AV_CODEC_CAP_EXPERIMENTAL &amp;&amp; !experimental) {
                experimental = p;
            } else
                return p;
        }
        p = p-&gt;next;
    }
    return experimental;
}
{% endcodeblock %}</p>

<p>其中<code>av_codec_is_decoder</code>定义如下：<br />
{% codeblock [lang:c] av_codec_is_decoder %}
int av_codec_is_decoder(const AVCodec *codec)
{
    return codec &amp;&amp; codec-&gt;decode;
}
{% endcodeblock %}</p>

<p><code>av_codec_is_encoder</code>定义如下：<br />
{% codeblock [lang:c] av_codec_is_decoder %}
int av_codec_is_encoder(const AVCodec *codec)
{
    return codec &amp;&amp; (codec-&gt;encode_sub || codec-&gt;encode2);
}
{% endcodeblock %}</p>

<p>查找编解码器除了上述的<code>avcodec_find_decoder</code>和<code>avcodec_find_encoder</code>外，还可以利用编解码器名字来查找函数为：avcodec_find_encoder_by_name 和 avcodec_find_decoder_by_name，在此不再赘述。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_register_all]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/"/>
    <updated>2016-12-05T08:42:17-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/05/avcodec-register-all</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#avcodecregisterall-" id="markdown-toc-avcodecregisterall-">avcodec_register_all 框架</a></li>
  <li><a href="#section" id="markdown-toc-section">调用关系</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">注册一次</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">注册硬件加速器</a></li>
      <li><a href="#codec" id="markdown-toc-codec">注册codec</a></li>
      <li><a href="#parser" id="markdown-toc-parser">注册parser</a></li>
      <li><a href="#bitstream-filters" id="markdown-toc-bitstream-filters">注册bitstream filters</a></li>
    </ul>
  </li>
</ul>

<p>avcodec_register_all 提供注册<code>codec</code><code>parsers</code><code>filters</code>的功能。</p>

<!--more-->

<h2 id="avcodecregisterall-">avcodec_register_all 框架</h2>

<p>{% codeblock lang:c avcodec_register_all %}
void avcodec_register_all(void)
{
    static int initialized;</p>

<pre><code>if(initialized)
    return;
initialized = 1;

/* hardwar accelerators */
REGISTER_HWACCEL(H264_MMAL,h264_mmal);
......

/* video codecs */
REGISTER_DECODER(HEVC,hevc);
......
REGISTER_ENCDEC (MPEG4,mpeg4);
......
/* audio codecs */
REGISTER_ENCDEC (AAC,aac);
......
/* parsers */
REGISTER_PARSER(HEVC,hevc);
/* bitstream filters */
REGISTER_BSF(HEVC_MP4TOANNEXB,hevc_mp4toannexb); } {% endcodeblock %}
</code></pre>

<h2 id="section">调用关系</h2>

<p><img src="http://lazybing.github.io/images/avcodec_register_all/avcodec_register_all.png" /></p>

<p>从<code>avcodec_register_all</code>的框架和调用关系图可以看出，该函数主要注册硬件加速器、codec、parsers、比特流过滤器等。</p>

<h2 id="section-1">源码分析</h2>

<h3 id="section-2">注册一次</h3>

<p>{% codeblock lang:c initialized_once %}
static int initialized;</p>

<p>if(initialized)
    return;
initialized = 1;
{% endcodeblock %}</p>

<p>该段代码可以看出，当调用过该函数一次后，再次调用时，该函数直接返回。<br />
注意，这种方法在 FFMEPG 源码中非常常见。</p>

<h3 id="section-3">注册硬件加速器</h3>

<p>{% codeblock lang:c REGISTER_HWACCEL %}
#define REGISTER_HWACCEL(X, x)                                          \
    {                                                                   \
        extern AVHWAccel ff_##x##<em>hwaccel;                              \
        if (CONFIG</em>##X##<em>HWACCEL)                                       \
            av_register_hwaccel(&amp;ff</em>##x##_hwaccel);                     \
    }
{% endcodeblock %}</p>

<p>以<code>H264</code>为例，<code>REGISTER_HWACCEL(H264_MMAL, h264_mmal)</code>展开如下：</p>

<p><code>
extern AVHWAccel ff_h264_mmal_hwaccel;
if(CONFIG_H264_MMAL_HWACCEL)
    av_register_hwaccel(&amp;ff_h264_mmal_hwaccel);
</code></p>

<p><code>av_register_hwaccel(&amp;ff_h264_mmal_hwaccel)</code> 展开如下：</p>

<p>{% codeblock lang:c av_register_hwaccel %}
void av_register_hwaccel(AVHWAccel <em>hwaccel)
{
    AVHWAccel **p = last_hwaccel;
    hwaccel-&gt;next = NULL;
    while(</em>p || avpriv_atomic_ptr_cas((void * volatile <em>)p, NULL, hwaccel))
        p = &amp;(</em>p)-&gt;next;
    last_hwaccel = &amp;hwaccel-&gt;next;
}
{% endcodeblock %}</p>

<h3 id="codec">注册codec</h3>

<p>{% codeblock lang:c REGISTER_DECODER %}
#define REGISTER_DECODER(X, x)                                          \
    {                                                                   \
        extern AVCodec ff_##x##<em>decoder;                                \
        if (CONFIG</em>##X##<em>DECODER)                                       \
            avcodec_register(&amp;ff</em>##x##_decoder);                        \
    }
{% endcodeblock %}</p>

<p>以<code>HEVC</code>为例，<code>REGISTER_DECODER(HEVC, hevc)</code>展开如下：</p>

<p><code>
extern AVCodec ff_hevc_decoder;
if(CONFIG_HEVC_DECODER)
    avcodec_register(&amp;ff_hevc_decoder);
</code></p>

<p><code>avcodec_register(&amp;ff_hevc_decoder)</code>展开如下：</p>

<p>{% codeblock lang:c avcodec_register %}
av_cold void avcodec_register(AVCodec *codec)
{
    AVCodec **p;
    avcodec_init();
    p = last_avcodec;
    codec-&gt;next = NULL;</p>

<pre><code>while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, codec))
    p = &amp;(*p)-&gt;next;
last_avcodec = &amp;codec-&gt;next;

if (codec-&gt;init_static_data)
    codec-&gt;init_static_data(codec); } {% endcodeblock %}
</code></pre>

<p>ff_hevc_decoder 定义如下：</p>

<p>{% codeblock lang:c ff_hevc_decoder %}
AVCodec ff_hevc_decoder = {
    .name                  = “hevc”,
    .long_name             = NULL_IF_CONFIG_SMALL(“HEVC (High Efficiency Video Coding)”),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_HEVC,
    .priv_data_size        = sizeof(HEVCContext),
    .priv_class            = &amp;hevc_decoder_class,
    .init                  = hevc_decode_init,
    .close                 = hevc_decode_free,
    .decode                = hevc_decode_frame,
    .flush                 = hevc_decode_flush,
    .update_thread_context = hevc_update_thread_context,
    .init_thread_copy      = hevc_init_thread_copy,
    .capabilities          = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                             AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS,
    .profiles              = NULL_IF_CONFIG_SMALL(profiles),
};
{% endcodeblock %}</p>

<h3 id="parser">注册parser</h3>

<p>{% codeblock lang:c REGISTER_PARSER %}
#define REGISTER_PARSER(X, x)                                           \
    {                                                                   \
        extern AVCodecParser ff_##x##<em>parser;                           \
        if (CONFIG</em>##X##<em>PARSER)                                        \
            av_register_codec_parser(&amp;ff</em>##x##_parser);                 \
    }
{% endcodeblock %}</p>

<p>以<code>HEVC</code>为例，<code>REGISTER_PARSER(HEVC, hevc)</code>展开如下：</p>

<p><code>
extern AVCoderParser ff_hevc_parser;
if(CONFIG_HEVC_PARSER)
    av_register_codec_parser(&amp;ff_hevc_parser);
</code></p>

<p><code>av_register_codec_parser(&amp;ff_hevc_parser)</code> 展开如下：</p>

<p>{% codeblock lang:c av_register_codec_parser %}
void av_register_codec_parser(AVCodecParser *parser)
{
    do {
        parser-&gt;next = av_first_parser;
    } while (parser-&gt;next != avpriv_atomic_ptr_cas((void * volatile *)&amp;av_first_parser, parser-&gt;next, parser));
}
{% endcodeblock %}</p>

<p>ff_hevc_parser 定义如下：</p>

<p>{% codeblock lang:c ff_hevc_parser %}
AVCodecParser ff_hevc_parser = {
    .codec_ids      = { AV_CODEC_ID_HEVC },
    .priv_data_size = sizeof(HEVCParserContext),
    .parser_parse   = hevc_parse,
    .parser_close   = hevc_parser_close,
    .split          = hevc_split,
};
{% endcodeblock %}</p>

<h3 id="bitstream-filters">注册bitstream filters</h3>

<p>{% codeblock lang:c REGISTER_BSF %}
#define REGISTER_BSF(X, x)                                              \
    {                                                                   \
        extern AVBitStreamFilter ff_##x##<em>bsf;                          \
        if (CONFIG</em>##X##<em>BSF)                                           \
            av_register_bitstream_filter(&amp;ff</em>##x##_bsf);                \
    }
{% endcodeblock %}</p>

<p>以<code>HEVC</code>为例，<code>REGISTER_BSF(HEVC_MP4TOANNEXB, hevc_mp4toannexb)</code> 展开如下：</p>

<p><code>
extern AVBitStreamFilter ff_hevc_mp4toannexb_bsf;
if(CONFIG_HEVC_MP4TOANNEXB_BSF)
    av_register_bitstream_filter(&amp;ff_hevc_mp4toannexb_bsf);
</code></p>

<p><code>av_register_bitstream_filter(&amp;&amp;ff_hevc_mp4toannexb_bsf)</code> 展开如下：</p>

<p>{% codeblock lang:c av_register_bitstream_filter %}
void av_register_bitstream_filter(AVBitStreamFilter *bsf)
{
    do {
        bsf-&gt;next = first_bitstream_filter;
    } while(bsf-&gt;next != avpriv_atomic_ptr_cas((void * volatile *)&amp;first_bitstream_filter, bsf-&gt;next, bsf));
}
{% endcodeblock %}</p>

<p>ff_hevc_mp4toannexb_bsf 定义如下：</p>

<p>{% codeblock lang:c ff_hevc_mp4toannexb_bsf %}
AVBitStreamFilter ff_hevc_mp4toannexb_bsf = {
    “hevc_mp4toannexb”,
    sizeof(HEVCBSFContext),
    hevc_mp4toannexb_filter,
    hevc_mp4toannexb_close,
};
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：av_register_all]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/05/av-register-all/"/>
    <updated>2016-12-05T04:45:48-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/05/av-register-all</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#avregisterall-" id="markdown-toc-avregisterall-">av_register_all 框架</a></li>
  <li><a href="#section" id="markdown-toc-section">调用关系</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">注册一次</a></li>
      <li><a href="#codec" id="markdown-toc-codec">注册 codec</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">注册复用器</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">注册解复用器</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">注册协议</a></li>
    </ul>
  </li>
</ul>

<p><code>av_register_all()</code>几乎是所有使用 FFMPEG 编程调用的第一个函数。<code>av_register_all()</code>的主要功能是注册所有的 formats 和 protocols。</p>

<!--more-->

<h2 id="avregisterall-">av_register_all 框架</h2>

<p>首先列一下该函数的大体框架：<br />
{% codeblock lang:c av_register_all %}
void av_register_all(void)
{
    static int initialized;</p>

<pre><code>if(initialized)
    return;
initialized = 1;

avcodec_register_all();

/*(de)muxers*/
......
REGISTER_MUXER   (F4V,              f4v);
......
REGISTER_MUXDEMUX(FLV,              flv);
REGISTER_MUXDEMUX(H264,             h264);
REGISTER_MUXDEMUX(HEVC,             hevc);
REGISTER_MUXER   (MP4,              mp4);

/*protocols*/
REGISTER_PROTOCOL(RTMP,             rtmp);
REGISTER_PROTOCOL(TCP,              tcp);
REGISTER_PROTOCOL(UDP,              udp);
...... } {% endcodeblock %}
</code></pre>

<h2 id="section">调用关系</h2>
<p><img src="http://lazybing.github.io/images/av_register_all/av_register_all.png" /></p>

<p>从调用关系图可以看出，通过调用<a href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/">avcodec_register_all</a>注册了和编解码器有关的组件；硬件加速器、解码器、编码器、Parser、Bistream Filter等，以及复用器、解复用器、协议处理。</p>

<h2 id="section-1">源码分析</h2>

<h3 id="section-2">注册一次</h3>

<p>{% codeblock lang:c initialized_once %}
static int initialized;</p>

<p>if (initialized)
    return;
initialized = 1;
{% endcodeblock %}</p>

<p>该段代码可以看出，当调用过该函数一次后，再次调用时，该函数直接返回。<br />
注意，这种方法在 FFMEPG 源码中非常常见。</p>

<h3 id="codec">注册 codec</h3>

<p><code>
avcodec_register_all();
</code>
该函数的作用为注册<code>codecs</code><code>parsers</code>和<code>filters</code>。<br />
该函数的源码，还请访问<a href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/">avcodec_register_all</a>函数。</p>

<h3 id="section-3">注册复用器</h3>

<p>{% codeblock lang:c REGISTER_MUXER %}
#define REGISTER_MUXER(X, x)                                            \
    {                                                                   \
        extern AVOutputFormat ff_##x##<em>muxer;                           \
        if (CONFIG</em>##X##<em>MUXER)                                         \
            av_register_output_format(&amp;ff</em>##x##_muxer);                 \
    }
{% endcodeblock %}</p>

<p>以<code>MP4</code>为例，<code>REGISTER_MUXER(MP4, mp4)</code>展开如下：<br />
<code>
extern AVOutpusFormat ff_mp4_muxer;
if(CONFIG_MP4_MUXER)
    av_register_output_format(&amp;ff_mp4_muxer);
</code></p>

<p><code>av_register_output_format(&amp;ff_mp4_muxer)</code>展开如下：</p>

<p>{% codeblock lang:c av_register_output_format %}
void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = last_oformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_oformat = &amp;format-&gt;next; } {% endcodeblock %}
</code></pre>

<h3 id="section-4">注册解复用器</h3>

<p>{% codeblock lang:c REGISTER_MUXER %}
#define REGISTER_DEMUXER(X, x)                                          \
    {                                                                   \
        extern AVInputFormat ff_##x##<em>demuxer;                          \
        if (CONFIG</em>##X##<em>DEMUXER)                                       \
            av_register_input_format(&amp;ff</em>##x##_demuxer);                \
    }
{% endcodeblock %}</p>

<p><code>av_register_input_format(&amp;ff_mp4_muxer)</code>展开如下：</p>

<p>{% codeblock lang:c av_register_output_format %}
void av_register_input_format(AVInputFormat *format)
{
    AVInputFormat **p = last_iformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_iformat = &amp;format-&gt;next; } {% endcodeblock %}
</code></pre>

<p>{% codeblock lang:c avpriv_atomic_ptr_cas %}
void *avpriv_atomic_ptr_cas(void * volatile *ptr, void *oldval, void *newval)
{
    void *ret;
    pthread_mutex_lock(&amp;atomic_lock);
    ret = *ptr;
    if (ret == oldval)
        *ptr = newval;
    pthread_mutex_unlock(&amp;atomic_lock);
    return ret;
}
{% endcodeblock %}</p>

<p>{% codeblock lang:c REGISTER_MUXDEMUX %}
#define REGISTER_MUXDEMUX(X, x) REGISTER_MUXER(X, x); REGISTER_DEMUXER(X, x)
{% endcodeblock %}</p>

<h3 id="section-5">注册协议</h3>

<p>{% codeblock lang:c REGISTER_PROTOCOL %}
#define REGISTER_PROTOCOL(X, x)                                         \
    {                                                                   \
        extern URLProtocol ff_##x##<em>protocol;                           \
        if (CONFIG</em>##X##<em>PROTOCOL)                                      \
            ffurl_register_protocol(&amp;ff</em>##x##_protocol);                \
    }
{% endcodeblock %}</p>

<p>以<code>TCP</code>为例，<code>REGISTER_PROTOCOL(TCP,tcp)</code>展开如下：</p>

<p><code>
extern URLProtocol ff_tcp_protocol;
if(CONFIG_TCP_PROTOCOL)
    ffurl_register_protocol(&amp;ff_tcp_protocol);
</code></p>

<p><code>ffurl_register_protocol(&amp;ff_tcp_protocol)</code>展开如下：</p>

<p>{% codeblock lang:c ffurl_register_protocol %}
int ffurl_register_protocol(URLProtocol <em>protocol)
{
    URLProtocol **p;
    p = &amp;first_protocol;
    while (</em>p)
        p = &amp;(*p)-&gt;next;
    *p             = protocol;
    protocol-&gt;next = NULL;
    return 0;
}
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFmpeg 学习之 FFplay 源码分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay/"/>
    <updated>2016-11-05T21:03:58-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay</id>
    <content type="html"><![CDATA[<p>FFplay 是一个简单便携的媒体播放器，它使用了 FFmpeg 和 SDL 库。<br />
<!--more--></p>

<h3 id="ffplay-">FFplay 的使用</h3>
<p>首先看一下 FFplay 的使用：安装完 FFmpeg 后，直接在命令行中输入 <br />
<code>
ffplay [options] bitstream_file
</code>
其中更详细的使用说明，可以使用<code>man ffplay</code>来查看。</p>

<p>其次我们可以通过使用<code>Esc</code><code>q</code>来推出播放，可以使用空格来暂停播放，可以使用<code>s</code>来执行逐帧播放视频等等操作。</p>

<h3 id="ffplay--1">FFplay 源码分析</h3>

<p>ffplay 里面最主要的函数时:<code>av_register_all()</code><code>SDL_Init(flags)</code><code>av_init_packet</code><code>stream_open</code><code>event_loop</code>。下面逐个分析这几个函数主要完成的功能。</p>

<h4 id="avregisterall">av_register_all()</h4>

<p><code>av_register_all</code>实现注册<code>codecs</code><code>demux</code>和<code>protocols</code>。其中注册的<code>codecs</code>时通过<code>avcodec_reigster_all()</code>函数来实现的；注册<code>demux</code>的方法，以 HEVC 为例。</p>

<p>{% codeblock lang:c %}
#define REGISTER_MUXER(X, x)                                            \
    {                                                                   \
        extern AVOutputFormat ff_##x##<em>muxer;                           \
        if (CONFIG</em>##X##<em>MUXER)                                         \
            av_register_output_format(&amp;ff</em>##x##_muxer);                 \
    }</p>

<h1 id="define-registerdemuxerx-x------------------------------------------">define REGISTER_DEMUXER(X, x)                                          \</h1>
<pre><code>{                                                                   \
    extern AVInputFormat ff_##x##_demuxer;                          \
    if (CONFIG_##X##_DEMUXER)                                       \
        av_register_input_format(&amp;ff_##x##_demuxer);                \
}
</code></pre>

<h1 id="define-registermuxdemuxx-x-registermuxerx-x-registerdemuxerx-x">define REGISTER_MUXDEMUX(X, x) REGISTER_MUXER(X, x); REGISTER_DEMUXER(X, x)</h1>

<p>REGISTER_MUXDEMUX(HEVC,hevc);
{% endcodeblock %}</p>

<p>将上面的宏展开即为：</p>

<p>{% codeblock lang:c %}
void av_register_input_format(AVInputFormat *format)
{
    AVInputFormat **p = last_iformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_iformat = &amp;format-&gt;next; }
</code></pre>

<p>void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = last_oformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_oformat = &amp;format-&gt;next; } {% endcodeblock %}
</code></pre>

<p>{% codeblock lang:c %}
AVOutputFormat ff_hevc_muxer = {
    .name              = “hevc”,
    .long_name         = NULL_IF_CONFIG_SMALL(“raw HEVC video”),
    .extensions        = “hevc”,
    .audio_codec       = AV_CODEC_ID_NONE,
    .video_codec       = AV_CODEC_ID_HEVC,
    .write_packet      = ff_raw_write_packet,
    .flags             = AVFMT_NOTIMESTAMPS,
};
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVPacket 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avpacket-structure/"/>
    <updated>2016-07-03T08:19:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avpacket-structure</id>
    <content type="html"><![CDATA[<p>AVPacket是存储压缩编码数据相关信息的结构体。
<!--more--></p>

<p>{% codeblock lang:c %}</p>

<p>typedef struct AVPacket{</p>

<pre><code>AVBufferRef *buf;
int64_t pts;
int64_t dts;
uint8_t *data;
int   size;
int   stream_index;
int   flags;
AVPacketSideData *side_data;
int side_data_elems;
int   duration;
int64_t pos;                            ///&lt; byte position in stream, -1 if unknown
int64_t convergence_duration;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>其中<code>pts</code>代表显示时间戳(单位是AVStream-&gt;time_base units)、<code>dts</code>代表解码时间戳(单位是AVStream-&gt;time_base units)、<code>stream_index</code>标识该<code>AVPacket</code>所属的视频音频流。</p>

]]></content>
  </entry>
  
</feed>
