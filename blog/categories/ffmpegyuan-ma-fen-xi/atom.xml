<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ffmpeg源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/ffmpegyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-11-20T00:06:43-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FFmpeg 学习之 FFplay 源码分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay/"/>
    <updated>2016-11-05T21:03:58-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay</id>
    <content type="html"><![CDATA[<p>FFplay 是一个简单便携的媒体播放器，它使用了 FFmpeg 和 SDL 库。<br />
<!--more--></p>

<h3 id="ffplay-">FFplay 的使用</h3>
<p>首先看一下 FFplay 的使用：安装完 FFmpeg 后，直接在命令行中输入 <br />
<code>
ffplay [options] bitstream_file
</code>
其中更详细的使用说明，可以使用<code>man ffplay</code>来查看。</p>

<p>其次我们可以通过使用<code>Esc</code><code>q</code>来推出播放，可以使用空格来暂停播放，可以使用<code>s</code>来执行逐帧播放视频等等操作。</p>

<h3 id="ffplay--1">FFplay 源码分析</h3>

<p>ffplay 里面最主要的函数时:<code>av_register_all()</code><code>SDL_Init(flags)</code><code>av_init_packet</code><code>stream_open</code><code>event_loop</code>。下面逐个分析这几个函数主要完成的功能。</p>

<h4 id="avregisterall">av_register_all()</h4>

<p><code>av_register_all</code>实现注册<code>codecs</code><code>demux</code>和<code>protocols</code>。其中注册的<code>codecs</code>时通过<code>avcodec_reigster_all()</code>函数来实现的；注册<code>demux</code>的方法，以 HEVC 为例。</p>

<p>{% codeblock lang:c %}
#define REGISTER_MUXER(X, x)                                            \
    {                                                                   \
        extern AVOutputFormat ff_##x##<em>muxer;                           \
        if (CONFIG</em>##X##<em>MUXER)                                         \
            av_register_output_format(&amp;ff</em>##x##_muxer);                 \
    }</p>

<h1 id="define-registerdemuxerx-x------------------------------------------">define REGISTER_DEMUXER(X, x)                                          \</h1>
<pre><code>{                                                                   \
    extern AVInputFormat ff_##x##_demuxer;                          \
    if (CONFIG_##X##_DEMUXER)                                       \
        av_register_input_format(&amp;ff_##x##_demuxer);                \
}
</code></pre>

<h1 id="define-registermuxdemuxx-x-registermuxerx-x-registerdemuxerx-x">define REGISTER_MUXDEMUX(X, x) REGISTER_MUXER(X, x); REGISTER_DEMUXER(X, x)</h1>

<p>REGISTER_MUXDEMUX(HEVC,hevc);
{% endcodeblock %}</p>

<p>将上面的宏展开即为：</p>

<p>{% codeblock lang:c %}
void av_register_input_format(AVInputFormat *format)
{
    AVInputFormat **p = last_iformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_iformat = &amp;format-&gt;next; }
</code></pre>

<p>void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = last_oformat;</p>

<pre><code>format-&gt;next = NULL;
while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))
    p = &amp;(*p)-&gt;next;
last_oformat = &amp;format-&gt;next; } {% endcodeblock %}
</code></pre>

<p>{% codeblock lang:c %}
AVOutputFormat ff_hevc_muxer = {
    .name              = “hevc”,
    .long_name         = NULL_IF_CONFIG_SMALL(“raw HEVC video”),
    .extensions        = “hevc”,
    .audio_codec       = AV_CODEC_ID_NONE,
    .video_codec       = AV_CODEC_ID_HEVC,
    .write_packet      = ff_raw_write_packet,
    .flags             = AVFMT_NOTIMESTAMPS,
};
{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVPacket 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avpacket-structure/"/>
    <updated>2016-07-03T08:19:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avpacket-structure</id>
    <content type="html"><![CDATA[<p>AVPacket是存储压缩编码数据相关信息的结构体。
<!--more--></p>

<p>{% codeblock lang:c %}</p>

<p>typedef struct AVPacket{</p>

<pre><code>AVBufferRef *buf;
int64_t pts;
int64_t dts;
uint8_t *data;
int   size;
int   stream_index;
int   flags;
AVPacketSideData *side_data;
int side_data_elems;
int   duration;
int64_t pos;                            ///&lt; byte position in stream, -1 if unknown
int64_t convergence_duration;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p>其中<code>pts</code>代表显示时间戳(单位是AVStream-&gt;time_base units)、<code>dts</code>代表解码时间戳(单位是AVStream-&gt;time_base units)、<code>stream_index</code>标识该<code>AVPacket</code>所属的视频音频流。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVStream 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avstream-structure/"/>
    <updated>2016-07-03T04:31:41-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avstream-structure</id>
    <content type="html"><![CDATA[<p>AVStream是存储每一个视频/音频流信息的结构体。
<!--more--></p>

<p>{% codeblock lang:c %}
typedef struct AVStream{</p>

<pre><code>int index;    	/* stream index in AVFormatContext */
int id;			/*  Format-specific stream ID */
AVCodecContext *codec;
void *priv_data;
AVRational time_base;
int64_t start_time;
int64_t duration;

int64_t nb_frames;                 ///&lt; number of frames in this stream if known or 0

int disposition; /**&lt; AV_DISPOSITION_* bit field */

enum AVDiscard discard; ///&lt; Selects which packets can be discarded at will and do not need to be demuxed.
AVRational sample_aspect_ratio;

AVDictionary *metadata;
AVRational avg_frame_rate;

AVPacket attached_pic;
AVPacketSideData *side_data;
int            nb_side_data;
int event_flags;
int pts_wrap_bits; /**&lt; number of bits in pts (used for wrapping control) */
int64_t first_dts;
int64_t cur_dts;
int64_t last_IP_pts;
int last_IP_duration;
int probe_packets;
int codec_info_nb_frames;

/* av_read_frame() support */
enum AVStreamParseType need_parsing;
struct AVCodecParserContext *parser;
struct AVPacketList *last_in_packet_buffer;
AVProbeData probe_data;
#define MAX_REORDER_DELAY 16
int64_t pts_buffer[MAX_REORDER_DELAY+1];

AVIndexEntry *index_entries; /**&lt; Only used if the format does not
                                support seeking natively. */
int nb_index_entries;
unsigned int index_entries_allocated_size;
AVRational r_frame_rate;
int stream_identifier;

int64_t interleaver_chunk_size;
int64_t interleaver_chunk_duration;
int request_probe;
int skip_to_keyframe;
int skip_samples;
int64_t start_skip_samples;
int64_t first_discard_sample;
int64_t last_discard_sample;
int nb_decoded_frames;
int64_t mux_ts_offset;
int64_t pts_wrap_reference;
int pts_wrap_behavior;
int update_initial_durations_done;
int64_t pts_reorder_error[MAX_REORDER_DELAY+1];
uint8_t pts_reorder_error_count[MAX_REORDER_DELAY+1];
int64_t last_dts_for_order_check;
uint8_t dts_ordered;
uint8_t dts_misordered;
int inject_global_side_data;
char *recommended_encoder_configuration;
AVRational display_aspect_ratio;

struct FFFrac *priv_pts;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVCodec 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avcodec-structure/"/>
    <updated>2016-07-03T01:11:57-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avcodec-structure</id>
    <content type="html"><![CDATA[<p>AVCodec是存储编解码器信息的结构体。
<!--more-->
{% codeblock lang:c %}
typedef struct AVCodec{</p>

<pre><code>const char *name;
const char *long_name;
enum AVMediaType type;
enum AVCodecID id;
int capabilities;
const AVRational *supported_framerates; ///&lt; array of supported framerates, or NULL if any, array is terminated by {0,0}
const enum AVPixelFormat *pix_fmts;     ///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1
const int *supported_samplerates;       ///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0
const enum AVSampleFormat *sample_fmts; ///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1
const uint64_t *channel_layouts;         ///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0
uint8_t max_lowres;                     ///&lt; maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()
const AVClass *priv_class;              ///&lt; AVClass for the private context
const AVProfile *profiles;              ///&lt; array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
int priv_data_size;
struct AVCodec *next;
int (*init_thread_copy)(AVCodecContext *);
int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);
const AVCodecDefault *defaults;
void (*init_static_data)(struct AVCodec *codec);

int (*init)(AVCodecContext *);
int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,
int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,
               int *got_packet_ptr);
int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);
int (*close)(AVCodecContext *);
void (*flush)(AVCodecContext *);
int caps_internal;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>以 HEVC 为例。</p>

<p>{% codeblock lang:c %}
AVCodec ff_hevc_decoder = {
    .name                  = “hevc”,
    .long_name             = NULL_IF_CONFIG_SMALL(“HEVC (High Efficiency Video Coding)”),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_HEVC,
    .priv_data_size        = sizeof(HEVCContext),
    .priv_class            = &amp;hevc_decoder_class,
    .init                  = hevc_decode_init,
    .close                 = hevc_decode_free,
    .decode                = hevc_decode_frame,
    .flush                 = hevc_decode_flush,
    .update_thread_context = hevc_update_thread_context,
    .init_thread_copy      = hevc_init_thread_copy,
    .capabilities          = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                             AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS,
    .profiles              = NULL_IF_CONFIG_SMALL(profiles),
};
{% endcodeblock %}</p>

<p>关于 AVCodec 的注册使用函数<code>avcodec_register_all</code>,该函数会调用<code>REGISTER_DECODER(HEVC, hevc);</code>, 其中的<code>REGISTER_DECODER</code>定义如下：
{% codeblock lang:c %}
#define REGISTER_DECODER(X, x)                                          \
    {                                                                   \
        extern AVCodec ff_##x##<em>decoder;                                \
        if (CONFIG</em>##X##<em>DECODER)                                       \
            avcodec_register(&amp;ff</em>##x##_decoder);                        \
    }
{% endcodeblock %}</p>

<p>其中的<code>avcodec_register</code>定义如下：</p>

<p>{% codeblock lang:c %}
av_cold void avcodec_register(AVCodec *codec)
{
    AVCodec **p;
    avcodec_init();
    p = last_avcodec;
    codec-&gt;next = NULL;</p>

<pre><code>while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, codec))
    p = &amp;(*p)-&gt;next;
last_avcodec = &amp;codec-&gt;next;

if (codec-&gt;init_static_data)
    codec-&gt;init_static_data(codec); } {% endcodeblock %}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVIOContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/02/aviocontext-structure/"/>
    <updated>2016-07-02T17:15:20-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/02/aviocontext-structure</id>
    <content type="html"><![CDATA[<p>AVIOContext 是FFMPEG管理输入输出数据的结构体。
<!--more--></p>

<p>{% codeblock lang:c %}</p>

<p>typedef struct AVIOContext{
    const AVClass <em>av_class;
    unsigned char *buffer;  /<strong>&lt; Start of the buffer. */
    int buffer_size;        /</strong>&lt; Maximum buffer size */
    unsigned char *buf_ptr; /<strong>&lt; Current position in the buffer */
    unsigned char *buf_end; /</strong>&lt; End of the data */
    int (</em>read_packet)(void <em>opaque, uint8_t *buf, int buf_size);
    int (</em>write_packet)(void <em>opaque, uint8_t *buf, int buf_size);
    int64_t (</em>seek)(void <em>opaque, int64_t offset, int whence);
    int64_t pos;            /<strong>&lt; position in the file of the current buffer */
    int must_flush;         /</strong>&lt; true if the next seek should flush */
    int eof_reached;        /<strong>&lt; true if eof reached */
    int write_flag;         /</strong>&lt; true if open for writing */
    int max_packet_size;
    unsigned long checksum;
    unsigned char *checksum_ptr;
    unsigned long (</em>update_checksum)(unsigned long checksum, const uint8_t <em>buf, unsigned int size);
    int error;              /**&lt; contains the error code or 0 if no error happened */
    int (</em>read_pause)(void <em>opaque, int pause);
    int64_t (</em>read_seek)(void *opaque, int stream_index,
                         int64_t timestamp, int flags);
    int seekable;
    int64_t maxsize;
    int direct;
    int64_t bytes_read;
    int seek_count;
    int writeout_count;
    int orig_buffer_size;
    int short_seek_threshold;
}</p>

<p>{% endcodeblock %}</p>

]]></content>
  </entry>
  
</feed>
