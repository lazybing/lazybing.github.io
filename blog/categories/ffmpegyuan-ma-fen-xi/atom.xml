<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:ffmpeg源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/ffmpegyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2021-07-21T05:41:03-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何从FFMpeg中提取CODEC(以TTA Decoder为例)]]></title>
    <link href="http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg/"/>
    <updated>2018-05-06T06:55:35-08:00</updated>
    <id>http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#tta-" id="markdown-toc-tta-">TTA 简介</a></li>
  <li><a href="#ffmpeg--tta-decoder" id="markdown-toc-ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</a></li>
  <li><a href="#tta-decoder-" id="markdown-toc-tta-decoder-">提取 TTA Decoder 中可能遇到的问题</a></li>
  <li><a href="#tta-decoder--1" id="markdown-toc-tta-decoder--1">提取 TTA Decoder 实现</a></li>
</ul>

<p><a href="https://ffmpeg.org/">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理。最近一直做得工作是从 FFMpeg 中提取特定的编解码器，本位以最简单的 TTA Decoder 为例，介绍如何同 FFMpeg 中提取 CODEC。</p>

<!--more-->

<h2 id="tta-">TTA 简介</h2>

<p>TTA(The True Audio Codec) 是免费、简单、实时无损视频压缩。基于 Adaptive Prognostic Filters, TTA 同其他同类的开源项目有强竞争力。</p>

<h2 id="ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</h2>

<p>FFMpeg 中关于 TTA Decoder 的部分在<code>libavcodec/tta.c</code>中定义:</p>

<p><code>
AVCodec ff_tta_decoder = {
    .name           = "tta",
    .long_name      = NULL_IF_CONFIG_SMALL("TTA (True Audio)"),
    .type           = AVMEDIA_TYPE_AUDIO,
    .id             = AV_CODEC_ID_TTA,
    .priv_data_size = sizeof(TTAContext),
    .init           = tta_decode_init,
    .close          = tta_decode_close,
    .decode         = tta_decode_frame,
    .init_thread_copy = ONLY_IF_THREADS_ENABLED(init_thread_copy),
    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
    .priv_class       = &amp;tta_decoder_class,
};
</code></p>

<p>从 TTA AVCodec 的定义可以看出，Decoder 的主要函数只有三个<code>tta_decode_init</code>、<code>tta_decode_frame</code>、<code>tta_decode_close</code>三部分。其中 init 部分主要是解析 TTA Header 信息，decode 部分是真正解码部分，close 主要是释放内存。</p>

<p>不管是硬件解码还是软件解码，Decoder 部分一般都包含六部分：解码器初始化、解码器释放、设置压缩数据给解码器、从解码器获取解码后的数据、设置参数给解码器、从解码器获取参数信息。因此我们可以按照上面的思路，将 FFMpeg 中的这几个函数拆分成相应的函数。</p>

<h2 id="tta-decoder-">提取 TTA Decoder 中可能遇到的问题</h2>

<h2 id="tta-decoder--1">提取 TTA Decoder 实现</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMpeg 实现视频编码、解码、封装、解封装、转码、缩放]]></title>
    <link href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/"/>
    <updated>2017-01-01T08:17:10-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ffmpeg-" id="markdown-toc-ffmpeg-">FFMpeg 编码实现</a></li>
  <li><a href="#ffmpeg--1" id="markdown-toc-ffmpeg--1">FFMpeg 解码实现</a></li>
  <li><a href="#ffmpeg--2" id="markdown-toc-ffmpeg--2">FFMpeg 封装实现</a></li>
  <li><a href="#ffmpeg--3" id="markdown-toc-ffmpeg--3">FFMpeg 解封装实现</a></li>
  <li><a href="#ffmpeg--4" id="markdown-toc-ffmpeg--4">FFMpeg 转码的实现</a></li>
  <li><a href="#ffmpeg--5" id="markdown-toc-ffmpeg--5">FFMpeg 视频缩放实现</a></li>
</ul>

<p><a href="https://ffmpeg.org/">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理，本文主要利用 FFMpeg 官方提供的 SDK 实现音视频最简单的几个实例：编码、解码、封装、解封装、转码、缩放以及添加水印。</p>

<!--more-->
<p>接下来会由发现问题－＞分析问题－＞解决问题－＞实现方案，循序渐进的完成。</p>

<p>参考代码:<a href="https://github.com/lazybing/ffmpeg-study-recording">ffmpeg_sdk</a></p>

<h2 id="ffmpeg-">FFMpeg 编码实现</h2>

<p>本例子实现的是将视频域 YUV 数据编码为压缩域的帧数据，编码格式包含了 H.264/H.265/MPEG1/MPEG2 四种 CODEC 类型。
实现的过程，可以大致用如下图表示:</p>

<p><img src="/images/ffmpeg_sdk/encoder.png"></p>

<p>从图中可以大致看出视频编码的流程:</p>

<ul>
  <li>首先要有未压缩的 YUV 原始数据。</li>
  <li>其次要根据想要编码的格式选择特定的编码器。</li>
  <li>最后编码器的输出即为编码后的视频帧。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>存放待压缩的 YUV 原始数据。此时可以利用 FFMpeg 提供的 AVFrame 结构体，并根据 YUV 数据来填充 AVFrame　结构的视频宽高、像素格式；根据视频宽高、像素格式可以分配存放数据的内存大小，以及字节对齐情况。</li>
  <li>获取编码器。利用想要压缩的格式，比如　H.264/H.265/MPEG1/MPEG2 等，来获取注册的编解码器，编解码器在 FFMpeg 中用 AVCodec 结构体表示，对于编解码器，肯定要对其进行配置，包括待压缩视频的宽高、像素格式、比特率等等信息，这些信息，FFMpeg 提供了一个专门的结构体 AVCodecContext 结构体。</li>
  <li>存放编码后压缩域的视频帧。FFMpeg 中用来存放压缩编码数据相关信息的结构体为 AVPacket。最后将 AVPacket 存储的压缩数据写入文件即可。</li>
</ul>

<hr />

<p>AVFrame 结构体的分配使用<code>av_frame_alloc()</code>函数，该函数会对 AVFrame 结构体的某些字段设置默认值，它会返回一个指向 AVFrame 的指针或 NULL指针(失败)。AVFrame 结构体的释放只能通过<code>av_frame_free()</code>来完成。注意，该函数只能分配 AVFrame 结构体本身，不能分配它的 data buffers 字段指向的内容，该字段的指向要根据视频的宽高、像素格式信息手动分配，本例使用的是<code>av_image_alloc()</code>函数。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//allocate AVFrame struct</span>
</span><span class='line'><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Frame</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//fill AVFrame struct fields</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
</span><span class='line'><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">AV_PIX_FMT_YUV420P</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//allocate AVFrame data buffers field point</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">linesize</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//write input file data to frame-&amp;gt;data buffer</span>
</span><span class='line'><span class="n">fread</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="o">*</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="n">av_frame_free</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<hr />

<p>编解码器相关的 AVCodec 结构体的分配使用<code>avcodec_find_encoder(enum AVCodecID id)</code>完成，该函数的作用是找到一个与 AVCodecID 匹配的已注册过得编码器；成功则返回一个指向 AVCodec ID 的指针，失败返回 NULL 指针。该函数的作用是确定系统中是否有该编码器，只是能够使用编码器进行特定格式编码的最基本的条件，要想使用它，至少要完成两个步骤：</p>

<ol>
  <li>根据特定的视频数据，对该编码器进行特定的配置；</li>
  <li>打开该编码器。</li>
</ol>

<p>针对第一步中关于编解码器的特定参数，FFMpeg 提供了一个专门用来存放 AVCodec 所需要的配置参数的结构体 AVCodecContext 结构。它的分配使用<code>avcodec_alloc_context3(const AVCodec *codec)</code>完成，该函数根据特定的 CODEC 分配一个 AVCodecContext 结构体，并设置一些字段为默认参数，成功则返回指向 AVCodecContext 结构体的指针，失败则返回 NULL 指针。分配完成后，根据视频特性，手动指定与编码器相关的一些参数，比如视频宽高、像素格式、比特率、GOP 大小等。最后根据参数信息，打开找到的编码器，此处使用<code>avcodec_open2()</code>函数完成。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//register all encoder and decoder</span>
</span><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//find the encoder</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_encoder</span><span class="p">(</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">Not</span> <span class="n">Find</span> <span class="n">the</span> <span class="n">Encoder</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//allocate the AVCodecContext and fill it’s fields</span>
</span><span class='line'><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecCtx</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="mi">4000000</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span>    <span class="o">=</span> <span class="n">frameWidth</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span>   <span class="o">=</span> <span class="n">frameHeight</span><span class="p">;</span>
</span><span class='line'><span class="n">codecCtx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">time_base</span><span class="o">=</span> <span class="p">(</span><span class="n">AVRational</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//open the encoder</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Encoder</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<hr />

<p>存放编码数据的结构体为 AVPacket，使用之前要对该结构体进行初始化，初始化函数为<code>av_init_packet(AVPacket *pkt)</code>，该函数会初始化 AVPacket 结构体中一些字段为默认值，但它不会设置其中的 data 和 size 字段，需要单独初始化,如果此处将 data 设为 NULL、size 设为 0，编码器会自动填充这两个字段。</p>

<p>有了存放编码数据的结构体后，我们就可以利用编码器进行编码了。FFMpeg 提供的用于视频编码的函数为<code>avcodec_encode_video2</code>,它作用是编码一帧视频数据，该函数比较复杂，单独列出如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avcodec_encode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">,</span>
</span><span class='line'>                          <span class="k">const</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_packet_ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>它会接收来自 AVFrame-&gt;data 的视频数据，并将编码数据放到 AVPacket-&gt;data 指向的位置，编码数据大小为 AVPacket-&gt;size。</p>

<p>其参数和返回值的意义：</p>

<ul>
  <li>avctx: AVCodecContext 结构，指定了编码的一些参数；</li>
  <li>avPkt: AVPacket对象的指针，用于保存输出的码流；</li>
  <li>frame：AVFrame结构，用于传入原始的像素数据；</li>
  <li>got_packet_ptr:输出参数，用于标识是否已经有了完整的一帧；</li>
  <li>返回值：编码成功返回 0， 失败返回负的错误码；</li>
</ul>

<p>编码完成后就可将AVPacket-&gt;data内的编码数据写到输出文件中；代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//init AVPacket</span>
</span><span class='line'><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//encode the image</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_encode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">got_output</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Encode</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="err">｝</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">got_output</span><span class="p">){</span>
</span><span class='line'>	<span class="n">fwrite</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>编码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/encoder.c">编码实现</a>。</p>

<h2 id="ffmpeg--1">FFMpeg 解码实现</h2>

<p>解码实现的是将压缩域的视频数据解码为像素域的 YUV 数据。实现的过程，可以大致用如下图所示。</p>

<p><img src="/images/ffmpeg_sdk/decoder.png"></p>

<p>从图中可以看出，大致可以分为下面三个步骤：</p>

<ul>
  <li>首先要有待解码的压缩域的视频。</li>
  <li>其次根据压缩域的压缩格式获得解码器。</li>
  <li>最后解码器的输出即为像素域的 YUV 数据。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>关于输入数据。首先，要分配一块内存，用于存放压缩域的视频数据；之后，对内存中的数据进行预处理，使其分为一个一个的 AVPacket 结构（AVPacket 结构的简单介绍如上面的编码实现）。最后，将 AVPacket 结构中的 data 数据给到解码器。</li>
  <li>关于解码器。首先，利用 CODEC_ID 来获取注册的解码器；之后，将预处理过得视频数据给到解码器进行解码。</li>
  <li>关于输出。FFMpeg 中，解码后的数据存放在 AVFrame 中；之后就将 AVFrame 中的 data 字段的数据存放到输出文件中。</li>
</ul>

<hr />

<p>对于输入数据，首先，通过 fread 函数实现将固定长度的输入文件的数据存放到一块 buffer 内。H.264中一个包的长度是不定的，读取固定长度的码流通常不可能刚好读出一个包的长度；对此，FFMpeg 提供了一个 AVCoderParserContext 结构用于解析读到 buffer 内的码流信息，直到能够取出一个完整的 H.264 包。为此，FFMpeg 提供的函数为<code>av_parser_parse2</code>，该函数比较复杂，定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">poutbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">poutbuf_size</span><span class="p">,</span>
</span><span class='line'>                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_size</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">int64_t</span> <span class="n">pts</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dts</span><span class="p">,</span>
</span><span class='line'>                     <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>函数的参数和返回值含义如下：</p>

<ul>
  <li>AVCodecParserContext *s:初始化过的 AVCodecParserContext 对象，决定了码流该以怎样的标准进行解析；</li>
  <li>AVCodecContext *avctx：预先定义好的 AVCodecContext 对象；</li>
  <li>uint8_t **poutbuf：AVPacket：：data 的地址，保存解析完成的包数据。</li>
  <li>int *poutbuf_size：AVPacket 的实际数据长度，如果没有解析出完整的一个包，该值为 0；</li>
  <li>const uint8_t *but:待解码的码流的地址；</li>
  <li>int buf_size:待解码的码流的长度；</li>
  <li>int64_t pts, int64_t dts:显示和解码的时间戳；</li>
  <li>int64_t pos:码流中的位置；</li>
  <li>返回值为解析所使用的比特位的长度；</li>
</ul>

<p>FFMpeg 中为我们提供的该函数常用的使用方式为：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">in_len</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">myparser</span><span class="p">.</span> <span class="n">AVCodecContext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">size</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">in</span> <span class="n">len</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">dts</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">in_data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'><span class="n">in_len</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>	<span class="n">decode_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。</p>

<p>因此，关于输入数据的处理，代码大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//open input file</span>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="n">pInput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Input_FileName</span><span class="p">,</span> <span class="err">“</span><span class="n">rb</span><span class="o">+</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInput_File</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Input</span> <span class="n">File</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class='line'><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class='line'>							<span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class='line'>							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class='line'>	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="n">decode_frame</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>注意，上面提到的<code>av_parser_parse2</code>函数用的几个参数，其实是与具体的编码格式有关的，它们应该在之前已经分配好了，我们只是放到后面来讲一下，因为它们是与具体的解码器强相关的。</p>

<hr />

<p>对于解码器。与上面提到的编码实现类似，首先，根据 CODEC_ID 找到注册的解码器 AVCodec，FFMpeg 为此提供的函数为<code>avcodec_find_decoder()</code>；其次，根据找到的解码器获取与之相关的解码器上下文结构体 AVCodecC，使用的函数为编码中提到的<code>avcodec_alloc_context3</code>；再者，如上面提到的要获取完整的一个 NALU，解码器需要分配一个 AVCodecParserContext 结构，使用函数<code>av_parser_init</code>；最后，前面的准备工作完成后，打开解码器，即可调用 FFMpeg 提供的解码函数<code>avcodec_decode_video2</code>对输入的压缩域的码流进行解码，并将解码数据存放到 AVFrame-&gt;data 中。代码实现大致如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//register all encoder and decoder</span>
</span><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate AVFrame to Store the Decode Data</span>
</span><span class='line'><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">Frame</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Find the  AVCodec Depending on the CODEC_ID</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Find</span> <span class="n">the</span> <span class="n">Decoder</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate the AVCodecContext </span>
</span><span class='line'><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecCtx</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Allocate the AVCodecParserContext </span>
</span><span class='line'><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="n">av_parser_init</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pCodecParserCtx</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Alloc</span> <span class="n">AVCodecParserContext</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Open the Decoder</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">Open</span> <span class="n">the</span> <span class="n">Decoder</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class='line'><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class='line'>							<span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class='line'>							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class='line'>							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class='line'>	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'><span class="c1">//decode start</span>
</span><span class='line'><span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">got_frame</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>注意，上面解码的过程中，针对具体的实现，可能要做一些具体参数上的调整，此处只是理清解码的流程。</p>

<hr />

<p>对于输出数据。解码完成后，解码出来的像素域的数据存放在 AVFrame 的 data 字段内，只需要将该字段内存放的数据之间写文件到输出文件即可。解码函数<code>avcodec_decode_video2</code>函数完成整个解码过程，对于它简单介绍如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class='line'>                         <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>                         <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>该函数各个参数的意义：</p>

<ul>
  <li>AVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成；</li>
  <li>AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好；</li>
  <li>int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了;</li>
  <li>const AVPacket *avpkt: 前面解析好的码流包；</li>
</ul>

<p>由此可见，当标识位为1时，代表解码一帧结束，可以写数据到文件中。代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">pOutput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Output_FileName</span><span class="p">,</span> <span class="err">“</span><span class="n">wb</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pOutput_File</span><span class="p">){</span>
</span><span class='line'>	<span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Open</span> <span class="n">Output</span> <span class="n">File</span> <span class="n">Fail</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">){</span>
</span><span class='line'>	<span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span> <span class="n">Len</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>解码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/decoder.c">解码实现</a>。</p>

<h2 id="ffmpeg--2">FFMpeg 封装实现</h2>

<p>本例子实现的是将视频数据和音频数据，按照一定的格式封装为特定的容器，比如FLV、MKV、MP4、AVI等等。实现的过程，可以大致用如下图表示：</p>

<p><img src="/images/ffmpeg_sdk/muxer.png"></p>

<p>从图中可以大致看出视频封装的流程：</p>

<ul>
  <li>首先要有编码好的视频、音频数据。</li>
  <li>其次要根据想要封装的格式选择特定的封装器。</li>
  <li>最后利用封装器进行封装。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>利用给定的YUV数据编码得到某种 CODEC 格式的编码视频（可以参见上面提到的<a href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/#ffmpeg-">编码实现</a>），同样的方法得到音频数据。</li>
  <li>获取输出文件格式。获取输出文件格式可以直接指定文件格式，比如FLV/MKV/MP4/AVI等，也可以通过输出文件的后缀名来确定，或者也可以选择默认的输出格式。根据得到的文件格式，其中可能有视频、音频等，为此我们需要为格式添加视频、音频、并对格式中的一些信息进行设置（比如头）。</li>
  <li>利用设置好的音频、视频、头信息等，开始封装。</li>
</ul>

<hr />

<p>对于由 YUV 数据得到编码的视频数据部分，不再重复。直接看与 Muxer 相关的部分，与特定的 Muxer 相关的信息，FFMpeg 提供了一个 AVFormatContext 的结构体描述，并用<code>avformat_alloc_output_context2()</code>函数来分配它。该函数的声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">avformat_alloc_output_context2</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">oformat</span><span class="p">,</span>
</span><span class='line'>                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中：</p>

<ul>
  <li>ctx:输出到 AVFormatContext 结构的指针，如果函数失败则返回给该指针为 NULL。</li>
  <li>oformat：指定输出的 AVOutputFormat 类型，如果设为 NULL，则根据 format_name 和 filename 生成。</li>
  <li>format_name:输出格式的名称，如果设为 NULL，则使用 filename 默认格式。</li>
  <li>filename：目标文件名，如果不使用，可以设为 NULL。</li>
  <li>返回值：&gt;=0 则成功，否则失败。</li>
</ul>

<p>代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
</span><span class='line'><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="cm">/* allocate the output media context */</span>
</span><span class='line'><span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">deduce</span> <span class="n">output</span> <span class="n">format</span> <span class="n">from</span> <span class="n">file</span> <span class="nl">extension</span><span class="p">:</span> <span class="n">using</span> <span class="n">MPEG</span><span class="p">.</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="err">“</span><span class="n">mpeg</span><span class="err">”</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">oformat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>有了表示媒体文件格式的 AVFormatContext 结构后，就需要根据媒体格式来判断是否需要往媒体文件中添加视频流、音频流（有的媒体文件，这两种流并不是必须的）；以 MP4 格式的媒体文件为例，我们需要一路视频流、一路音频流。因此需要创建一路流，FFMpeg 提供的创建流的函数为<code>avformat_new_stream()</code>，该函数完成向 AVFormatContext 结构体中所代码的媒体文件中添加数据流，函数声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVStream</span> <span class="o">*</span><span class="nf">avformat_new_stream</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中：</p>

<ul>
  <li>s:AVFormatContext 结构，表示要封装生成的视频文件。</li>
  <li>c：视频或音频流的编码器的指针。</li>
  <li>返回值：指向生成的 stream 对象的指针；失败则返回 NULL。</li>
</ul>

<p>注意：对于 Muxer，该函数必须在调用<code>avformat_write_header()</code>前调用。使用完成后，需要调用<code>avcodec_close()</code>和<code>avformat_free_context()</code>来清理由它分配的内容。</p>

<p>该函数调用完成后，一个新的 AVStream 便已经加入到输出文件中，下面就需要设置 stream 的 id 和 codec 等参数。以视频流为例，代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">OutputStream</span> <span class="o">*</span><span class="n">ost</span><span class="p">;</span>
</span><span class='line'><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodec</span> <span class="o">**</span><span class="n">codec</span><span class="p">;</span>
</span><span class='line'><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="n">AVStream</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">st</span> <span class="o">=</span> <span class="n">avformat_new_stream</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">allocate</span> <span class="n">stream</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">st</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">id</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">nb_streams</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>参数设置完成后，就可以打开编码器并为编码器分配必要的内存。步骤跟之前的类似，以视频为例，示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//open the codec</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">opt</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">open</span> <span class="n">video</span> <span class="nl">codec</span><span class="p">:</span> <span class="o">%</span><span class="n">s</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//allocate and init a re-usable frame</span>
</span><span class='line'><span class="n">ost</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">alloc_picture</span><span class="p">(</span><span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>接下来进行真正的封装：首先，为媒体文件添加头部信息,FFMpeg 为此提供的函数为<code>avformat_write_header()</code>。其次，将编码好的音视频 AVPacket 包添加到媒体文件中去，FFMpeg 为此提供的函数为<code>av_interleaved_write_frame()</code>。最后，写入文件尾的数据，FFMpeg 为此提供的函数为<code>av_write_trailer()</code>。</p>

<p>封装的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/muxer.c">封装实现</a>。</p>

<h2 id="ffmpeg--3">FFMpeg 解封装实现</h2>

<p>本例子实现的是将音视频分离，例如将封装格式为 FLV、MKV、MP4、AVI 等封装格式的文件，将音频、视频分离开来。
实现的过程，可以大致用如下图表示：</p>

<p><img src="/images/ffmpeg_sdk/demuxer.png"></p>

<p>从图中可以看出大致的节封装流程：</p>

<ul>
  <li>首先要对解复用器进行初始化。</li>
  <li>其次将输入的封装格式文件给到解复用器内。</li>
  <li>最后利用解封装对 Container 进行解封装。</li>
</ul>

<p>根据流程可以推到出大致的代码流程：</p>

<ul>
  <li>首先对输入文件(Container 文件)、输出文件(Video/Audio 进行处理)，方便后面的使用；</li>
  <li>其次打开输入文件，并分配 Format Context，从输入文件中得到流信息</li>
  <li>之后打开视频、音频编码器 Context,针对视频数据，分配图像 image。</li>
  <li>分配 frame 结构，初始化 packet，从输入文件中读取 frame 信息，并之后进行解码 packet。</li>
  <li>最后释放各种分配的数据信息。</li>
</ul>

<hr />

<p>在音视频分离后，需要将分离出的音视频分别放到不同的输出文件中，为此，需要打开文件以备后用。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">video_dst_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">audio_dst_filename</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">video_dst_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">audio_dst_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">video_dst_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="n">audio_dst_filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'><span class="n">video_dst_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">video_dst_filename</span><span class="p">,</span> <span class="err">“</span><span class="n">wb</span><span class="o">+</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'><span class="n">audio_dst_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">audio_dst_filename</span><span class="p">,</span> <span class="err">“</span><span class="n">wb</span><span class="o">+</span><span class="err">”</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>对于给定的需要 AV 分离的输入文件，使用<code>avformat_open_input</code>打开输入文件，并分配<code>AVFormatContext</code>结构。该函数的声明如下：</p>

<p><code>
int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options);
</code>
其中：</p>

<ul>
  <li>ps:指向由用户提供的<code>AVFormatContext</code>结构体，该结构体通过<code>avformat_alloc_context</code>分配，如果它是一个 NULL，该结构在此函数内分配并负值给 ps。</li>
  <li>filename:指向需要打开的流的名称。</li>
  <li>fmt：如果是 non-NULL,该参数指定输入的文件格式，否则输入文件的格式自动根据文件本身自动获取。</li>
  <li>options:此处可以为 NULL。</li>
  <li>返回值：成功返回0，否则返回 AVERROR。</li>
</ul>

<p>实现代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//open input file, and allocate format context</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">src_filename</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">open</span> <span class="n">source</span> <span class="n">file</span> <span class="o">%</span><span class="n">s</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">,</span> <span class="n">src_filename</span><span class="p">);</span> <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//retrive stream information</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">find</span> <span class="n">stream</span> <span class="n">information</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>通过输入文件分配好<code>AVFormatContext</code>后，需要找到里面的音频流和视频流，此处需要用到的函数为<code>av_find_best_stream</code>;
之后要根据找到的不同的流(如H264流、HEVC流等)找到特定的编解码器，此处使用<code>avcodec_find_decoder</code>;找到了解码器后，
就需要打开解码器，此处使用<code>avcodec_open2</code>函数完成。下面分别介绍这几个函数的使用：</p>

<p><code>av_find_best_stream</code>函数定义如下：</p>

<p><code>
int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec **decoder_ret, int flags);
</code>
其中：</p>

<ul>
  <li>ic:媒体文件句柄。</li>
  <li>type:媒体类型，视频、音频、文本等。</li>
  <li>wanted_stream_nb:用户请求的流，-1 代表自动选择。</li>
  <li>related_stream:尝试找到相关流，如果没有就设为-1。</li>
  <li>decoder_ret:如果是non-NULL,返回选定的流的解码器。</li>
  <li>flags：此处定位0。</li>
  <li>返回值：成功返回非负值，如果找不到指定的请求类型的流，就返回<code>AVERROR_STREAM_NOT_FOUND</code>;如果找到了流，但没找到对应的解码器，就返回<code>AVERROR_DECODER_NOT_FOUND</code>。</li>
</ul>

<p><code>avcodec_find_decoder</code>函数定义如下：</p>

<p><code>
AVCodec *avcodec_find_decoder(enum AVCodecID id);
</code></p>

<p>该函数参数为<code>AVCodecID</code>指定了请求的解码器，成功返回解码器，否则返回 NULL。</p>

<p><code>avcodec_open2</code>函数定义如下：</p>

<p><code>
int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);
</code></p>

<p>其中：</p>

<ul>
  <li>avctx:即将初始化的<code>AVCodecContext</code>结构体。</li>
  <li>codec：打开的解码器，如果它是non-NULL codec,并在之前传递给了<code>avcodec_alloc_context3</code>或<code>avcodec_get_context_defaults3</code>，该参数必须为 NULL 或之前传递的 CODEC。</li>
  <li>Options：此处我们设置为 NULL。</li>
  <li>返回值：成功返回0，出错返回一个负值。</li>
</ul>

<p>该函数的主要作用是根据给定的<code>AVCodec</code>初始化<code>AVCodecContext</code>,在使用该函数之前，待初始化的<code>AVCodecContext</code>结构需要先使用<code>avcodec_alloc_context3</code>分配好。其中的参数
<code>AVCodec</code>可以通过<code>avcodec_find_decoder_by_name</code><code>avcodec_find_encoder_by_name</code><code>avcodec_find_decoder</code>或<code>avcodec_find_endcoder</code>来获取。在进行真正的解码之前，必须调用该函数。
下面给出使用的示例：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class='line'><span class="n">av_dict_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">opts</span><span class="p">,</span> <span class="err">“</span><span class="n">b</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="mf">2.5</span><span class="n">M</span><span class="err">”</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>对于上面分析的部分，我们将其封装在一个函数里，代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">open_codec_context</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">stream_idx</span><span class="p">,</span>
</span><span class='line'>                              <span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">fmt_ctx</span><span class="p">,</span>
</span><span class='line'>                              <span class="k">enum</span> <span class="n">AVMediaType</span> <span class="n">type</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">stream_index</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AVStream</span> <span class="o">*</span><span class="n">pStream</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codec_ctx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">av_find_best_stream</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not find %s stream in input file &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">),</span> <span class="n">src_filename</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="n">stream_index</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pStream</span> <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">streams</span><span class="p">[</span><span class="n">stream_index</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//find decoder for the stream</span>
</span><span class='line'>    <span class="n">codec_ctx</span> <span class="o">=</span> <span class="n">pStream</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">;</span>
</span><span class='line'>    <span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">codec_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to find %s codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//open the decoder</span>
</span><span class='line'>    <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Failed to open %s codec</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">av_get_media_type_string</span><span class="p">(</span><span class="n">type</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">*</span><span class="n">stream_idx</span> <span class="o">=</span> <span class="n">stream_index</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>针对音频、视频，分别调用该函数，示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">open_codec_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">video_stream_idx</span><span class="p">,</span> <span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>        <span class="n">video_stream</span>    <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">streams</span><span class="p">[</span><span class="n">video_stream_idx</span><span class="p">];</span>
</span><span class='line'>        <span class="n">video_codec_ctx</span> <span class="o">=</span> <span class="n">video_stream</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="c1">//allocate image where the decoded image will be put</span>
</span><span class='line'>    <span class="n">width</span>   <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>    <span class="n">height</span>  <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">video_codec_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">;</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">,</span> <span class="n">video_dst_linesize</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not allocate raw video buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">video_dst_bufsize</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">open_codec_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">audio_stream_idx</span><span class="p">,</span> <span class="n">fmt_ctx</span><span class="p">,</span> <span class="n">AVMEDIA_TYPE_AUDIO</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">audio_stream</span> <span class="o">=</span> <span class="n">fmt_ctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">streams</span><span class="p">[</span><span class="n">audio_stream_idx</span><span class="p">];</span>
</span><span class='line'>    <span class="n">audio_codec_ctx</span> <span class="o">=</span> <span class="n">audio_stream</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>上面的一些准备工作完成后，就需要从输入文件中一帧一帧读取数据，并进行解码了。从这里可以看出，需要找到一个
一帧视频存放的地方，为此需要使用<code>av_init_packet</code>初始化一个<code>AVPacket</code>。之后就可以使用<code>av_read_frame</code>来从输入
文件中读取一个 frame。示例代码如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_packet</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">got_frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cached</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="o">*</span><span class="n">got_frame</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">video_stream_idx</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">//decode video frame</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">video_codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">got_frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error decoding video frame (%s) </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;num %d got_frame %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="o">++</span><span class="p">,</span> <span class="o">*</span><span class="n">got_frame</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_frame</span><span class="p">){</span>
</span><span class='line'>        <span class="n">av_image_copy</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">,</span> <span class="n">video_dst_linesize</span><span class="p">,</span>
</span><span class='line'>                      <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">**</span><span class="p">)(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">),</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">linesize</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">pix_fmt</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//write to raw video file</span>
</span><span class='line'>        <span class="n">fwrite</span><span class="p">(</span><span class="n">video_dst_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">video_dst_bufsize</span><span class="p">,</span> <span class="n">video_dst_file</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">stream_index</span> <span class="o">==</span> <span class="n">audio_stream_idx</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">//decode audio frame</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_decode_audio4</span><span class="p">(</span><span class="n">audio_codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">got_frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error decoding audio frame (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_frame</span><span class="p">){</span>
</span><span class='line'>        <span class="kt">size_t</span> <span class="n">unpadded_linesize</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">nb_samples</span> <span class="o">*</span> <span class="n">av_get_bytes_per_sample</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">format</span><span class="p">);</span>
</span><span class='line'>        <span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">extended_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">unpadded_linesize</span><span class="p">,</span> <span class="n">audio_dst_file</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">FFMIN</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//allocate frame </span>
</span><span class='line'><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="err">“</span><span class="n">Could</span> <span class="n">not</span> <span class="n">allocate</span> <span class="n">frame</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//read frames from the file</span>
</span><span class='line'><span class="kt">int</span> <span class="n">got_frame</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">av_read_frame</span><span class="p">(</span><span class="n">fmt_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">pkt</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">AVPacket</span> <span class="n">orig_pkt</span> <span class="o">=</span> <span class="n">pkt</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">do</span><span class="p">{</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">decode_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">got_frame</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">av_free_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">orig_pkt</span><span class="p">);</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>解封装大致流程已经完成了，剩余的是一些收尾工作，例如释放刚刚分配的内存等。</p>

<p>完整实现过程请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/demuxer.c">解封在实现</a>.</p>

<h2 id="ffmpeg--4">FFMpeg 转码的实现</h2>

<h2 id="ffmpeg--5">FFMpeg 视频缩放实现</h2>

<p>针对视频的缩放，FFMpeg 提供了 libswscale 库，可以轻松实现视频的分辨率转换功能。除此之外，libswscale 库还可以
实现颜色空间转换的功能。</p>

<p>FFMpeg 中针对视频的缩放提供了一个示例代码，位于<code>doc\examples\scaling_video.c</code>中。分析该程序的流程大致分为如下几部分：</p>

<ol>
  <li>解析命令行参数，获取缩放的视频宽高，视频文件名。</li>
  <li>创建<code>SwsContext</code>结构体。</li>
  <li>分配源图像和目标图像的内存。</li>
  <li>将源图像进行转换为目标图像的大小。</li>
  <li>将缩放的图像写到输出文件中。</li>
  <li>收尾工作，释放分配的内存，关闭打开的文件。</li>
</ol>

<p>首先解析期望的视频宽高，示例代码中使用的是<code>av_parse_video_size</code>函数，该函数的声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">av_parse_video_size</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">width_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">height_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>解析 str，并将解析出来的宽高信息赋值给 width_ptr, height_ptr;其中：</p>

<ul>
  <li>str：待解析的字符串，可以是格式为<code>widthxheight</code>的字符串，或者是一个合法的视频大小描述。</li>
  <li>width_ptr,height_ptr,指向检测到的宽高变量的指针。</li>
  <li>返回值，成功返回大于0，失败返回负值。</li>
</ul>

<p>之后，创建<code>SwsContext</code>结构体，示例代码中使用的是<code>sws_getContext</code>函数，该函数声明如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">SwsContext</span> <span class="o">*</span><span class="nf">sws_getContext</span><span class="p">(</span><span class="kt">int</span> <span class="n">srcW</span><span class="p">,</span> <span class="kt">int</span> <span class="n">srcH</span><span class="p">,</span> <span class="k">enum</span> <span class="n">AVPixelFormat</span> <span class="n">srcFormat</span><span class="p">,</span>
</span><span class='line'>                                  <span class="kt">int</span> <span class="n">dstW</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstH</span><span class="p">,</span> <span class="k">enum</span> <span class="n">AVPixelFormat</span> <span class="n">dstFormat</span><span class="p">,</span>
</span><span class='line'>                                  <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">SwsFilter</span> <span class="o">*</span><span class="n">srcFilter</span><span class="p">,</span>
</span><span class='line'>                                  <span class="n">SwsFilter</span> <span class="o">*</span><span class="n">dstFilter</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>该函数的作用是分配并返回一个<code>SwsContext</code>结构，后面如果需要实现缩放/转换操作时，需要使用<code>sws_scale</code>函数。其中：</p>

<ul>
  <li>srcW:源图像的宽</li>
  <li>srcH:源图像的高</li>
  <li>srcFormat:源图像的格式</li>
  <li>dstW:目标图像的宽</li>
  <li>dstH:目标图像的高</li>
  <li>dstFormat:目标图像的格式</li>
  <li>flags:指定了使用何种算法和选项进行缩放</li>
</ul>

<p>编译时用<code>make examples</code>后生成 scaling_video 可执行文件。命令行如下：</p>

<p><code>
$ /scaling_video 001_bit_rv8_64P_352x288.yuv hd1080
</code>
注意，输入时 YUV 数据，输出时 RGB 数据，会根据后面的 size 生成不同分辨率的数据。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avformat_find_stream_info]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info/"/>
    <updated>2016-12-25T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">调用关系</a></li>
</ul>

<p><code>avformat_find_stream_info</code>主要是读媒体文件的包(packets)，然后从中提取出流的信息。
对于没有头部信息的文件格式尤其有用，比如<code>MPEG</code>。文件的逻辑位置不会被改变，读取出来
的包会被缓存起来供以后处理。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);
</code>
返回值：&gt;=0–&gt;OK,或出错返回AVERROR_xxx</p>

<p>注意，该函数并不保证能够打开所有的 codec，因此将options 设置为非NULL用于返回一些信息是非常好的行为。</p>

<h2 id="section-1">调用关系</h2>

<p><img src="http://lazybing.github.io/images/avformat_find_stream_info/avformat_find_stream_info.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_decode_video2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video/"/>
    <updated>2016-12-20T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a></li>
</ul>

<p><code>avcodec_decode_video</code>函数的作用是解码<code>AVPacket</code>中的压缩数据，解码为图像数据。
某些解码器支持在一个<code>AVPacket</code>中包含多帧，这类的解码器只解码第一帧。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                         int *got_picture_ptr,
                         const AVPacket *avpkt);
</code></p>

<p>注意，输入内存的对齐字节(AV_INPUT_BUFFER_PADDING_SIZE)比实际读取字节要大，因为某些
最优流可能会读取 32 或 64 bits 每次。</p>

<p>在将压缩数据packets给到解码器之前，<code>AVCodecContext</code>必须用<code>avcodec_open2</code>设置过。</p>

<p>函数参数：</p>

<ul>
  <li><code>AVCodecContext *</code>。</li>
  <li><code>AVFrame *</code>存放解码的视频数据，它使用<code>av_frame_alloc</code>获得一个<code>AVFrame</code>。解码器会调用
<code>AVCodecContext.get_buffer2</code>回调函数为实际的位图分配内存。</li>
  <li><code>got_picture_ptr</code>,如果没有帧可以解码，该值被设为0。否则，它是非零值。</li>
  <li><code>AVPacket *</code>包含输入缓存。该结构体使用<code>av_init_packet</code>创建后会设置<code>data</code>和<code>size</code>，某些
解码器可能需要更多的字段,如<code>flags &amp; AV_PKT_FLAG_KEY</code>。解码器被设置为使用最少的字段。</li>
</ul>

<p>返回值：如果解码出错，返回负值；否则返回使用的字节数。</p>

<h2 id="section-1">源码分析</h2>

<p><code>avcodec_decode_video2</code>函数比较简单，主要做了以下几个工作：</p>

<ol>
  <li>对输入的字段进行一些列的检查工作，比如宽高是否正确，输入是否为视频等等。</li>
  <li>真正的解码，通过<code>avctx-&gt;codec-&gt;decode</code>实现，它会调用相应的<code>AVCodec</code>的 decode 函数，完成解码。</li>
  <li>对得到的<code>AVFrame</code>进行一些字段进行赋值，例如宽高、像素格式等等。</li>
</ol>

<p><figure class='code'><figcaption><span>avcodec_decode_video2 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">attribute_align_arg</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class='line'>                                              <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>                                              <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="err">…</span>
</span><span class='line'>    <span class="c1">//检测输入参数</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="err">“</span><span class="n">Invalid</span> <span class="n">media</span> <span class="n">type</span> <span class="k">for</span> <span class="n">video</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="n">got_picture_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">((</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_width</span> <span class="o">||</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_height</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">av_image_check_size</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_width</span><span class="p">,</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">coded_height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avctx</span><span class="p">))</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">//真正的解码</span>
</span><span class='line'><span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">decode</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">picture</span><span class="p">,</span> <span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class='line'>        <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">//设置参数</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">codec</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">capabilities</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_CODEC_CAP_DR1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>    <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">sample_aspect_ratio</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">)</span>                      <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span>               <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">)</span>                     <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">format</span> <span class="o">==</span> <span class="n">AV_PIX_FMT_NONE</span><span class="p">)</span>   <span class="n">picture</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">format</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">pix_fmt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>以H.265解码器为例，解码示例如下：</p>

<p><figure class='code'><figcaption><span>ff_hevc_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="err">“</span><span class="n">hevc</span><span class="err">”</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="err">“</span><span class="n">HEVC</span> <span class="p">(</span><span class="n">High</span> <span class="n">Efficiency</span> <span class="n">Video</span> <span class="n">Coding</span><span class="p">)</span><span class="err">”</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class='line'>    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class='line'>    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class='line'>    <span class="err">…</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>其中<code>hevc_decode_frame</code>是解码器的真正的解码函数，定义如下：<br />
<figure class='code'><figcaption><span>hevc_decode_frame </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">hevc_decode_frame</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_output</span><span class="p">,</span>
</span><span class='line'>                             <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="n">HEVCContext</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">priv_data</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ret</span> <span class="o">=</span> <span class="n">ff_hevc_output_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="n">ret</span>    <span class="o">=</span> <span class="n">decode_nal_units</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">hwaccel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">hwaccel</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">end_frame</span><span class="p">(</span><span class="n">avctx</span><span class="p">))</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span>
</span><span class='line'>               <span class="s">&quot;hardware accelerator failed to decode picture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* verify the SEI checksum */</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">err_recognition</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_EF_CRCCHECK</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span>
</span><span class='line'>        <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_md5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ret</span> <span class="o">=</span> <span class="n">verify_md5</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">frame</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">avctx</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">err_recognition</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">AV_EF_EXPLODE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_md5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_DEBUG</span><span class="p">,</span> <span class="s">&quot;Decoded frame with POC %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">poc</span><span class="p">);</span>
</span><span class='line'>    <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">is_decoded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">output_frame</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">av_frame_move_ref</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">output_frame</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">avpkt</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：av_read_frame]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/15/av_read_frame/"/>
    <updated>2016-12-15T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/15/av_read_frame</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数调用关系</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">源码分析</a></li>
</ul>

<p><code>av_read_frame</code>函数的作用是返回文件中保存的数据。它会文件中保存的数据分成不同的帧，
每次调用都会返回一帧。注意，该函数不会忽略帧与帧之间无效数据(非帧数据)，目的是给解码器
最多的信息用于解码。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>
int av_read_frame(AVFormatContext *s, AVPacket *pkt);
</code></p>

<p>如果<code>pkt-&gt;buf</code>是 NULL,包直到下一次调用<code>av_read_frame</code>或<code>avformat_close_input</code>时都是有效的。
不需要时，包必须通过<code>av_free_packet</code>释放。对于视频，<code>packet</code>只包含一帧；对于音频，如果每帧有固定大小(如 PCM 或 ADPCM 数据)，
<code>packet</code>可以包含多个音频帧（必须是整数帧）,如果音频帧大小可变(如MPEG 音频)，它只能包含一帧数据。</p>

<p><code>pkt-&gt;pts</code><code>pkt-&gt;dts</code><code>pkt-&gt;duration</code>都是以<code>AVStream.time_base_units</code>为单位的。
如果视频格式里包含 B 帧，<code>pkt-&gt;pts</code>可以是<code>AV_NOPTS_VALUE</code>,因此如果不解压缩数据，最好
查看<code>pkt-&gt;dts</code>。</p>

<p>如果函数返回0，正确；小于0，则为到文件尾或出错。</p>

<h2 id="section-1">函数调用关系</h2>

<p><img src="http://lazybing.github.io/images/av_read_frame/av_read_frame.png" /></p>

<h2 id="section-2">源码分析</h2>

<p><code>av_read_frame</code>函数会判断在未解码缓存中是否有数据，如果有数据则调用<code>read_from_packet_buffer</code>。</p>

]]></content>
  </entry>
  
</feed>
