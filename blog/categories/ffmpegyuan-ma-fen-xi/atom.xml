<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ffmpeg源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/ffmpegyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-09-03T21:59:18-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AVPacket 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avpacket-structure/"/>
    <updated>2016-07-03T08:19:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avpacket-structure</id>
    <content type="html"><![CDATA[<p>AVPacket是存储压缩编码数据相关信息的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}</p>

<p>typedef struct AVPacket{</p>

<pre><code>AVBufferRef *buf;
int64_t pts;
int64_t dts;
uint8_t *data;
int   size;
int   stream_index;
int   flags;
AVPacketSideData *side_data;
int side_data_elems;
int   duration;
int64_t pos;                            ///&lt; byte position in stream, -1 if unknown
int64_t convergence_duration;
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVStream 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avstream-structure/"/>
    <updated>2016-07-03T04:31:41-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avstream-structure</id>
    <content type="html"><![CDATA[<p>AVStream是存储每一个视频/音频流信息的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVStream{</p>

<pre><code>int index;      /* stream index in AVFormatContext */
int id;         /*  Format-specific stream ID */
AVCodecContext *codec;
void *priv_data;
AVRational time_base;
int64_t start_time;
int64_t duration;

int64_t nb_frames;                 ///&lt; number of frames in this stream if known or 0

int disposition; /**&lt; AV_DISPOSITION_* bit field */

enum AVDiscard discard; ///&lt; Selects which packets can be discarded at will and do not need to be demuxed.
AVRational sample_aspect_ratio;

AVDictionary *metadata;
AVRational avg_frame_rate;

AVPacket attached_pic;
AVPacketSideData *side_data;
int            nb_side_data;
int event_flags;
int pts_wrap_bits; /**&lt; number of bits in pts (used for wrapping control) */
int64_t first_dts;
int64_t cur_dts;
int64_t last_IP_pts;
int last_IP_duration;
int probe_packets;
int codec_info_nb_frames;

/* av_read_frame() support */
enum AVStreamParseType need_parsing;
struct AVCodecParserContext *parser;
struct AVPacketList *last_in_packet_buffer;
AVProbeData probe_data;
#define MAX_REORDER_DELAY 16
int64_t pts_buffer[MAX_REORDER_DELAY+1];

AVIndexEntry *index_entries; /**&lt; Only used if the format does not
                                support seeking natively. */
int nb_index_entries;
unsigned int index_entries_allocated_size;
AVRational r_frame_rate;
int stream_identifier;

int64_t interleaver_chunk_size;
int64_t interleaver_chunk_duration;
int request_probe;
int skip_to_keyframe;
int skip_samples;
int64_t start_skip_samples;
int64_t first_discard_sample;
int64_t last_discard_sample;
int nb_decoded_frames;
int64_t mux_ts_offset;
int64_t pts_wrap_reference;
int pts_wrap_behavior;
int update_initial_durations_done;
int64_t pts_reorder_error[MAX_REORDER_DELAY+1];
uint8_t pts_reorder_error_count[MAX_REORDER_DELAY+1];
int64_t last_dts_for_order_check;
uint8_t dts_ordered;
uint8_t dts_misordered;
int inject_global_side_data;
char *recommended_encoder_configuration;
AVRational display_aspect_ratio;

struct FFFrac *priv_pts;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVCodec 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/03/avcodec-structure/"/>
    <updated>2016-07-03T01:11:57-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/03/avcodec-structure</id>
    <content type="html"><![CDATA[<p>AVCodec是存储编解码器信息的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVCodec{</p>

<pre><code>const char *name;
const char *long_name;
enum AVMediaType type;
enum AVCodecID id;
int capabilities;
const AVRational *supported_framerates; ///&lt; array of supported framerates, or NULL if any, array is terminated by {0,0}
const enum AVPixelFormat *pix_fmts;     ///&lt; array of supported pixel formats, or NULL if unknown, array is terminated by -1
const int *supported_samplerates;       ///&lt; array of supported audio samplerates, or NULL if unknown, array is terminated by 0
const enum AVSampleFormat *sample_fmts; ///&lt; array of supported sample formats, or NULL if unknown, array is terminated by -1
const uint64_t *channel_layouts;         ///&lt; array of support channel layouts, or NULL if unknown. array is terminated by 0
uint8_t max_lowres;                     ///&lt; maximum value for lowres supported by the decoder, no direct access, use av_codec_get_max_lowres()
const AVClass *priv_class;              ///&lt; AVClass for the private context
const AVProfile *profiles;              ///&lt; array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
int priv_data_size;
struct AVCodec *next;
int (*init_thread_copy)(AVCodecContext *);
int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);
const AVCodecDefault *defaults;
void (*init_static_data)(struct AVCodec *codec);

int (*init)(AVCodecContext *);
int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,
int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,
               int *got_packet_ptr);
int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);
int (*close)(AVCodecContext *);
void (*flush)(AVCodecContext *);
int caps_internal;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVIOContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/02/aviocontext-structure/"/>
    <updated>2016-07-02T17:15:20-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/02/aviocontext-structure</id>
    <content type="html"><![CDATA[<p>AVIOContext 是FFMPEG管理输入输出数据的结构体。</p>

<!--more-->


<p>{% codeblock lang:c %}</p>

<p>typedef struct AVIOContext{
    const AVClass <em>av_class;
    unsigned char </em>buffer;  /<strong>&lt; Start of the buffer. */
    int buffer_size;        /</strong>&lt; Maximum buffer size <em>/
    unsigned char </em>buf_ptr; /<strong>&lt; Current position in the buffer <em>/
    unsigned char </em>buf_end; /</strong>&lt; End of the data <em>/
    int (</em>read_packet)(void <em>opaque, uint8_t </em>buf, int buf_size);
    int (<em>write_packet)(void </em>opaque, uint8_t <em>buf, int buf_size);
    int64_t (</em>seek)(void <em>opaque, int64_t offset, int whence);
    int64_t pos;            /**&lt; position in the file of the current buffer </em>/
    int must_flush;         /<strong>&lt; true if the next seek should flush */
    int eof_reached;        /</strong>&lt; true if eof reached <em>/
    int write_flag;         /**&lt; true if open for writing </em>/
    int max_packet_size;
    unsigned long checksum;
    unsigned char <em>checksum_ptr;
    unsigned long (</em>update_checksum)(unsigned long checksum, const uint8_t <em>buf, unsigned int size);
    int error;              /**&lt; contains the error code or 0 if no error happened </em>/
    int (<em>read_pause)(void </em>opaque, int pause);
    int64_t (<em>read_seek)(void </em>opaque, int stream_index,
                         int64_t timestamp, int flags);
    int seekable;
    int64_t maxsize;
    int direct;
    int64_t bytes_read;
    int seek_count;
    int writeout_count;
    int orig_buffer_size;
    int short_seek_threshold;
}</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVCodecContext 结构体解析]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/01/avcodeccontext-structure/"/>
    <updated>2016-07-01T10:16:42-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/01/avcodeccontext-structure</id>
    <content type="html"><![CDATA[<p>AVCodecContext 可能是最复杂的结构体了。</p>

<!--more-->


<p>{% codeblock lang:c %}
typedef struct AVCodecContext{
    const AVClass <em>av_class;
    int log_level_offset;
    enum AVMediaType codec_type;
    const struct AVCodec </em>codec;
    enum AVCodecID     codec_id;
    unsigned int codec_tag;
    void <em>priv_data;
    struct AVCodecInternal </em>internal;
    void <em>opaque;
    int bit_rate;
    int bit_rate_tolerance;
    int global_quality;
    int compression_level;
    int flags;
    int flags2;
    uint8_t </em>extradata;
    int extradata_size;
    AVRational time_base;
    int ticks_per_frame;
    int delay;
    int width, height;
    int coded_width, coded_height;
    int gop_size;
    enum AVPixelFormat pix_fmt;
    void (<em>draw_horiz_band)(struct AVCodecContext </em>s,
                            const AVFrame <em>src, int offset[AV_NUM_DATA_POINTERS],
                            int y, int type, int height);
    enum AVPixelFormat (</em>get_format)(struct AVCodecContext <em>s, const enum AVPixelFormat * fmt);
    int max_b_frames;
    float b_quant_factor;
    int b_frame_strategy;
    float b_quant_offset;
    int has_b_frames;
    int mpeg_quant;         /</em>decoding: unused<em>/
    float i_quant_factor;   /</em>decoding: unused<em>/
    float i_quant_offset;   /</em>decoding: unused<em>/
    float lumi_masking;     /</em>decoding: unused<em>/
    float temporal_cplx_masking; /</em>decoding: unused<em>/
    float spatial_cplx_masking;  /</em>decoding: unused<em>/
    float p_masking;        /</em>decoding: unused<em>/
    float dark_masking;     /</em>decoding: unused<em>/
    int slice_count;
    int prediction_method;  /</em>decoding: unused<em>/
    int </em>slice_offset;
    AVRational sample_aspect_ratio;
    int me_cmp;             /<em>decoding: unused</em>/
    int me_sub_cmp;         /<em>decoding: unused</em>/
    int mb_cmp;             /<em>decoding: unused</em>/
    int ildct_cmp;          /<em>decoding: unused</em>/
    int dia_size;           /<em>decoding: unused</em>/
    int last_predictor_count;   /<em>decoding: unused</em>/
    int pre_me;             /<em>decoding: unused</em>/
    int me_pre_cmp;         /<em>decoding: unused</em>/
    int pre_dia_size;       /<em>decoding: unused</em>/
    int me_subpel_quality;  /<em>decoding: unused</em>/
    int me_range;           /<em>decoding: unused</em>/
    int slice_flags;
    int mb_decision;
    uint16_t <em>intra_matrix;
    uint16_t </em>inter_matrix;
    int scenechange_threshold;  /<em>decoding: unused</em>/
    int noise_reduction;        /<em>decoding: unused</em>/
    int intra_dc_precision;
    int skip_top;
    int skip_bottom;
    int mb_lmin;            /<em>decoding: unused</em>/
    int mb_lmax;            /<em>decoding: unused</em>/
    int me_penalty_compensation;    /<em>decoding: unused</em>/
    int bidir_refine;       /<em>decoding: unused</em>/
    int brd_scale;          /<em>decoding: unused</em>/
    int keyint_min;         /<em>decoding: unused</em>/
    int refs;
    int chromaoffset;       /<em>decoding: unused</em>/
    int mv0_threshold;      /<em>decoding: unused</em>/
    int b_sensitivity;      /<em>decoding: unused</em>/
    enum AVColorPrimaries color_primaries;
    enum AVColorTransferCharacteristic color_trc;
    enum AVColorSpace colorspace;
    enum AVColorRange color_range;
    enum AVChromaLocation chroma_sample_location;
    int slices;             /<em>decoding: unused</em>/
    enum AVFieldOrder field_order;
    int sample_rate;        /<em> audio only </em>/
    int channels;           /<em> audio only </em>/
    enum AVSampleFormat sample_fmt;
    int frame_size;
    int frame_number;
    int block_align;
    int cutoff;             /<em>decoding: unused</em>/
    uint64_t channel_layout;    /<em> audio </em>/
    uint64_t request_channel_layout;
    enum AVAudioServiceType audio_service_type;
    enum AVSampleFormat request_sample_fmt;
    int (<em>get_buffer2)(struct AVCodecContext </em>s, AVFrame <em>frame, int flags);
    int refcounted_frames;
    float qcompress;    /</em> - encoding parameters <em>/
    float qblur;        /</em> - encoding parameters <em>/
    int qmin;           /</em>decoding: unused<em>/
    int qmax;           /</em>decoding: unused<em>/
    int max_qdiff;      /</em>decoding: unused<em>/
    int rc_buffer_size;     /</em>decoding: unused<em>/
    int rc_override_count;  /</em>decoding: unused<em>/
    RcOverride </em>rc_override;/<em>decoding: unused</em>/
    int rc_max_rate;
    float rc_max_available_vbv_use; /<em>decoding: unused</em>/
    float rc_min_vbv_overflow_use;  /<em>decoding: unused</em>/
    int rc_initial_buffer_occupancy;/<em>decoding: unused</em>/
    int coder_type;             /<em>decoding: unused</em>/
    int context_model;          /<em>decoding: unused</em>/
    int frame_skip_threshold;   /<em>decoding: unused</em>/
    int frame_skip_factor;      /<em>decoding: unused</em>/
    int frame_skip_exp;         /<em>decoding: unused</em>/
    int frame_skip_cmp;         /<em>decoding: unused</em>/
    int trellis;                /<em>decoding: unused</em>/
    int min_prediction_order;   /<em>decoding: unused</em>/
    int max_prediction_order;   /<em>decoding: unused</em>/
    int64_t timecode_frame_start;
    void (<em>rtp_callback)(struct AVCodecContext </em>avctx, void *data, int size, int mb_nb);
    int rtp_payload_size;</p>

<pre><code>/* statistics, used for 2-pass encoding */
int mv_bits;
int header_bits;
int i_tex_bits;
int p_tex_bits;
int i_count;
int p_count;
int skip_count;
int misc_bits;

int frame_bits;     /*decoding: unused*/
char *stats_out;    /*decoding: unused*/
char *stats_in;     /*decoding: unused*/

int workaround_bugs;
int strict_std_compliance;
int error_concealment;
int debug;
int64_t reordered_opaque;
struct AVHWAccel *hwaccel;
void *hwaccel_context;
uint64_t error[AV_NUM_DATA_POINTERS]; /*decoding: unused*/
int dct_algo;   /*decoding: unused*/
int idct_algo;
int bits_per_coded_sample;
int bits_per_raw_sample;
int thread_count;
int thread_type;
int active_thread_type;
int thread_safe_callbacks;
int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void *arg2, int *ret, int count, int size);
int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);
int nsse_weight;    /*decoding: unused*/
int profile;
int level;
enum AVDiscard skip_loop_filter;
enum AVDiscard skip_idct;
enum AVDiscard skip_frame;
uint8_t *subtitle_header;
int subtitle_header_size;
uint64_t vbv_delay;     /*decoding: unused*/
int side_data_only_packets;
int initial_padding;
AVRational framerate;
enum AVPixelFormat sw_pix_fmt;
AVRational pkt_timebase;
const AVCodecDescriptor *codec_descriptor;

int64_t pts_correction_num_faulty_pts; /// Number of incorrect PTS values so far
int64_t pts_correction_num_faulty_dts; /// Number of incorrect DTS values so far
int64_t pts_correction_last_pts;       /// PTS of the last frame
int64_t pts_correction_last_dts;       /// DTS of the last frame

char *sub_charenc;
int sub_charenc_mode;
int skip_alpha;
int seek_preroll;
int debug_mv;
uint16_t *chroma_intra_matrix;
uint8_t *dump_separator;
char *codec_whitelist;
unsigned properties;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
