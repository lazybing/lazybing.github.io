<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:av1 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/av1/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-05-09T17:23:07-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AV1 解码详解(四)之LOOP RESTORATION(待总结)]]></title>
    <link href="http://lazybing.github.io/blog/2019/03/02/loop-restoration/"/>
    <updated>2019-03-02T18:02:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/03/02/loop-restoration</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#wiener-filter-" id="markdown-toc-wiener-filter-">Wiener Filter 维纳滤波器</a></li>
  <li><a href="#selfguided-filter-" id="markdown-toc-selfguided-filter-">Selfguided Filter 自导向投影滤波器</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p>LOOP RESTORATION，环内重建滤波器，是一个重要的增强图像质量处理方法。它包含了两种滤波器，编码器会从两者中选择其一。Wiener Filter(维纳滤波器)采用可分离的对称设计。SelfGuided(自导向投影滤波器)使用两个重建信号的线性组合来近似真实信号。编码器通过比较滤波结果，选择合适的参数，并传输给解码器。</p>

<!--more-->

<p>图像重建是一个比较成熟的领域，它包含了很多专业技术可用，比如 deblocking、deblurring、deringring、debanding、denoising、constrast enhancement、sharpening 和 resolution enhancement。</p>

<h2 id="wiener-filter-">Wiener Filter 维纳滤波器</h2>

<p>Degraded 帧的每个像素都</p>

<h2 id="selfguided-filter-">Selfguided Filter 自导向投影滤波器</h2>

<h2 id="section">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="https://static1.squarespace.com/static/56ac12221f40397fbfd21993/t/59cf3d9a2278e777855714bb/1506753947391/0000265.pdf">A SWITCHABLE LOOP-RESTORATION WITH SIDE-INFORMATION FRAMEWORK FOR THE EMERGING AV1 VIDEO CODEC</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1 解码详解(三)之CDEF]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter/"/>
    <updated>2019-01-28T06:32:04-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cdef-" id="markdown-toc-cdef-">CDEF 介绍</a></li>
  <li><a href="#section" id="markdown-toc-section">方向查找</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">非线性低通滤波器</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">定向滤波器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">代码实现分析</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">方向查找实现</a></li>
          <li><a href="#cdef--1" id="markdown-toc-cdef--1">CDEF 方向滤波</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">参考文档</a></li>
</ul>

<p>CDEF(constrained directional enhancement)约束方向增强滤波器是 AV1 里的几种滤波器之一， SPEC 中定义的该部分在 7.15 CDEF process 中。AOM 代码中在 cdef.c 相关的文件中。除此外，还可以参考 <code>The AV1 CONSTRAINED DIRECTIONAL ENHANCEMENT FILTER</code>论文，本文就是基于上面三个部分分析的结果。</p>

<!--more-->

<p>环路滤波器基于非线性低通滤波器，专为矢量化效率设计的。该滤波器考虑边缘方向和滤波模式，它通过确定每个 block 块的方向，然后自适应的用沿方向的滤波强度进行滤波。增强滤波目的是提高 AOM 的质量，尤其是低复杂性的配置中。</p>

<h2 id="cdef-">CDEF 介绍</h2>

<p>CDEF 的主要目的是过滤掉编码杂音，同时保留图像的详细内容。AV1 中采用的方法是非线性空间滤波器，该滤波器的设计非常适用于矢量化，即可以使用 SIMD 操作，而其他非线性滤波器（如中值滤波器和双边滤波器）并非如此。</p>

<p>CDEF 滤波器的设计基于以下观察：编码图像中杂音的数量通常与量化步长大致成比例，图像详细内容的数量是输入图像的一个属性，保留在量化过的图像中的最小的实际信息量也与量化成一定的比例。对于给定的步长，杂音的幅度要比细节的幅度小很多。</p>

<p>CDEF 首先判断每个块的方向，之后沿着判断的方向自适应的滤波，并沿着判断的方向小幅度旋转 45 度，滤波强度明确表示，对模糊的高度控制。</p>

<p>CDEF 是基于之前提到的两个环路滤波器，结合的滤波器用在了 AV1 Codec 中。</p>

<p>从 SPEC 中的7.15 节可以看出，CDEF 可以理解为，输入为重建像素的当前帧数组，输出为包含了 Deringed 像素的数组 CDEF 帧。CDEF 的作用就是在侦测到的块方向上执行 DEringing， 码流中 CDEF 参数存放到每个64x64块(luma像素)中。可以将 CDEF 模块大致分为3步：</p>

<ul>
  <li>CDEF Block 处理</li>
  <li>CDEF Direction 处理</li>
  <li>CDEF Filter 处理</li>
</ul>

<h2 id="section">方向查找</h2>

<p>方块滤波后，方向查找就作用在重建像素上。因为重建像素对解码器是可获取的，因此滤波方向不需要特定的给出。查找作用在 8x8 块上，当应用到量化过后的图像时，该大小对于充分处理非直接边缘已经足够小，而对可靠地估计出方向又已经足够大了,有一个固定方向作用在8x8区域上，使得矢量化滤波更容易。</p>

<p><img src="/images/av1_cdef/av1_cdef_find_dir.png"></p>

<p>对每个方向d，每行k的平均像素是: $ u_{d,k} = \frac{1}{N_{d,k}} \sum_{p \in P_{d,k}} x_p$ 其中：</p>

<ul>
  <li>$x_p$ 是像素$p$的值</li>
  <li>$P_{d,k}$是在方向$d$上第$k$行的一组像素值</li>
  <li>$N_{d,k}$是相对$P_{d,k}$对应的基数，如$N_{1,0}=2, N_{1,4}=8$</li>
</ul>

<p><code>SSD</code>的计算公式如下：$E_{d}^2 = \sum_{k} \big[\sum_{p \in P_{d,k}} \big( x_{p} - u_{d,k}\big)^2 \big]$</p>

<p>将上面的两个公式整合后，结果如下：$E_{d}^2 = \sum_{p}x_{p}^2 - \sum_{k}\frac{1}{N_{d,k}} \big(\sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>我们可以通过计算上面公式中第二部分的最大值来寻找最佳方向 $d_{opt}$, $d_opt = max_d s_d$, 其中 $s_{d} = \sum_{k}\frac{1}{N_{d,k}} \big(sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>可以用 840 乘以$S_d$来避免除以$N_{d,k}$,840 是所有$N_{d,k}$的最小公倍数。对于 8bit 数据，数据值为$[-128, 127]$，所有$840S_d$和所有的其他计算都适用于 32位 signed 整数类型。对于更高的bit，如10bit或12bit，在查找方向时，缩放像素到 8bit。</p>

<p><img src="/images/av1_cdef/direction_search.png"></p>

<p>上图展示了一个针对 8x8 块，寻找方向的例子，寻找的算法如下。为了节省解码器的复杂度，我们假定亮度和色度方向是相关的，因此我们只寻找亮度原件的方向，该方向与色度方向相同。</p>

<p><img src="/images/av1_cdef/algorithm_find_direction.png"></p>

<h2 id="section-1">非线性低通滤波器</h2>

<p>CDEF 使用非线性低通滤波器，去除编码杂音的同时不会模糊块的边缘。AV1 根据特定方向寻找滤波器抽头位置，同时当滤波器运用到块边界时，要防止过度模糊。使用非线性低通滤波器，在滤波像素偏差过大时，就不再对该像素过度强调。</p>

<h3 id="section-2">定向滤波器</h3>

<p>确认方向是为了统一特定方向上滤波器抽头，来降低振铃，同时不会模糊特定的边缘。但是单纯的定向滤波器有时无法高效的降低振铃效应，因此同时需要对像素数据使用滤波器抽头，该抽头并不是直接沿着主要方向。为了降低模糊块的风险，这些额外的抽头会被更保守的处理。因此，CDEF 定义了 primary taps 和 secondary taps。</p>

<p>primary taps 沿着方向 d，它的系数如上面图 4 所示。对 primary taps，对不同的 strength，会有不同的系数，对于1/3/5的strength，与2/4/6的strength，系数是不同的。secondary tpas 会形成一个十字架，是方向 d 旋转 45° 后得到，系数如图 5。</p>

<p><img src="/images/av1_cdef/primary_filter.png">
<img src="/images/av1_cdef/secondary_filter.png"></p>

<p>2-D CDEF 滤波器公式如下：</p>

<p>$y(i,j) = x(i,j) + round( \sum_{m,n} w_{d,m,n}^{(p)} f(x(m,n) -x(i, j), S^{(p)}, D) + \sum_{m,n} w_{d,m,n}^{(s)} f(x(m,n) -x(i,j), S^{(s)}, D))$</p>

<ul>
  <li>$S_{p}$和$S_{s}$是 primary 和 secondary 抽头的 strength。</li>
</ul>

<p>每个要滤波的 8x8 块，方向、strength 和 damping 参数是固定的。当处理位置(i, j)处的像素时，滤波器允许使用 x(i+m, j+m)处的像素，该像素可能超出 8x8 块的边界。如果处理像素超出了帧范围，像素会被忽略(f(d, S, D) = 0)。为最大化并行，CDEF 总是作用在输入(post-deblocking)像素 x(i,j)上，这样在滤波其他像素时，不会用的之前已经滤波王城的像素。</p>

<h3 id="section-3">代码实现分析</h3>

<p>此处以 DAV1D 工程里的 CDEF 模块作为例子，主要介绍两部分，<code>cdef_find_dir</code>和<code>cdef_filter_block</code>，并把 10bit 汇编优化完成。完成后，在 pixel2 手机上测试，效率提升大概 30% 左右。</p>

<h4 id="section-4">方向查找实现</h4>

<p>DAV1D 工程里，对 CDEF 方向查找，完成了 C 代码实现和对 8bit 码流的汇编优化，对10bit优化并没有完成。</p>

<p><figure class='code'><figcaption><span>cdef_find_dir.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4 id="cdef--1">CDEF 方向滤波</h4>

<p>滤波主要由两步完成，</p>

<h2 id="section-5">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="http://www.mirlab.org/conference_papers/international_conference/ICASSP%202018/pdfs/0001193.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
  <li><a href="https://jmvalin.ca/misc_stuff/icassp2018_slides.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(二)之film_grain]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis/"/>
    <updated>2018-10-17T08:35:36-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#film-grain-" id="markdown-toc-film-grain-">Film Grain 简介</a></li>
  <li><a href="#film-grain--1" id="markdown-toc-film-grain--1">Film Grain 流程</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p><code>Film Grain</code>在电视和电影内容中广泛存在，它经常是创作内容的一部分，在编码过程中需要保留下来，因为<code>film grain</code>的随机性，导致很难用传统的压缩算法进行压缩。</p>

<!--more-->

<h1 id="film-grain-">Film Grain 简介</h1>

<p><code>film grain</code>模型和整体框架如图所示。</p>

<p><img src="/images/film_grain_av1/film_grain_framework.png"></p>

<p><code>film grain</code>在去噪音过程中会从视频中去除掉，<code>grain</code>参数会通过噪音视频序列和去噪视频序列的差异中获得,这些参数会和压缩视频流一起传输到解码端。 解码后，<code>film grain</code>会被叠加到重建视频帧中。</p>

<h1 id="film-grain--1">Film Grain 流程</h1>

<p>从上面的框架图可以看出，<code>film grain</code>包括压缩前的去噪、编码参数、解码参数、噪音叠加到重建帧等几个过程，这里不讨论去噪的过程，主要讨论<code>film grain modeling synthesis</code>。
流程可以从<code>SPEC</code>中看到，也可以从源码中学习，<code>film grain</code>中在源码中主要集中在<code>aom/aom_dsp/grain_synthesis.c</code>中的<code>av1_add_film_grain_run</code>函数中，分析源码可知大致分为如下流程：</p>

<ul>
  <li>init_array. 为<code>film grain</code>准备后面用到的内存，大致分为三类<code>grain buffer(luma_grain_block/cb_grain_block/cr_grain_block)</code>、<code>line buf(y_line_buf/cb_line_buf/cr_line_buf)</code>、<code>column buf(y_col_buf/cb_col_buf/cr_col_buf)</code>。</li>
  <li>generate_luma_grain_block 和 generate_chroma_grain_blocks. 它会根据码流中 parse 出来的<code>grain_scale_shift/ar_coeff_lag</code>的值和<code>gaussian_sequence</code>表来填充<code>grain block</code>。</li>
  <li>init_scaling_function. 它是利用码流中 parse 出来的 <code>scaling_points_y</code>来填充<code>scaling_lut_y/scaling_lut_cb/scaling_lut_cr</code>数组。</li>
  <li>add_noise_to_block。它会根据上面生成的<code>grain block</code>叠加到重建帧上。</li>
</ul>

<h1 id="section">参考文档</h1>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/">AV1 Bitstream &amp; Decoding Process</a></li>
</ol>

<p>(未完待续…)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(一)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/15/av1-startup/"/>
    <updated>2018-10-15T07:43:02-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/15/av1-startup</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#av1-" id="markdown-toc-av1-">AV1 工具介绍</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">编码块划分</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">帧内预测</a>        <ul>
          <li><a href="#section-2" id="markdown-toc-section-2">更多的方向预测模式</a></li>
          <li><a href="#section-3" id="markdown-toc-section-3">非定向平滑帧内预测器</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">基于递归滤波的帧内预测器</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">从亮度值预测色度值</a></li>
          <li><a href="#section-6" id="markdown-toc-section-6">调色板模式</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">帧内拷贝模式</a></li>
        </ul>
      </li>
      <li><a href="#section-8" id="markdown-toc-section-8">帧间预测</a>        <ul>
          <li><a href="#section-9" id="markdown-toc-section-9">扩充参考帧</a></li>
          <li><a href="#section-10" id="markdown-toc-section-10">高级合成预测</a></li>
        </ul>
      </li>
      <li><a href="#section-11" id="markdown-toc-section-11">环路滤波和图像后处理</a>        <ul>
          <li><a href="#cdef" id="markdown-toc-cdef">约束方向增强滤波(CDEF)</a></li>
          <li><a href="#section-12" id="markdown-toc-section-12">帧超分辨率重建</a></li>
          <li><a href="#section-13" id="markdown-toc-section-13">环内重建滤波器</a></li>
          <li><a href="#section-14" id="markdown-toc-section-14">电影胶片颗粒效果合成器</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#aom-" id="markdown-toc-aom-">AOM 工程</a>    <ul>
      <li><a href="#av1--1" id="markdown-toc-av1--1">AV1 前期准备</a></li>
      <li><a href="#section-15" id="markdown-toc-section-15">获取源码</a></li>
      <li><a href="#section-16" id="markdown-toc-section-16">编译</a>        <ul>
          <li><a href="#linux-" id="markdown-toc-linux-">Linux 下编译方法</a></li>
          <li><a href="#windows-" id="markdown-toc-windows-">Windows 下编译方法</a></li>
          <li><a href="#section-17" id="markdown-toc-section-17">交叉编译</a></li>
        </ul>
      </li>
      <li><a href="#section-18" id="markdown-toc-section-18">配置选项</a></li>
      <li><a href="#aom-vs-" id="markdown-toc-aom-vs-">AOM VS 工程</a></li>
    </ul>
  </li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 工程</a>    <ul>
      <li><a href="#dav1d--1" id="markdown-toc-dav1d--1">DAV1D 下载</a></li>
      <li><a href="#dav1d--2" id="markdown-toc-dav1d--2">DAV1D 工程编译</a></li>
      <li><a href="#dav1d-vs-" id="markdown-toc-dav1d-vs-">DAV1D VS 工程</a></li>
      <li><a href="#section-19" id="markdown-toc-section-19">参考文档</a></li>
    </ul>
  </li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/AV1">AV1</a>作为一个开放、免专利的视频编码格式，专为通过网络进行传输而设计。学习一个新的视频编解码标准除了看<a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">SPEC</a>,最好的方法是看源码<code>aom</code>。本文主要记录 AV1 中使用到的技术、官方工程 AOM 和 DAV1D 两个工程的建立。</p>

<!--more-->

<h2 id="av1-">AV1 工具介绍</h2>

<h3 id="section">编码块划分</h3>

<p>尽管编码块的划分是在编码端完成，但作为一个视频压缩中的技术手段，这里也给出简单的描述。</p>

<p>VP9 中使用最大块<code>64x64</code>的块，沿着 4 个方向划分到最小的<code>4x4</code>块，并且对<code>8x8</code>块有额外严格的限制。AV1 不仅扩大了划分方式到 10 个方向，并且增大最大块到<code>128x128</code>，这其中包括了<code>4:1/1:4</code>的矩形划分（该划分方式不存在于 VP9 中）。对于举行划分，无法进行递归的划分。AV1 对于<code>8x8</code>以下的块有更加灵活的划分方式。</p>

<p><img src="/images/av1_startup/partition_vp9_av1.png"></p>

<p>注意，图中标记为 R 的，代表还可以继续向下划分。</p>

<p><code>DAV1D</code>中关于块划分和块大小的定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">BlockPartition</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">PARTITION_NONE</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_H</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_V</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_SPLIT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_T_TOP_SPLIT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_T_BOTTOM_SPLIT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_T_LEFT_SPLIT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_T_RIGHT_SPLIT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_H4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">PARTITION_V4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">N_PARTITIONS</span><span class="p">,</span>
</span><span class='line'>    <span class="n">N_SUB8x8_PARTITIONS</span> <span class="o">=</span> <span class="n">PARTITION_T_TOP_SPLIT</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">enum</span> <span class="n">BlockSize</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">BS_128x128</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_128x64</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_64x128</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_64x64</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_64x32</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_64x16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_32x64</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_32x32</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_32x16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_32x8</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_16x64</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_16x32</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_16x16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_16x8</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_16x4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_8x32</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_8x16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_8x8</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_8x4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_4x16</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_4x8</span><span class="p">,</span>
</span><span class='line'>    <span class="n">BS_4x4</span><span class="p">,</span>
</span><span class='line'>    <span class="n">N_BS_SIZES</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3 id="section-1">帧内预测</h3>

<p>VP9 支持 10 种帧内预测模式，其中包括 8 个方向预测模式（角度从 45° 到 207°）和 2 个非方向预测模式（DC 和 TM 模式）。AV1 中，帧内编码从各个角度对它进行了升级：从方向预测的角度进行了升级、非方向预测通过考虑梯度和丰富预测因子来进行了升级、利用色度和亮度的相关性进行了升级以及针对人为制造内容进行了工具的开发。</p>

<h4 id="section-2">更多的方向预测模式</h4>

<p>AV1 支持 56 个方向的预测，利用当前块的上边界和左边界，重建的图像，通过方向的差值来预测当前块的像素值，它的角度的表达式方向是从 8 个主要的差值方向中，选择其中之一，并用一个 Delta 值来确定精确的角度。</p>

<h4 id="section-3">非定向平滑帧内预测器</h4>

<p>除方向预测模式外，AV1 还支持非定向帧内预测模式，它有 4 种不同的差值方法对当前值进行预测，当前值 P 将会由深蓝色模块的像素差值获得。</p>

<p>AV1 通过增加 3 种平滑预测模式 SMOOTH_V、SMOOTH_H、SMOOTH 扩展非定向帧内模式，它们分别是在纵向、横向以及双向平均的方式进行二次差值。除此以外，还有一个 PAETH 预测器。</p>

<p><img src="/images/av1_startup/smooth_intra_predictors.png"></p>

<h4 id="section-4">基于递归滤波的帧内预测器</h4>

<p>利用滤波的方式递归地对每个像素值进行预测，在编解码方面复杂度会有所提升。</p>

<h4 id="section-5">从亮度值预测色度值</h4>

<p>从亮度值预测色度值得工具，它利用视觉图像当中亮度值通道与色度值通道具有高度相似性的特点，通过选择适当的参数再以重建亮度值通道来预测色度值，这个工具对于游戏视频具有很好地压缩效果。</p>

<h4 id="section-6">调色板模式</h4>

<p>调色板模式是将快内的元素当做几种离散的颜色，不同于直接传输像素本身的参数值，而是通过传输色块的颜色编号实现压缩的目的。AV1 支持从 8x8 到 64x64 的块，支持调色板模式，编码器会自动根据视频内容选择是否使用调色板模式。调色板模式对于当前块有单一色调的场景十分有用，一般这种场景出现在屏幕内容的压缩当中。宏块的每个平面的调色板预测期由两部分指定：1. 一个调色板，有2-8 种颜色。2. 块中每个像素的颜色索引。基色的数量决定了保真度和紧凑性的平衡。使用基于邻近的上下文对颜色索引进行熵编码。</p>

<h4 id="section-7">帧内拷贝模式</h4>

<p>AV1 允许它的帧内编码器在预测当前块时，回去往回搜索当前帧中已经重建的部分，这种方式在某种程度上与帧间编码搜索之前的帧时类似的。这种方法对于屏幕内容的视频压缩会非常有效，因为屏幕内容的视频通常会在同一帧中包含相同的文本、字符等内容。下图是一个典型的帧内拷贝应用场景，因为文字图片里很多字母相同，使得它的压缩效率可以高达 50%。</p>

<p><img src="/images/av1_startup/intra_block_copy.png"></p>

<h3 id="section-8">帧间预测</h3>

<p>帧间压缩工具比帧内压缩工具更丰富。AV1 比 VP9 在参考帧的数量和结构上有了进一步的优化，支持 8 个参考帧，并能够使用其中的 7 个参考帧进行预测，而 VP9 只使用了其中三个。AV1 还支持分层结构进行双向预测。</p>

<h4 id="section-9">扩充参考帧</h4>

<p>AV1 将每帧的参考帧个数从 3 个扩充到 7 个。这里面除了包括 VP9 中提到的 LAST 帧、GOLDEN 帧和 ALTREF 帧外，还添加了两个最近的 LAST2 和 LAST3 帧和两个最近的 BWDREF 和 ALTREF2 帧。如下图所示，该图描述了一个 golden-frame 组中多层结构，该组中多个帧共享同一个 GOLDEN 和 ALTREF 帧。BWDREF 帧是一个 look-ahead 帧，它直接编码不进行滤波，因此更适合作为后向参考帧。ALTREF2 作为中间的未来滤波的参考，它位于 GOLDEN 和 ALTREF 中间的。所有这些参考帧或者通过单一预测模式被选中、或者通过组合预测模式被选中。AV1 提供了大量的参考帧组合，同时支持双向和单向组合预测。</p>

<p><img src="/images/av1_startup/multi_layer_golden_frame.png"></p>

<h4 id="section-10">高级合成预测</h4>

<p>当有两个参考帧时，如何把它们融合在一起生成预测块，AV1 在这方面支持多种不同的方式来生成预测块，包括平均值运动补偿、加权运动补偿、楔形分割预测等等。</p>

<p><img src="/images/av1_startup/inter_compound_prediction.png"></p>

<p>运动补偿的原理是利用平滑滤波的方式将两个运动补偿块重叠在一起，特点是能够消除运动的不连续性带来的影响，以此提高预测准确率。双向预测种，可以通过调整两个预测块的权重来达到生成不同预测块的目的。AV1 除了支持平均运动补偿外，还会根据参考帧的距离来加权生成预测块，特点是当一个参考帧距离现在帧非常近的时候，它的预测准确度可能会更高，于是我们给予它更高的权重，当另一个参考帧距离比较远的时候，给予远处的参考帧一个更低的权重，权重并不直接通过比特流传输，会通过传输序号的方式在预设值的表格里查询对应的权重。</p>

<p>AV1 还支持楔形分割预测，可以通过方块运动补偿中无法准确模拟物体边界的缺点。楔形分割已经作为查表预存在编解码器中，通过编码器选择合适的最佳楔形分割方式传输比特流来告知解码器。</p>

<h3 id="section-11">环路滤波和图像后处理</h3>

<p>AV1 使用了非常多的环内滤波工具作用于解码帧中。最初阶段是去块滤波器（Deblocking Filter），该滤波器与 VP9 中使用的那个有很少的改动。最长滤波器由 VP9 中的 15-taps 减少到 13-tap。其他在 AV1 中使用的滤波器有以下几种: 约束方向增强滤波器(CDEF)、超分辨率重建(Frame Super-resolution)、 环内重建滤波器(Loop Restoration Filters)、电影颗粒胶片效果合成器(Film Grain Synthesis)。</p>

<h4 id="cdef">约束方向增强滤波(CDEF)</h4>

<p>约束方向增强滤波器，应用在去块滤波之后，对每一个 8x8 的块估计物体的方向，并沿着物体方向采用增强滤波，它能保留物体边缘的清晰度，提升重建图像的质量。</p>

<h4 id="section-12">帧超分辨率重建</h4>

<p>帧超分辨率重建，应用在 CDEF 之后，它首先将图像沿着水平方向降采样，只对低分辨率图像进行编码，在解码器升采样把分辨率图像还原为原分辨率。这个方法显著提升了低码率下的编解码的主观观测质量。</p>

<h4 id="section-13">环内重建滤波器</h4>

<p>环内重建滤波器，是另一个重要的增强图像质量的后期处理方法。它包含了两种滤波器。编码器从两者中选择其一。维纳滤波器采用可分离的对称设计。自导向投影滤波器使用两个重建信号的线性组合来近似真实信号。编码器通过比较滤波结果，选择合适的参数，并传输给解码器。</p>

<p>DAV1D 中关于这两种滤波器定义如下：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">Dav1dRestorationType</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">DAV1D_RESTORATION_NONE</span><span class="p">,</span>
</span><span class='line'>    <span class="n">DAV1D_RESTORATION_SWITCHABLE</span><span class="p">,</span>
</span><span class='line'>    <span class="n">DAV1D_RESTORATION_WIENER</span><span class="p">,</span>
</span><span class='line'>    <span class="n">DAV1D_RESTORATION_SGRPROJ</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4 id="section-14">电影胶片颗粒效果合成器</h4>

<p>电影胶片颗粒效果合成器，是针对高质量视频而设计的一个工具。电影胶片的颗粒效果，很难用传统的视频压缩方法保留。AV1 将颗粒效果合成作为后期处理的步骤，对颗粒效果单独处理，它的工作原理是将电影胶片颗粒效果在编码前从原视频中分离出来。分离后的图像进行普通编解码，而颗粒效果在最后与解码后的图像合成为最终的输出视频。</p>

<h2 id="aom-">AOM 工程</h2>

<h3 id="av1--1">AV1 前期准备</h3>

<ul>
  <li>安装<code>CMake</code>，版本需求 3.5 以上。</li>
  <li>安装<code>Git</code>。</li>
  <li>安装<code>Perl</code>。</li>
  <li>对于<code>x86</code>,需要安装<code>yasm</code>或<code>nasm</code>。</li>
  <li>安装<code>python</code>。</li>
</ul>

<h3 id="section-15">获取源码</h3>

<p><code>
$ git clone https://aomedia.googlesource.com/aom
</code></p>

<h3 id="section-16">编译</h3>

<p><code>AV1</code>采用的配制方法不再是通常的<code>config</code>命令，而是<code>cmake</code>.<code>cmake</code>会生成配置文件和编译文件，大多数系统中，默认的编译文件是<code>Makefile</code>。
执行<code>cmake</code>会得到如下提示:</p>

<p><code>
cmake [options] &lt;path-to-source&gt;
...
Options
    -G &lt;generator-name&gt; = Specify a build system generator.
</code></p>

<p>某些参数可以直接通过 cmake传递进去，如是否编译<code>encoder</code>。</p>

<blockquote>
  <p>其实不止 AV1 的官方代码，<code>DAV1D</code>工程，同样有类似的配置过程，只不过它使用的是<code>meson</code>而不是<code>cmake</code>，但效果是一样的。</p>
</blockquote>

<h4 id="linux-">Linux 下编译方法</h4>

<p>Linux 下的编译最简单了，只需要用<code>cmake</code>配置，然后<code>make</code>编译即可。</p>

<p><code>
$ cmake path/to/aom
$ make
</code>
上面的方法就可以用到<code>Linux</code>平台下，生成<code>aomdec</code>可执行文件，进行解码。</p>

<h4 id="windows-">Windows 下编译方法</h4>

<p><code>Windows</code>下使用<code>Visual Studio</code>同样可以编译运行<code>av1</code>的代码。只需要在<code>cmake</code>时指定 VS 版本号即可,支持的工具可以通过<code>cmake --help</code>来查看。</p>

<p><code>
$ make aom_vs
$ cd aom_vs
$ cmake /path/to/aom -G "Visual Studio 12 2013 Win64" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0 -DAOM_TARGET_CPU=generic
</code></p>

<p>此时在<code>aom_vs</code>路径下，会生成一个<code>AOM.sln</code>,用<code>VisualStudio 2013</code>打开该文件后，编译运行即可使用<code>VisualStudio</code>调试学习了。</p>

<h4 id="section-17">交叉编译</h4>

<p><code>
$ mkdir aom_armv7
$ cd aom_armv7
$ CFLAGS="-pie -fPIE" LDFLAGS="-pie -fpIE" cmake /path/to/aom -DCROSS=/path/to/cross_build_tool_bin/ -DCMAKE_TOOLCHAIN_FILE=/path/to/tools -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0
$ make
</code></p>

<h3 id="section-18">配置选项</h3>

<p>上面再编译的过程中，已经提到了很多配置选项，在此举几个例子：</p>

<ul>
  <li><code>-DCONFIG_AV1_ENCODER=0</code>表示不编译<code>av1 encoder</code>。</li>
  <li><code>-DAOM_TARGET_CPU=generic</code>表示不编译汇编。</li>
  <li><code>-G "Visual Studio 12 2013 Win64"</code>表示生成的配置文件，可以通过<code>VS2013</code>来打开编译运行。</li>
  <li><code>-DCMAKE_CONFIGURATION_TYPES=Debg</code>表示生成Debug 类型的可执行文件。</li>
</ul>

<h3 id="aom-vs-">AOM VS 工程</h3>

<p><img src="/images/av1_startup/aom_vs.png"></p>

<h2 id="dav1d-">DAV1D 工程</h2>

<p>DAV1D 工程是一个跨平台的 AV1 解码器，该开源项目的目标是加速解码进度，解决目前还没有硬件支持 AV1 解码的问题。它包括了大多数 AOM 工程的特性。浏览该工程源码，该源码代码比较紧凑、很多函数甚至是宏定义完成的，调试非常困难……</p>

<h3 id="dav1d--1">DAV1D 下载</h3>

<p><code>
$git clone git@code.videolan.org:videolan/dav1d.git
$git clont https://code.videolan.org/videolan/dav1d.git
</code></p>

<h3 id="dav1d--2">DAV1D 工程编译</h3>

<ol>
  <li>安装<code>Meson(0.47或更高版本)和 Ninja</code>，如果是 x86 平台，需要安装<code>nasm(2.13.02或更高版本)</code></li>
  <li>cd dav1d</li>
  <li><code>meson --buildtype debug --backend vs2017 ./ vs2017</code>，其中各个参数的含义，可以通过<code>meson --help</code>命令查看，注意，该命令的执行要在 Visual Studio 工程的 Native Tool Command 下执行。有时可能是安装时的配置的问题，即使在 Native Tool Command 下执行，仍然有问题，我是在<code>Developer Command Prompt for VS 2017</code>下执行成功的。</li>
  <li>安装完成后，就可以使用 Visual Studio 2017 打开 dav1d.sln 了。</li>
</ol>

<h3 id="dav1d-vs-">DAV1D VS 工程</h3>

<p><img src="/images/av1_startup/dav1d_vs.png"></p>

<h3 id="section-19">参考文档</h3>

<p><a href="https://aomedia.googlesource.com/aom/+/master/README.md">AV1 Codec Library</a></p>

<p><strong><em>欢迎添加微信交流</em></strong></p>

]]></content>
  </entry>
  
</feed>
