<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:av1 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/av1/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2018-10-18T07:47:13-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Av1解码详解之film_grain(三)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis/"/>
    <updated>2018-10-17T08:35:36-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#film-grain-" id="markdown-toc-film-grain-">Film Grain 简介</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p><code>Film Grain</code>在电视和电影内容中广泛存在，它经常是创作内容的一部分，在编码过程中需要保留下来，因为<code>film grain</code>的随机性，导致很难用传统的压缩算法进行压缩。</p>

<!--more-->

<h1 id="film-grain-">Film Grain 简介</h1>

<p><code>film grain</code>模型和整体框架如图所示。</p>

<p><img src="/images/film_grain_av1/film_grain_framework.png"></p>

<p><code>film grain</code>在去噪音过程中会从视频中去除掉，<code>grain</code>参数会通过噪音视频序列和去噪视频序列的差异中获得,这些参数会和压缩视频流一起传输到解码端。 解码后，<code>film grain</code>会被加到重建视频帧中。</p>

<h1 id="section">参考文档</h1>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/">AV1 Bitstream &amp; Decoding Process</a></li>
</ol>

<p>(未完待续…)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(一)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/15/av1-startup/"/>
    <updated>2018-10-15T07:43:02-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/15/av1-startup</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#av1-" id="markdown-toc-av1-">AV1 前期准备</a></li>
  <li><a href="#section" id="markdown-toc-section">获取源码</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">编译</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">最简单的编译方法</a></li>
      <li><a href="#windows-" id="markdown-toc-windows-">Windows 下编译方法</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">交叉编译</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">配置选项</a></li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/AV1">AV1</a>作为一个开放、免专利的视频编码格式，专为通过网络进行刘传书而设计。学习一个新的视频编解码标准除了看<a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">SPEC</a>,最好的方法是看源码<code>aom</code>。</p>

<!--more-->

<h1 id="av1-">AV1 前期准备</h1>

<ul>
  <li>安装<code>CMake</code>，版本需求 3.5 以上。</li>
  <li>安装<code>Git</code>。</li>
  <li>安装<code>Perl</code>。</li>
  <li>对于<code>x86</code>,需要安装<code>yasm</code>或<code>nasm</code>。</li>
  <li>安装<code>python</code>。</li>
</ul>

<h1 id="section">获取源码</h1>

<p><code>
$ git clone https://aomedia.googlesource.com/aom
</code></p>

<h1 id="section-1">编译</h1>

<h2 id="section-2">最简单的编译方法</h2>

<p><code>
$ cmake path/to/aom
$ make
</code>
上面的方法就可以用到<code>Linux</code>平台下，生成<code>aomdec</code>可执行文件，进行解码。</p>

<h2 id="windows-">Windows 下编译方法</h2>

<p><code>
$ make aom_vs
$ cd aom_vs
$ cmake /path/to/aom -G "Visual Studio 12 2013 Vin64" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0 -DAOM_TARGET_CPU=generic
</code>
此时在<code>aom_vs</code>路径下，会生成一个<code>AOM.sln</code>,用<code>VisualStudio 2013</code>打开该文件后，编译运行即可使用<code>VisualStudio</code>调试学习了。</p>

<h2 id="section-3">交叉编译</h2>

<p><code>
$ make aom_armv7
$ cd aom_armv7
$ CFLAGS="-pie -fPIE" LDFLAGS="-pie -fpIE" cmake /path/to/aom -DCROSS=/path/to/cross_build_tool_bin/ -DCMAKE_TOOLCHAIN_FILE=/path/to/tools -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0
$ make
</code></p>

<h1 id="section-4">配置选项</h1>

<p>上面再编译的过程中，已经提到了很多配置选项，例如<code>-DCONFIG_AV1_ENCODER=0</code>表示不编译<code>av1 encoder</code>。</p>

]]></content>
  </entry>
  
</feed>
