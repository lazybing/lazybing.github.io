<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:av1 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/av1/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-01-30T07:25:58-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AV1 解码详解(三)之CDEF]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter/"/>
    <updated>2019-01-28T06:32:04-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cdef-" id="markdown-toc-cdef-">CDEF 介绍</a></li>
  <li><a href="#section" id="markdown-toc-section">方向查找</a></li>
</ul>

<p>CDEF(constrained directional enhancement)约束方向增强滤波器是 AV1 里的几种滤波器之一， SPEC 中定义的该部分在 7.15 CDEF process 中。AOM 代码中在 cdef.c 相关的文件中。除此外，还可以参考 <code>The AV1 CONSTRAINED DIRECTIONAL ENHANCEMENT FILTER</code>论文，本文就是基于上面三个部分分析的结果。</p>

<!--more-->

<p>环路滤波器基于非线性低通滤波器，专为矢量化效率设计的。该滤波器考虑边缘方向和滤波模式，它通过确定每个 block 块的方向，然后自适应的用沿方向的滤波强度进行滤波。增强滤波目的是提高 AOM 的质量，尤其是低复杂性的配置中。</p>

<h2 id="cdef-">CDEF 介绍</h2>

<p>CDEF 的主要目的是过滤掉编码杂音，同时保留图像的详细内容。AV1 中采用的方法是非线性空间滤波器，该滤波器的设计非常适用于矢量化，即可以使用 SIMD 操作，而其他非线性滤波器（如中值滤波器和双边滤波器）并非如此。</p>

<p>CDEF 滤波器的设计基于以下观察：编码图像中杂音的数量通常与量化步长大致成比例，图像详细内容的数量是输入图像的一个属性，保留在量化过的图像中的最小的实际信息量也与量化成一定的比例。对于给定的步长，杂音的幅度要比细节的幅度小很多。</p>

<p>CDEF 首先判断每个块的方向，之后沿着判断的方向自适应的滤波，并沿着判断的方向小幅度旋转 45 度，滤波强度明确表示，对模糊的高度控制。</p>

<p>CDEF 是基于之前提到的两个环路滤波器，结合的滤波器用在了 AV1 Codec 中。</p>

<h2 id="section">方向查找</h2>

<p>方块滤波后，方向查找就作用在重建像素上。因为重建像素对解码器是可获取的，因此滤波方向不需要特定的给出。查找作用在 8x8 块上，当应用到量化过后的图像时，该大小对于充分处理非直接边缘已经足够小，而对可靠地估计出方向又已经足够大了。</p>

<p><img src="/images/av1_cdef/av1_cdef_find_dir.png"></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(二)之film_grain]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis/"/>
    <updated>2018-10-17T08:35:36-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#film-grain-" id="markdown-toc-film-grain-">Film Grain 简介</a></li>
  <li><a href="#film-grain--1" id="markdown-toc-film-grain--1">Film Grain 流程</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p><code>Film Grain</code>在电视和电影内容中广泛存在，它经常是创作内容的一部分，在编码过程中需要保留下来，因为<code>film grain</code>的随机性，导致很难用传统的压缩算法进行压缩。</p>

<!--more-->

<h1 id="film-grain-">Film Grain 简介</h1>

<p><code>film grain</code>模型和整体框架如图所示。</p>

<p><img src="/images/film_grain_av1/film_grain_framework.png"></p>

<p><code>film grain</code>在去噪音过程中会从视频中去除掉，<code>grain</code>参数会通过噪音视频序列和去噪视频序列的差异中获得,这些参数会和压缩视频流一起传输到解码端。 解码后，<code>film grain</code>会被叠加到重建视频帧中。</p>

<h1 id="film-grain--1">Film Grain 流程</h1>

<p>从上面的框架图可以看出，<code>film grain</code>包括压缩前的去噪、编码参数、解码参数、噪音叠加到重建帧等几个过程，这里不讨论去噪的过程，主要讨论<code>film grain modeling synthesis</code>。
流程可以从<code>SPEC</code>中看到，也可以从源码中学习，<code>film grain</code>中在源码中主要集中在<code>aom/aom_dsp/grain_synthesis.c</code>中的<code>av1_add_film_grain_run</code>函数中，分析源码可知大致分为如下流程：</p>

<ul>
  <li>init_array. 为<code>film grain</code>准备后面用到的内存，大致分为三类<code>grain buffer(luma_grain_block/cb_grain_block/cr_grain_block)</code>、<code>line buf(y_line_buf/cb_line_buf/cr_line_buf)</code>、<code>column buf(y_col_buf/cb_col_buf/cr_col_buf)</code>。</li>
  <li>generate_luma_grain_block 和 generate_chroma_grain_blocks. 它会根据码流中 parse 出来的<code>grain_scale_shift/ar_coeff_lag</code>的值和<code>gaussian_sequence</code>表来填充<code>grain block</code>。</li>
  <li>init_scaling_function. 它是利用码流中 parse 出来的 <code>scaling_points_y</code>来填充<code>scaling_lut_y/scaling_lut_cb/scaling_lut_cr</code>数组。</li>
  <li>add_noise_to_block。它会根据上面生成的<code>grain block</code>叠加到重建帧上。</li>
</ul>

<h1 id="section">参考文档</h1>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/">AV1 Bitstream &amp; Decoding Process</a></li>
</ol>

<p>(未完待续…)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(一)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/15/av1-startup/"/>
    <updated>2018-10-15T07:43:02-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/15/av1-startup</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#aom-" id="markdown-toc-aom-">AOM 工程</a>    <ul>
      <li><a href="#av1-" id="markdown-toc-av1-">AV1 前期准备</a></li>
      <li><a href="#section" id="markdown-toc-section">获取源码</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">编译</a>        <ul>
          <li><a href="#linux-" id="markdown-toc-linux-">Linux 下编译方法</a></li>
          <li><a href="#windows-" id="markdown-toc-windows-">Windows 下编译方法</a></li>
          <li><a href="#section-2" id="markdown-toc-section-2">交叉编译</a></li>
        </ul>
      </li>
      <li><a href="#section-3" id="markdown-toc-section-3">配置选项</a></li>
      <li><a href="#aom-vs-" id="markdown-toc-aom-vs-">AOM VS 工程</a></li>
    </ul>
  </li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 工程</a>    <ul>
      <li><a href="#dav1d--1" id="markdown-toc-dav1d--1">DAV1D 下载</a></li>
      <li><a href="#dav1d--2" id="markdown-toc-dav1d--2">DAV1D 工程编译</a></li>
      <li><a href="#dav1d-vs-" id="markdown-toc-dav1d-vs-">DAV1D VS 工程</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
    </ul>
  </li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/AV1">AV1</a>作为一个开放、免专利的视频编码格式，专为通过网络进行刘传书而设计。学习一个新的视频编解码标准除了看<a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">SPEC</a>,最好的方法是看源码<code>aom</code>。本文主要记录官方工程 AOM 和 DAV1D 两个工程的建立。</p>

<!--more-->

<h2 id="aom-">AOM 工程</h2>

<h3 id="av1-">AV1 前期准备</h3>

<ul>
  <li>安装<code>CMake</code>，版本需求 3.5 以上。</li>
  <li>安装<code>Git</code>。</li>
  <li>安装<code>Perl</code>。</li>
  <li>对于<code>x86</code>,需要安装<code>yasm</code>或<code>nasm</code>。</li>
  <li>安装<code>python</code>。</li>
</ul>

<h3 id="section">获取源码</h3>

<p><code>
$ git clone https://aomedia.googlesource.com/aom
</code></p>

<h3 id="section-1">编译</h3>

<p><code>AV1</code>采用的配制方法不再是通常的<code>config</code>命令，而是<code>cmake</code>.<code>cmake</code>会生成配置文件和编译文件，大多数系统中，默认的编译文件是<code>Makefile</code>。
执行<code>cmake</code>会得到如下提示:</p>

<p><code>
cmake [options] &lt;path-to-source&gt;
...
Options
    -G &lt;generator-name&gt; = Specify a build system generator.
</code></p>

<p>某些参数可以直接通过 cmake传递进去，如是否编译<code>encoder</code>。</p>

<blockquote>
  <p>其实不止 AV1 的官方代码，<code>DAV1D</code>工程，同样有类似的配置过程，只不过它使用的是<code>meson</code>而不是<code>cmake</code>，但效果是一样的。</p>
</blockquote>

<h4 id="linux-">Linux 下编译方法</h4>

<p>Linux 下的编译最简单了，只需要用<code>cmake</code>配置，然后<code>make</code>编译即可。</p>

<p><code>
$ cmake path/to/aom
$ make
</code>
上面的方法就可以用到<code>Linux</code>平台下，生成<code>aomdec</code>可执行文件，进行解码。</p>

<h4 id="windows-">Windows 下编译方法</h4>

<p><code>Windows</code>下使用<code>Visual Studio</code>同样可以编译运行<code>av1</code>的代码。只需要在<code>cmake</code>时指定 VS 版本号即可,支持的工具可以通过<code>cmake --help</code>来查看。</p>

<p><code>
$ make aom_vs
$ cd aom_vs
$ cmake /path/to/aom -G "Visual Studio 12 2013 Win64" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0 -DAOM_TARGET_CPU=generic
</code>
此时在<code>aom_vs</code>路径下，会生成一个<code>AOM.sln</code>,用<code>VisualStudio 2013</code>打开该文件后，编译运行即可使用<code>VisualStudio</code>调试学习了。</p>

<h4 id="section-2">交叉编译</h4>

<p><code>
$ mkdir aom_armv7
$ cd aom_armv7
$ CFLAGS="-pie -fPIE" LDFLAGS="-pie -fpIE" cmake /path/to/aom -DCROSS=/path/to/cross_build_tool_bin/ -DCMAKE_TOOLCHAIN_FILE=/path/to/tools -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0
$ make
</code></p>

<h3 id="section-3">配置选项</h3>

<p>上面再编译的过程中，已经提到了很多配置选项，在此举几个例子：</p>

<ul>
  <li><code>-DCONFIG_AV1_ENCODER=0</code>表示不编译<code>av1 encoder</code>。</li>
  <li><code>-DAOM_TARGET_CPU=generic</code>表示不编译汇编。</li>
  <li><code>-G "Visual Studio 12 2013 Win64"</code>表示生成的配置文件，可以通过<code>VS2013</code>来打开编译运行。</li>
  <li><code>-DCMAKE_CONFIGURATION_TYPES=Debg</code>表示生成Debug 类型的可执行文件。</li>
</ul>

<h3 id="aom-vs-">AOM VS 工程</h3>

<p><img src="/images/av1_startup/aom_vs.png"></p>

<h2 id="dav1d-">DAV1D 工程</h2>

<p>DAV1D 工程是一个跨平台的 AV1 解码器，该开源项目的目标是加速解码进度，解决目前还没有硬件支持 AV1 解码的问题。它包括了大多数 AOM 工程的特性。浏览该工程源码，该源码代码比较紧凑、很多函数甚至是宏定义完成的，调试非常困难……</p>

<h3 id="dav1d--1">DAV1D 下载</h3>

<p><code>
$git clone git@code.videolan.org:videolan/dav1d.git
$git clont https://code.videolan.org/videolan/dav1d.git
</code></p>

<h3 id="dav1d--2">DAV1D 工程编译</h3>

<ol>
  <li>安装<code>Meson(0.47或更高版本)和 Ninja</code>，如果是 x86 平台，需要安装<code>nasm(2.13.02或更高版本)</code></li>
  <li>cd dav1d</li>
  <li><code>meson --buildtype debug --backend vs2017 ./ vs2017</code>，其中各个参数的含义，可以通过<code>meson --help</code>命令查看，注意，该命令的执行要在 Visual Studio 工程的 Native Tool Command 下执行。有时可能是安装时的配置的问题，即使在 Native Tool Command 下执行，仍然有问题，我是在<code>Developer Command Prompt for VS 2017</code>下执行成功的。</li>
  <li>安装完成后，就可以使用 Visual Studio 2017 打开 dav1d.sln 了。</li>
</ol>

<h3 id="dav1d-vs-">DAV1D VS 工程</h3>

<p><img src="/images/av1_startup/dav1d_vs.png"></p>

<h3 id="section-4">参考文档</h3>

<p><a href="https://aomedia.googlesource.com/aom/+/master/README.md">AV1 Codec Library</a></p>

<p><strong><em>欢迎添加微信交流</em></strong></p>

]]></content>
  </entry>
  
</feed>
