<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读书笔记 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-06-19T10:37:22-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FFmpeg 使用]]></title>
    <link href="http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics/"/>
    <updated>2016-06-19T09:59:26-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics</id>
    <content type="html"><![CDATA[<p>FFmpeg Basics &mdash;Multimedia handling with a fast audio and video encoder 是 FFmpeg 官网提供的一本对 FFmpeg 使用的介绍手册。本文就是对读此手册时的简单记录。方便了解 FFmpeg 的作用。</p>

<!--more-->


<hr />

<h3>Bit Rate, Frame Rate 和 File Size</h3>

<p>Frame Rate 是一秒钟播放的 frame 的个数，又可以分为 interlaced 和 progressive 两种， Interlaced Frame 主要用于 TV，如 NTSC 标准使用 60i fps ，即 60 interlaced fields（30 frames）每秒。</p>

<p>Frame rate 设置使用 -r 选项： <code>ffmpeg -i input -r fps output</code></p>

<pre><code>ffmpeg -i input.avi -r 30 output.mp4
</code></pre>

<p>除此之外，也可用 fps filter 设置 frame rate。</p>

<pre><code>ffmpeg -i clip.mpg -vf fps=fps=25 clip.webm
</code></pre>

<p>Bit Rate 是单位时间内可以处理的 bits 数，可分为 <code>ABR(Average bit rate)</code> <code>CBR(Constant bit rate)</code> <code>VBR(Variable bit rate)</code>。
Bit Rate 设置使用 -b 选项：<code>ffmpeg -i input -b bitrates output</code>
针对 video 和 audio 的不同，又可使用 <code>-b:v</code> 和 <code>-b:a</code>。</p>

<pre><code>ffmpeg -i file.avi -b 1.5M film.mp4
ffmpeg -i input.avi -b:v 1500k output.mp4
</code></pre>

<p>CBR 的设置需要同时设置 bitrate、minimal rate 和 maximal rate 为相同的值，设置 maxrate的同时需要设置 bufsize 选项。</p>

<pre><code>ffmpeg -i in.avi -b 0.5M -minrate 0.5M -maxrate 0.5M -bufsize 1M out.mkv
</code></pre>

<p>File Size 是由 Video Size 和 Audio Size 两者之和组成的。</p>

<pre><code>video_size = video_bitrate * time_in_seconds / 8;
audio_size = audio_bitrate * time_in_seconds / 8; 或
audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8;
</code></pre>

<p>也可设置输出文件的最大值,设置选项为 -fs(file size) ：</p>

<pre><code>ffmpeg -i input.avi -fs 10MB output.mp4
</code></pre>

<h3>Cropping Video</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用git]]></title>
    <link href="http://lazybing.github.io/blog/2016/05/08/how-to-use-git/"/>
    <updated>2016-05-08T07:48:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/05/08/how-to-use-git</id>
    <content type="html"><![CDATA[<p>git 作为版本控制工具，已被广泛使用，公司从去年开始陆续将版本控制系统从 Perforce 向 git 转移。<a href="https://git-scm.com/book/en/v2">《Pro Git》</a>作为官方推荐的学习 git 书籍，不可不读，而且该书已经有<a href="https://git-scm.com/book/zh">中文版</a>。这篇就将记录自己学习使用 git 的过程。</p>

<!--more-->


<p>开发项目时，使用 git 主要的全过程可以大体概况为如下三个步骤：</p>

<pre><code>1. 使用 git clone 命令从远程服务器上拉取源代码到本地。

2. 按照自己的需要，本地修改从步骤 1 拉取下来的代码。

3. 将修改好的代码 git push 到远程服务器上。
</code></pre>

<h3>拉取源码</h3>

<hr />

<p>以 octopress 为例，使用 <code>git clone</code> 命令从远程服务器拉起代码的命令一般如下：</p>

<pre><code>$ git clone git@github.com:imathis/octopress.git octopress
</code></pre>

<p>此时，该命令就会将 octopress 的源码拉取到本地，并命名为 octopress 文件夹。如果使用 <code>git branch</code> 命令查看 branch 名称时，默认 branch 会是 <code>master</code> 。如果使用 <code>git remote -v</code> 来查看远程服务器名称时，默认名称会是 <code>origin</code>。</p>

<pre><code>binglis-Mac:octopress bingli$ git branch
* master
binglis-Mac:octopress bingli$ git remote -v
origin  git@github.com:imathis/octopress.git (fetch)
origin  git@github.com:imathis/octopress.git (push)
</code></pre>

<p><code>git clone</code> 是 clone 仓库，它主要用于在服务器端已经存在源码目录的情况，该方法在程序开发过程中非常有用。但如果一开始并没有这样的远程仓库，而需要我们从头开始呢？<code>git init</code> 正是在现有目录中初始化仓库，该命令创建一个名为 <code>.git</code> 的子仓库，这个子目录含有你初始化的 Git 仓库中所有的必须文件。</p>

<p>抓取代码除了用于初始化的 <code>git clone</code> 外，还有 <code>git fetch [remote name]</code> 和 <code>git pull</code>。其中 <code>git fetch</code>只是简单的从远程服务器拉取 code，但并捕鱼本地 branch 进行合并；而 <code>git pull</code> 不仅拉取远端服务器有而本地没有的 code 到本地，还会进行合并。</p>

<h3>修改代码</h3>

<hr />

<p>git 仓库里的源码一共有 4 种状态，分别是：<code>Untracked</code> <code>Unmodified</code> <code>Modified</code> <code>Staged</code>。仓库里哪些文件处于哪些状态可以通过 <code>git status</code> 命令来查看。</p>

<pre><code>binglis-Mac:octopress bingli$ git status
On branch source
Your branch is based on 'origin/master', but the upstream is gone.
  (use "git branch --unset-upstream" to fixup)
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   source/_posts/2016-05-08-how-to-use-git.md

no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>

<p><code>git status</code> 不仅可以查看状态，还能够提示如果变更某些文件的状态，如上面的 <code>2016-05-08-how-to-use-git.md</code> 处于 <code>modified</code> 状态，可以使用 <code>git add</code> 或 <code>git checkout</code> 命令修改它的状态。</p>

<h3>提交代码</h3>

<hr />

<p><code>git commit</code> 作为提交命令可以用于提交处于暂存区中的文件到仓库里。使用 <code>git commit</code> 时会自动启动一个编辑器用于添加提交说明。或者可以直接加 <code>-m</code> 选项，并在后面直接加上提交说明：</p>

<pre><code>binglis-Mac:octopress bingli$ git commit -m "commit on how to use git blog"
[source 6bf4d37] commit on how to use git blog
 1 file changed, 38 insertions(+)
</code></pre>

<p>提交后，会有信息显示当前是在哪个分之(<code>master</code>)下提交的，校验和(<code>6bf4d37</code>)，以及有多少文件修改过，多少行添加，多少行删除等信息。</p>

<p><code>git commit</code> 只是提交到了本地仓库，如果有远程仓库，可以使用 <code>git push [remote name] [branch name]</code> 命令，将其推送到远程仓库。例如：</p>

<pre><code>binglis-Mac:octopress bingli$ git push origin source
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1.85 KiB | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git@github.com:lazybing/lazybing.github.io.git
   df4de96..6bf4d37  source -&gt; source
</code></pre>
]]></content>
  </entry>
  
</feed>
