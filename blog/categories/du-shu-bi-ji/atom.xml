<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:读书笔记 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2021-07-12T16:34:25-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解计算机系统之优化程序性能]]></title>
    <link href="http://lazybing.github.io/blog/2018/05/10/csapp-program-optimization/"/>
    <updated>2018-05-10T07:57:12-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/05/10/csapp-program-optimization</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">优化编译器的能力和局限性</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">表示程序性能</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">程序示例</a></li>
  <li><a href="#define-ident-0" id="markdown-toc-define-ident-0">define IDENT 0</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">消除循环的低效率</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">减少调用过程</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">消除不必要的存储器引用</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">循环展开</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">提高并行性</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录学习完 CSAPP 的优化程序性能章节。程序的优化主要有三种方法：选择合适的算法和数据结构;编写出编译器能够有效优化以转换成高效可执行代码的源代码;将一个任务分成多个部分,使其可以在多核和多处理器的某种组合上并行计算。了解了程序优化的三种方法后，我们必须思考一个问题，既然程序的优化是无止境的，那么优化在什么点算是最好的平衡的，这里的平衡包括程序开发的时间与效率、代码的可读性与性能。想明白了这两点，就不难理解为什么人们不是把所有的语言都用汇编来编写，以及对于性能好但可读性代码差的代码在公司企业中，有的时候并不推崇了。</p>

<!--more-->

<h2 id="section">优化编译器的能力和局限性</h2>

<p>以 GCC 编译器为例，可以使用多个优化级别<code>-O1/-O2/-O3</code>等，但编译器的优化也是有限的，它只对确定性的可以优化的代码才会优化，对于不确定性的部分，编译器不会对其优化。看如下两段代码：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">twiddle1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">yp</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="n">xp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">yp</span><span class="p">;</span>
</span><span class='line'>    <span class="o">*</span><span class="n">xp</span> <span class="o">+=</span> <span class="o">*</span><span class="n">yp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">twiddle2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">xp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">yp</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="o">*</span><span class="n">xp</span> <span class="o">+=</span><span class="mi">2</span> <span class="o">*</span> <span class="o">*</span><span class="n">yp</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>上面的代码中<code>twiddle1</code>的功能是，将 yp 指针指向地址的值加到 xp 指针指向地址的值，执行两次。<code>twiddle2</code>的功能是将 yp 指针指向地址的值得两倍加到 xp 指针指向地址的值。看起来两个的功能是一样的。但当 xp 和 yp 指向同一个存储器位置时，两个程序结果不在相同，因此编译器不会优化它。这就是一个典型的“妨碍优化因素”，称为<strong>存储器别名使用</strong>。</p>

<p>再来看另外一段程序:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">f</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">fun1</span><span class="p">(){</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">f</span><span class="p">()</span> <span class="o">+</span> <span class="n">f</span><span class="p">()</span> <span class="o">+</span> <span class="n">f</span><span class="p">()</span> <span class="o">+</span> <span class="n">f</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">fun2</span><span class="p">(){</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">f</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>上面的两个函数在编译器看来也不相同，这就是妨碍优化的第二个因素：函数调用。思考，当函数 f() 存在对全局变量的修改时，因此编译器不能优化。</p>

<h2 id="section-1">表示程序性能</h2>

<p>为表示程序性能，我们引入<strong>每元素的周期数(Cycles Per Element, CPE)</strong>的概念，使用时钟周期来表示度量标准比用事件表示有用的多，因为时钟周期表示的是执行了多少条指令，而程序运行了多少时间，可能与机器的频率有关。</p>

<h2 id="section-2">程序示例</h2>

<p>以如下程序为示例，记录几种通用的优化方法：</p>

<p><figure class='code'><figcaption><span>vec.h </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifndef VEC_H</span>
</span><span class='line'><span class="cp">#define VEC_H&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;define-ident-0&quot;</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">IDENT</span> <span class="mi">0</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">#</span><span class="n">define</span> <span class="n">OP</span> <span class="o">+&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Create abstract data type for vector&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="kt">int</span> <span class="kt">data_t</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="n">vec_rec</span><span class="p">,</span> <span class="o">*</span><span class="n">vec_ptr</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><figure class='code'><figcaption><span>vec.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Create vector of specified length</span>
</span><span class='line'><span class="n">vec_ptr</span> <span class="nf">new_vec</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//Allocate header structure</span>
</span><span class='line'>    <span class="n">vec_ptr</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec_ptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">vec_rec</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">//Could not allocate storage</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//Allocate array</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">data_t</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">data_t</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">){</span>
</span><span class='line'>        <span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">//could not allocate storage</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Retrieve vector element and store at dest.</span>
</span><span class='line'><span class="c1">//Return 0 (out of bounds) or 1 (successful)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">get_vec_element</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">v</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">len</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Return length of vector</span>
</span><span class='line'><span class="kt">long</span> <span class="kt">int</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">v</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">len</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//Implementation with maximum use of data abstraction</span>
</span><span class='line'><span class="kt">void</span> <span class="n">combine1</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>    <span class="n">get_vec_element</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="n">OP</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="section-3">消除循环的低效率</h3>

<p>观察上面的 <strong>combine1</strong> 函数，可以看出在 for 循环的测试条件中，每次都要执行 <strong>vec_length</strong>，但这个函数每次执行结果都一样，可以提到测试条件外面，修改代码如下： 
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//move call to vec_length out of loop</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">combine2</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>    <span class="n">get_vec_element</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="n">OP</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="section-4">减少调用过程</h3>

<p>函数调用会带来巨大的时间开销，再来看上面的<strong>combine2</strong>函数中，每次循环都会调用<strong>get_vec_element</strong>函数，而且这个函数的返回值 val 都是随着 i 的递增而在内存中连续存放，因此可以将该函数从循环中拿出。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">data_t</span> <span class="o">*</span><span class="nf">get_vec_start</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">v</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//direct access to vector data</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">combine3</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="section-5">消除不必要的存储器引用</h3>

<p>观察上面的函数，在每次 for 循环中，都会有两次的读取内存(<em>dest 和 data[i])的操作，一次写内存(</em>dest)的操作。每次读写内存都会耗时，因此可以使用临时变量，从而使每次循环只有一次读即可。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//Accumulate result in local variable</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">combine4</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">acc</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="section-6">循环展开</h3>

<p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。它能够从两方面改善程序的性能：首先，它减少了不直接有助于程序结果的操作的数量。其次，它提供一些方法，可以进一步变换代码，减少整个计算中关键路径上的操作数量。</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//Unroll loop by 2</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">combine4</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//Combine 2 elements at a time</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">){</span>
</span><span class='line'>    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Finish any remaining elements</span>
</span><span class='line'><span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">acc</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<h3 id="section-7">提高并行性</h3>

<p>两次循环展开，并且使用两路并行，该方法利用了功能单元的流水线能力</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//Unroll loop by 2, 2-way parallelism</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">combine6</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">acc0</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">data_t</span> <span class="n">acc1</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">//combine 2 elements at a time</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">){</span>
</span><span class='line'>    <span class="n">acc0</span> <span class="o">=</span> <span class="n">acc0</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="n">acc1</span> <span class="o">=</span> <span class="n">acc1</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Finish any remaining elements</span>
</span><span class='line'><span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>    <span class="n">acc0</span> <span class="o">=</span> <span class="n">acc0</span> <span class="n">OP</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">acc0</span> <span class="n">OP</span> <span class="n">acc1</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</code></pre>

<p>还有其他的方法，比如重新组合结合上面<strong>combine5</strong>中的运算，即将
<code>
acc = (acc OP data[i]) OP data[i + 1]
</code>
合并成如下实现
<code>
acc = acc OP (data[i] OP data[i + 1])
</code></p>

<p>或者使用 SIMD 指令提高更高的并行性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFmpeg 使用]]></title>
    <link href="http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics/"/>
    <updated>2016-06-19T09:59:26-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bit-rate-frame-rate--file-size" id="markdown-toc-bit-rate-frame-rate--file-size">Bit Rate, Frame Rate 和 File Size</a></li>
  <li><a href="#resizing-and-scaling-video" id="markdown-toc-resizing-and-scaling-video">Resizing and Scaling Video</a></li>
  <li><a href="#cropping-video" id="markdown-toc-cropping-video">Cropping Video</a></li>
  <li><a href="#padding-video" id="markdown-toc-padding-video">Padding Video</a></li>
  <li><a href="#filpping-and-rotating-video" id="markdown-toc-filpping-and-rotating-video">Filpping and Rotating Video</a></li>
  <li><a href="#blur-sharpen-adn-other-denoising" id="markdown-toc-blur-sharpen-adn-other-denoising">Blur Sharpen adn Other Denoising</a></li>
  <li><a href="#overlay---picture-in-picture" id="markdown-toc-overlay---picture-in-picture">Overlay - Picture in Picture</a></li>
  <li><a href="#adding-text-on-video" id="markdown-toc-adding-text-on-video">Adding Text on Video</a></li>
  <li><a href="#conversion-between-formats" id="markdown-toc-conversion-between-formats">Conversion Between Formats</a></li>
</ul>

<p>FFmpeg Basics —Multimedia handling with a fast audio and video encoder 是 FFmpeg 官网提供的一本对 FFmpeg 使用的介绍手册。本文就是对读此手册时的简单记录。方便了解 FFmpeg 的作用。</p>

<!--more-->

<hr />

<h3 id="bit-rate-frame-rate--file-size">Bit Rate, Frame Rate 和 File Size</h3>

<p>Frame Rate 是一秒钟播放的 frame 的个数，又可以分为 interlaced 和 progressive 两种， Interlaced Frame 主要用于 TV，如 NTSC 标准使用 60i fps ，即 60 interlaced fields（30 frames）每秒。</p>

<p>Frame rate 设置使用 -r 选项： <code>ffmpeg -i input -r fps output</code></p>

<p><code>
ffmpeg -i input.avi -r 30 output.mp4
</code>
除此之外，也可用 fps filter 设置 frame rate。</p>

<p><code>
ffmpeg -i clip.mpg -vf fps=fps=25 clip.webm
</code></p>

<p>Bit Rate 是单位时间内可以处理的 bits 数，可分为 <code>ABR(Average bit rate)</code> <code>CBR(Constant bit rate)</code> <code>VBR(Variable bit rate)</code>。
Bit Rate 设置使用 -b 选项：<code>ffmpeg -i input -b bitrates output</code>
针对 video 和 audio 的不同，又可使用 <code>-b:v</code> 和 <code>-b:a</code>。</p>

<p><code>
ffmpeg -i file.avi -b 1.5M film.mp4
ffmpeg -i input.avi -b:v 1500k output.mp4
</code>
CBR 的设置需要同时设置 bitrate、minimal rate 和 maximal rate 为相同的值，设置 maxrate的同时需要设置 bufsize 选项。</p>

<p><code>
ffmpeg -i in.avi -b 0.5M -minrate 0.5M -maxrate 0.5M -bufsize 1M out.mkv
</code></p>

<p>File Size 是由 Video Size 和 Audio Size 两者之和组成的。</p>

<p><code>
video_size = video_bitrate * time_in_seconds / 8;
audio_size = audio_bitrate * time_in_seconds / 8; 或
audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8;
</code>
也可设置输出文件的最大值,设置选项为 -fs(file size) ：</p>

<p><code>
ffmpeg -i input.avi -fs 10MB output.mp4
</code>
—-</p>

<h3 id="resizing-and-scaling-video">Resizing and Scaling Video</h3>

<p>Resizing 是指改变宽高，Scaling 是利用 scale filter 改变 frame size。</p>

<p>Resizing Video ： 利用 <code>-s</code>选项指定输出视频的宽高，格式为<code>wxh</code>，其中 w 是以 pixel 为单位的宽， h 是以 pixel 为单位的高。例如:</p>

<p><code>
ffmpeg -i input_file -s 320x240 output_file
</code>
此外，FFmpeg 针对不同的宽高信息，提供了预定义的视频大小简写，下面两个命令的作用相同，都是将 input_file 转换为 640*480 的输出文件：</p>

<p><code>
ffmpeg -i input_file.avi -s 640x480 output.avi
ffmpeg -i input_file.avi -s vga output.avi
</code>
通常情况下，做 resize 是从<code>big frame -&gt; small frame</code>，反过来的话，可能导致图片不清晰，尤其是当原始视频的 resolution 比较小的时候。针对 <code>small frame -&gt; big frame</code>，有专门的特殊 filter（<code>super2xsai</code>） 可以使用，它可以使原视频文件变大两倍。2xsai 即指 2 times scale and interpolate, syntax 是 <code>-vf super2xsai</code>。
例如把 128x96 的 phone_video.3gp 文件转换为 256x192 的视频文件。</p>

<p><code>
ffmpeg -i phone_video.3gp -vf super2xsai output.mp4
</code></p>

<p>Scaling Video : 当使用<code>-s</code>选项来改变 frame size 时，其实在 filtergraph 的最后有一个 scale filter。scale filter也可以通过设置来固定在某个位置。</p>

<p>scale 可以改变输出视频的 sample aspect ration，同时 display aspect ration 保持不变。</p>

<p>syntax 是 <code>scale=width:height[:interl={l|-l}]</code>。其中 width 和 height 可以是 iw/in_w/ih/in_h/ow/out_w/oh/out_h等。</p>

<p>下面两个 command 执行效果相同:</p>

<p><code>
ffmpeg -i input.mpg -s 320x240 output.mp4
ffmpeg -i input.mpg -vf scale=320:240 output.mp4
</code>
如果不知道源视频的 resolution，又需要做 scale，可以用下面的方法:</p>

<p><code>
ffmpeg -i input.mpg -vf scale=iw/2:ih/2 output.mp4
ffmpeg -i input.mpg -vf scale=iw*0.9:ih*0.9 output.mp4
ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4
</code></p>

<hr />

<h3 id="cropping-video">Cropping Video</h3>

<p>Cropping Video 是指截取源视频中的某个矩形区域作为输出视频显示。通常它会与 Resizing/Padding 等共同配合使用。</p>

<p>旧版 FFmpeg 中会使用 cropbottom/cropleft/cropright/croptop 等选项，现在的版本中废弃了这种使用方式，改用<code>crop filter</code>的方式来实现Cropping Video。</p>

<p>syntax 是<code>crop=ow[:oh[:x[:y[:keep_aspect]]]]</code>，其中 <code>ow=out_w oh=out_h</code>。示例如下：</p>

<p><code>
ffmpeg -i input -vf crop=iw/3:ih:0:0 output
ffmpet -i input -vf crop=iw/3:ih:iw/3*2:0 output
</code>
如果x和y没有专门给出，会有默认值计算：</p>

<p><code>
X(default) = (input width - output widht)/2
Y(default) = (input height - output height)/2
</code>
<code>
ffmpeg -i input_file -vf crop=w:h output_file
ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi
</code></p>

<hr />

<h3 id="padding-video">Padding Video</h3>
<p>对于 Padding Video ，使用 pad filter 来实现。
syntax 是<code>pad=width[:height[:x[:y[:color]]]]</code>，其中的 color 表示 padding 的颜色。</p>

<p><code>
ffmpeg -i photo.jpg -vf pad=860:660:30:30:pink framed_photo.jpg
</code></p>

<p>Padding videos from 4:3 to 16:9</p>

<p><code>
ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output
ffmepg -i film.mpg -vf pad=ih*16/9:ih:(ow-iw)/2:0 filem_wide.avi
</code></p>

<p>Padding videos from 16:9 to 4:3</p>

<p><code>
ffmpeg -i input -vf pad=iw:iw*3/4:0:(oh-ih)/2:color output
ffmpeg -i hd_video.avi -vf pad=iw:iw*3/4:0:(oh-ih)/2 video.avi
</code></p>

<p>Padding from and to various aspect ratios</p>

<p><code>
ffmpeg -i input -vf pad=ih*ar:ih:(ow-iw)/2:0:color output //pillarboxing -adding boxes horizontally(To adjust a smaller width-to-height aspect ration to the bigger)
ffmpeg -i input -vf pad=iw:iw*ar:0:(oh-ih)/2:color output //letterboxing -adding boxes vertically(To adjust a bigger width-to-height aspect ration to the smaller)
</code>
—</p>

<h3 id="filpping-and-rotating-video">Filpping and Rotating Video</h3>

<h3 id="blur-sharpen-adn-other-denoising">Blur Sharpen adn Other Denoising</h3>

<h3 id="overlay---picture-in-picture">Overlay - Picture in Picture</h3>

<h3 id="adding-text-on-video">Adding Text on Video</h3>

<h3 id="conversion-between-formats">Conversion Between Formats</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用git]]></title>
    <link href="http://lazybing.github.io/blog/2016/05/08/how-to-use-git/"/>
    <updated>2016-05-08T07:48:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/05/08/how-to-use-git</id>
    <content type="html"><![CDATA[<p>git 作为版本控制工具，已被广泛使用，公司从去年开始陆续将版本控制系统从 Perforce 向 git 转移。<a href="https://git-scm.com/book/en/v2">《Pro Git》</a>作为官方推荐的学习 git 书籍，不可不读，而且该书已经有<a href="https://git-scm.com/book/zh">中文版</a>。这篇就将记录自己学习使用 git 的过程。
<!--more--></p>

<p>开发项目时，使用 git 主要的全过程可以大体概况为如下三个步骤：</p>

<pre><code>1. 使用 git clone 命令从远程服务器上拉取源代码到本地。

2. 按照自己的需要，本地修改从步骤 1 拉取下来的代码。

3. 将修改好的代码 git push 到远程服务器上。
</code></pre>

<h3 id="section">拉取源码</h3>
<hr />
<p>以 octopress 为例，使用 <code>git clone</code> 命令从远程服务器拉起代码的命令一般如下：</p>

<p><code>
$ git clone git@github.com:imathis/octopress.git octopress
</code>
此时，该命令就会将 octopress 的源码拉取到本地，并命名为 octopress 文件夹。如果使用 <code>git branch</code> 命令查看 branch 名称时，默认 branch 会是 <code>master</code> 。如果使用 <code>git remote -v</code> 来查看远程服务器名称时，默认名称会是 <code>origin</code>。</p>

<p><code>
binglis-Mac:octopress bingli$ git branch
* master
binglis-Mac:octopress bingli$ git remote -v
origin	git@github.com:imathis/octopress.git (fetch)
origin	git@github.com:imathis/octopress.git (push)
</code>
<code>git clone</code> 是 clone 仓库，它主要用于在服务器端已经存在源码目录的情况，该方法在程序开发过程中非常有用。但如果一开始并没有这样的远程仓库，而需要我们从头开始呢？<code>git init</code> 正是在现有目录中初始化仓库，该命令创建一个名为 <code>.git</code> 的子仓库，这个子目录含有你初始化的 Git 仓库中所有的必须文件。</p>

<p>抓取代码除了用于初始化的 <code>git clone</code> 外，还有 <code>git fetch [remote name]</code> 和 <code>git pull</code>。其中 <code>git fetch</code>只是简单的从远程服务器拉取 code，但并捕鱼本地 branch 进行合并；而 <code>git pull</code> 不仅拉取远端服务器有而本地没有的 code 到本地，还会进行合并。</p>

<h3 id="section-1">修改代码</h3>
<hr />
<p>git 仓库里的源码一共有 4 种状态，分别是：<code>Untracked</code> <code>Unmodified</code> <code>Modified</code> <code>Staged</code>。仓库里哪些文件处于哪些状态可以通过 <code>git status</code> 命令来查看。</p>

<p>```
binglis-Mac:octopress bingli$ git status
On branch source
Your branch is based on ‘origin/master’, but the upstream is gone.
  (use “git branch –unset-upstream” to fixup)
Changes not staged for commit:
  (use “git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)</file></file></p>

<pre><code>modified:   source/_posts/2016-05-08-how-to-use-git.md
</code></pre>

<p>no changes added to commit (use “git add” and/or “git commit -a”)
```</p>

<p><code>git status</code> 不仅可以查看状态，还能够提示如果变更某些文件的状态，如上面的 <code>2016-05-08-how-to-use-git.md</code> 处于 <code>modified</code> 状态，可以使用 <code>git add</code> 或 <code>git checkout</code> 命令修改它的状态。</p>

<h3 id="section-2">提交代码</h3>
<hr />
<p><code>git commit</code> 作为提交命令可以用于提交处于暂存区中的文件到仓库里。使用 <code>git commit</code> 时会自动启动一个编辑器用于添加提交说明。或者可以直接加 <code>-m</code> 选项，并在后面直接加上提交说明：</p>

<p><code>
binglis-Mac:octopress bingli$ git commit -m "commit on how to use git blog"
[source 6bf4d37] commit on how to use git blog
 1 file changed, 38 insertions(+)
</code>
提交后，会有信息显示当前是在哪个分之(<code>master</code>)下提交的，校验和(<code>6bf4d37</code>)，以及有多少文件修改过，多少行添加，多少行删除等信息。</p>

<p><code>git commit</code> 只是提交到了本地仓库，如果有远程仓库，可以使用 <code>git push [remote name] [branch name]</code> 命令，将其推送到远程仓库。例如：</p>

<p><code>
binglis-Mac:octopress bingli$ git push origin source
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1.85 KiB | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git@github.com:lazybing/lazybing.github.io.git
   df4de96..6bf4d37  source -&gt; source
</code></p>

]]></content>
  </entry>
  
</feed>
