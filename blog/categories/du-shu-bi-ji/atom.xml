<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读书笔记 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-02-12T03:01:01-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Complete]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/23/code-complete/"/>
    <updated>2016-12-23T18:50:56-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/23/code-complete</id>
    <content type="html"><![CDATA[
<代码大全>是一本真正体贴开发者的经典巨著 —— 云风。

<!--more-->

# 打好基础

## 欢迎进入软件构建的世界 (待续)

## 用隐喻来更充分地理解软件开发 (待续)

## 三思而后行：前期准备  (待续)

## 关键地"构建"决策  (待续)

# 创建高质量的代码  (待续)

## 软件构建中的设计  (待续)

## 可以工作的类  (待续)

## 高质量的子程序  (待续)

## 防御式编程  (待续)

## 伪代码编码过程  (待续)

# 变量

## 使用变量的一般事项 (待续)

## 变量名的力量 (待续)

## 基本数据类型 (待续)

## 不常见的数据类型 (待续)

# 语句

## 组织直线型代码 (待续)

## 使用条件语句

### if 语句

首先写正常代码路径；再处理不常见情况。  

确保对于等量的分支是正确的。  

把正常情况的处理放在 if 后面而不要放在 else 后面。  

让 if 字句后面跟随一个有意义的语句。  

考虑 else 字句。  

测试 else 字句的正确性。  

检查 if 和 else 字句是不是弄反了。  

利用布尔函数调用简化负责的检测。   

把最常见的情况放在最前面。  

确保所有的情况都考虑到。  

### case 语句

#### 为 case 选择最有效的排列顺序


按照字母顺序或数组顺序排列各种重要性相同的情况。  

把正常的情况放在前面。  

按照执行频率排列 case  字句。  

#### 使用 case  语句的诀窍

简化每种情况对应的操作。  

不要为了使用 case 语句而刻意制造一个变量。  

把 default 子句只用于检查真正的默认情况。  

利用 default 子句来检查错误。  

避免代码执行越过一条 case 子句的末尾。  


## 控制循环（待续）

## 不常见的控制结构(待续)

## 表驱动法（待续）

## 一般控制问题(待续)

# 代码改善

## 软件质量概述(待续)

## 协同构建(待续)

## 开发者测试(待续)

## 调试(待续)

## 重构(待续)

## 代码调试策略(待续)

## 代码调整技术（待续）

# 系统考虑

## 程序规模对构建的影响(待续)

## 管理构建（待续）

## 集成（待续）

## 编程工具(待续)

# 软件工艺

## 布局与风格(待续)

## 自说明代码（待续）

## 个人性格（待续）

## 软件工艺的话题(待续)

## 何处有更多信息(待续)


</代码大全>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFmpeg 使用]]></title>
    <link href="http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics/"/>
    <updated>2016-06-19T09:59:26-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/06/19/ffmpeg-basics</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bit-rate-frame-rate--file-size" id="markdown-toc-bit-rate-frame-rate--file-size">Bit Rate, Frame Rate 和 File Size</a></li>
  <li><a href="#resizing-and-scaling-video" id="markdown-toc-resizing-and-scaling-video">Resizing and Scaling Video</a></li>
  <li><a href="#cropping-video" id="markdown-toc-cropping-video">Cropping Video</a></li>
  <li><a href="#padding-video" id="markdown-toc-padding-video">Padding Video</a></li>
  <li><a href="#filpping-and-rotating-video" id="markdown-toc-filpping-and-rotating-video">Filpping and Rotating Video</a></li>
  <li><a href="#blur-sharpen-adn-other-denoising" id="markdown-toc-blur-sharpen-adn-other-denoising">Blur Sharpen adn Other Denoising</a></li>
  <li><a href="#overlay---picture-in-picture" id="markdown-toc-overlay---picture-in-picture">Overlay - Picture in Picture</a></li>
  <li><a href="#adding-text-on-video" id="markdown-toc-adding-text-on-video">Adding Text on Video</a></li>
  <li><a href="#conversion-between-formats" id="markdown-toc-conversion-between-formats">Conversion Between Formats</a></li>
</ul>

<p>FFmpeg Basics —Multimedia handling with a fast audio and video encoder 是 FFmpeg 官网提供的一本对 FFmpeg 使用的介绍手册。本文就是对读此手册时的简单记录。方便了解 FFmpeg 的作用。</p>

<!--more-->

<hr />

<h3 id="bit-rate-frame-rate--file-size">Bit Rate, Frame Rate 和 File Size</h3>

<p>Frame Rate 是一秒钟播放的 frame 的个数，又可以分为 interlaced 和 progressive 两种， Interlaced Frame 主要用于 TV，如 NTSC 标准使用 60i fps ，即 60 interlaced fields（30 frames）每秒。</p>

<p>Frame rate 设置使用 -r 选项： <code>ffmpeg -i input -r fps output</code></p>

<p><code>
ffmpeg -i input.avi -r 30 output.mp4
</code>
除此之外，也可用 fps filter 设置 frame rate。</p>

<p><code>
ffmpeg -i clip.mpg -vf fps=fps=25 clip.webm
</code></p>

<p>Bit Rate 是单位时间内可以处理的 bits 数，可分为 <code>ABR(Average bit rate)</code> <code>CBR(Constant bit rate)</code> <code>VBR(Variable bit rate)</code>。
Bit Rate 设置使用 -b 选项：<code>ffmpeg -i input -b bitrates output</code>
针对 video 和 audio 的不同，又可使用 <code>-b:v</code> 和 <code>-b:a</code>。</p>

<p><code>
ffmpeg -i file.avi -b 1.5M film.mp4
ffmpeg -i input.avi -b:v 1500k output.mp4
</code>
CBR 的设置需要同时设置 bitrate、minimal rate 和 maximal rate 为相同的值，设置 maxrate的同时需要设置 bufsize 选项。</p>

<p><code>
ffmpeg -i in.avi -b 0.5M -minrate 0.5M -maxrate 0.5M -bufsize 1M out.mkv
</code></p>

<p>File Size 是由 Video Size 和 Audio Size 两者之和组成的。</p>

<p><code>
video_size = video_bitrate * time_in_seconds / 8;
audio_size = audio_bitrate * time_in_seconds / 8; 或
audio_size = sampling_rate * bit_depth * channels * time_in_seconds / 8;
</code>
也可设置输出文件的最大值,设置选项为 -fs(file size) ：</p>

<p><code>
ffmpeg -i input.avi -fs 10MB output.mp4
</code>
—-</p>

<h3 id="resizing-and-scaling-video">Resizing and Scaling Video</h3>

<p>Resizing 是指改变宽高，Scaling 是利用 scale filter 改变 frame size。</p>

<p>Resizing Video ： 利用 <code>-s</code>选项指定输出视频的宽高，格式为<code>wxh</code>，其中 w 是以 pixel 为单位的宽， h 是以 pixel 为单位的高。例如:</p>

<p><code>
ffmpeg -i input_file -s 320x240 output_file
</code>
此外，FFmpeg 针对不同的宽高信息，提供了预定义的视频大小简写，下面两个命令的作用相同，都是将 input_file 转换为 640*480 的输出文件：</p>

<p><code>
ffmpeg -i input_file.avi -s 640x480 output.avi
ffmpeg -i input_file.avi -s vga output.avi
</code>
通常情况下，做 resize 是从<code>big frame -&gt; small frame</code>，反过来的话，可能导致图片不清晰，尤其是当原始视频的 resolution 比较小的时候。针对 <code>small frame -&gt; big frame</code>，有专门的特殊 filter（<code>super2xsai</code>） 可以使用，它可以使原视频文件变大两倍。2xsai 即指 2 times scale and interpolate, syntax 是 <code>-vf super2xsai</code>。
例如把 128x96 的 phone_video.3gp 文件转换为 256x192 的视频文件。</p>

<p><code>
ffmpeg -i phone_video.3gp -vf super2xsai output.mp4
</code></p>

<p>Scaling Video : 当使用<code>-s</code>选项来改变 frame size 时，其实在 filtergraph 的最后有一个 scale filter。scale filter也可以通过设置来固定在某个位置。</p>

<p>scale 可以改变输出视频的 sample aspect ration，同时 display aspect ration 保持不变。</p>

<p>syntax 是 <code>scale=width:height[:interl={l|-l}]</code>。其中 width 和 height 可以是 iw/in_w/ih/in_h/ow/out_w/oh/out_h等。</p>

<p>下面两个 command 执行效果相同:</p>

<p><code>
ffmpeg -i input.mpg -s 320x240 output.mp4
ffmpeg -i input.mpg -vf scale=320:240 output.mp4
</code>
如果不知道源视频的 resolution，又需要做 scale，可以用下面的方法:</p>

<p><code>
ffmpeg -i input.mpg -vf scale=iw/2:ih/2 output.mp4
ffmpeg -i input.mpg -vf scale=iw*0.9:ih*0.9 output.mp4
ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4
</code></p>

<hr />

<h3 id="cropping-video">Cropping Video</h3>

<p>Cropping Video 是指截取源视频中的某个矩形区域作为输出视频显示。通常它会与 Resizing/Padding 等共同配合使用。</p>

<p>旧版 FFmpeg 中会使用 cropbottom/cropleft/cropright/croptop 等选项，现在的版本中废弃了这种使用方式，改用<code>crop filter</code>的方式来实现Cropping Video。</p>

<p>syntax 是<code>crop=ow[:oh[:x[:y[:keep_aspect]]]]</code>，其中 <code>ow=out_w oh=out_h</code>。示例如下：</p>

<p><code>
ffmpeg -i input -vf crop=iw/3:ih:0:0 output
ffmpet -i input -vf crop=iw/3:ih:iw/3*2:0 output
</code>
如果x和y没有专门给出，会有默认值计算：</p>

<p><code>
X(default) = (input width - output widht)/2
Y(default) = (input height - output height)/2
</code>
<code>
ffmpeg -i input_file -vf crop=w:h output_file
ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi
</code></p>

<hr />

<h3 id="padding-video">Padding Video</h3>
<p>对于 Padding Video ，使用 pad filter 来实现。
syntax 是<code>pad=width[:height[:x[:y[:color]]]]</code>，其中的 color 表示 padding 的颜色。</p>

<p><code>
ffmpeg -i photo.jpg -vf pad=860:660:30:30:pink framed_photo.jpg
</code></p>

<p>Padding videos from 4:3 to 16:9</p>

<p><code>
ffmpeg -i input -vf pad=ih*16/9:ih:(ow-iw)/2:0:color output
ffmepg -i film.mpg -vf pad=ih*16/9:ih:(ow-iw)/2:0 filem_wide.avi
</code></p>

<p>Padding videos from 16:9 to 4:3</p>

<p><code>
ffmpeg -i input -vf pad=iw:iw*3/4:0:(oh-ih)/2:color output
ffmpeg -i hd_video.avi -vf pad=iw:iw*3/4:0:(oh-ih)/2 video.avi
</code></p>

<p>Padding from and to various aspect ratios</p>

<p><code>
ffmpeg -i input -vf pad=ih*ar:ih:(ow-iw)/2:0:color output //pillarboxing -adding boxes horizontally(To adjust a smaller width-to-height aspect ration to the bigger)
ffmpeg -i input -vf pad=iw:iw*ar:0:(oh-ih)/2:color output //letterboxing -adding boxes vertically(To adjust a bigger width-to-height aspect ration to the smaller)
</code>
—</p>

<h3 id="filpping-and-rotating-video">Filpping and Rotating Video</h3>

<h3 id="blur-sharpen-adn-other-denoising">Blur Sharpen adn Other Denoising</h3>

<h3 id="overlay---picture-in-picture">Overlay - Picture in Picture</h3>

<h3 id="adding-text-on-video">Adding Text on Video</h3>

<h3 id="conversion-between-formats">Conversion Between Formats</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用git]]></title>
    <link href="http://lazybing.github.io/blog/2016/05/08/how-to-use-git/"/>
    <updated>2016-05-08T07:48:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/05/08/how-to-use-git</id>
    <content type="html"><![CDATA[<p>git 作为版本控制工具，已被广泛使用，公司从去年开始陆续将版本控制系统从 Perforce 向 git 转移。<a href="https://git-scm.com/book/en/v2">《Pro Git》</a>作为官方推荐的学习 git 书籍，不可不读，而且该书已经有<a href="https://git-scm.com/book/zh">中文版</a>。这篇就将记录自己学习使用 git 的过程。
<!--more--></p>

<p>开发项目时，使用 git 主要的全过程可以大体概况为如下三个步骤：</p>

<pre><code>1. 使用 git clone 命令从远程服务器上拉取源代码到本地。

2. 按照自己的需要，本地修改从步骤 1 拉取下来的代码。

3. 将修改好的代码 git push 到远程服务器上。
</code></pre>

<h3 id="section">拉取源码</h3>
<hr />
<p>以 octopress 为例，使用 <code>git clone</code> 命令从远程服务器拉起代码的命令一般如下：</p>

<p><code>
$ git clone git@github.com:imathis/octopress.git octopress
</code>
此时，该命令就会将 octopress 的源码拉取到本地，并命名为 octopress 文件夹。如果使用 <code>git branch</code> 命令查看 branch 名称时，默认 branch 会是 <code>master</code> 。如果使用 <code>git remote -v</code> 来查看远程服务器名称时，默认名称会是 <code>origin</code>。</p>

<p><code>
binglis-Mac:octopress bingli$ git branch
* master
binglis-Mac:octopress bingli$ git remote -v
origin	git@github.com:imathis/octopress.git (fetch)
origin	git@github.com:imathis/octopress.git (push)
</code>
<code>git clone</code> 是 clone 仓库，它主要用于在服务器端已经存在源码目录的情况，该方法在程序开发过程中非常有用。但如果一开始并没有这样的远程仓库，而需要我们从头开始呢？<code>git init</code> 正是在现有目录中初始化仓库，该命令创建一个名为 <code>.git</code> 的子仓库，这个子目录含有你初始化的 Git 仓库中所有的必须文件。</p>

<p>抓取代码除了用于初始化的 <code>git clone</code> 外，还有 <code>git fetch [remote name]</code> 和 <code>git pull</code>。其中 <code>git fetch</code>只是简单的从远程服务器拉取 code，但并捕鱼本地 branch 进行合并；而 <code>git pull</code> 不仅拉取远端服务器有而本地没有的 code 到本地，还会进行合并。</p>

<h3 id="section-1">修改代码</h3>
<hr />
<p>git 仓库里的源码一共有 4 种状态，分别是：<code>Untracked</code> <code>Unmodified</code> <code>Modified</code> <code>Staged</code>。仓库里哪些文件处于哪些状态可以通过 <code>git status</code> 命令来查看。</p>

<p>```
binglis-Mac:octopress bingli$ git status
On branch source
Your branch is based on ‘origin/master’, but the upstream is gone.
  (use “git branch –unset-upstream” to fixup)
Changes not staged for commit:
  (use “git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)</file></file></p>

<pre><code>modified:   source/_posts/2016-05-08-how-to-use-git.md
</code></pre>

<p>no changes added to commit (use “git add” and/or “git commit -a”)
```</p>

<p><code>git status</code> 不仅可以查看状态，还能够提示如果变更某些文件的状态，如上面的 <code>2016-05-08-how-to-use-git.md</code> 处于 <code>modified</code> 状态，可以使用 <code>git add</code> 或 <code>git checkout</code> 命令修改它的状态。</p>

<h3 id="section-2">提交代码</h3>
<hr />
<p><code>git commit</code> 作为提交命令可以用于提交处于暂存区中的文件到仓库里。使用 <code>git commit</code> 时会自动启动一个编辑器用于添加提交说明。或者可以直接加 <code>-m</code> 选项，并在后面直接加上提交说明：</p>

<p><code>
binglis-Mac:octopress bingli$ git commit -m "commit on how to use git blog"
[source 6bf4d37] commit on how to use git blog
 1 file changed, 38 insertions(+)
</code>
提交后，会有信息显示当前是在哪个分之(<code>master</code>)下提交的，校验和(<code>6bf4d37</code>)，以及有多少文件修改过，多少行添加，多少行删除等信息。</p>

<p><code>git commit</code> 只是提交到了本地仓库，如果有远程仓库，可以使用 <code>git push [remote name] [branch name]</code> 命令，将其推送到远程仓库。例如：</p>

<p><code>
binglis-Mac:octopress bingli$ git push origin source
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 1.85 KiB | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git@github.com:lazybing/lazybing.github.io.git
   df4de96..6bf4d37  source -&gt; source
</code></p>

]]></content>
  </entry>
  
</feed>
