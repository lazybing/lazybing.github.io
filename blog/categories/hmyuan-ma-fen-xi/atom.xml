<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hm源码分析 | 懒人李冰]]></title>
  <link href="http://lazybing.github.io/blog/categories/hmyuan-ma-fen-xi/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2016-12-06T07:24:00-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HM 源码分析（一）]]></title>
    <link href="http://lazybing.github.io/blog/2015/10/01/hm-source-code-analyse0/"/>
    <updated>2015-10-01T07:48:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2015/10/01/hm-source-code-analyse0</id>
    <content type="html"><![CDATA[<p>在 HM 的源码分析中，经常会用到读取 syntax 值，此时用到 <code>xReadCode</code> <code>xReadUvlc</code> <code>xReadSvlc</code> <code>xReadFlag</code> 的函数，这篇就主要分析这几个函数的源码。
<!--more--></p>

<p>对 syntax 的分析，主要是由<code>SyntaxElementParser</code>完成，位于<code>lib\libdecoder\SyntaxElementParser.h</code>中。
{% codeblock lang:C++ syntaxelementparser.h %}</p>

<h1 id="define-readcodelength-code-name-----xreadcode--length-code-">define READ_CODE(length, code, name)     xReadCode ( length, code )</h1>
<p>#define READ_UVLC(        code, name)     xReadUvlc (         code )
#define READ_SVLC(        code, name)     xReadSvlc (         code )
#define READ_FLAG(        code, name)     xReadFlag (         code )</p>

<p>class SyntaxElementParser
{
protected:
	TComInputBitstream * m_pcBitstream;</p>

<pre><code>SyntaxElementParser()
: m_pcBitstream(NULL)
{};

virtual ~SyntaxElementParser();

void xReadCode(UInt length, UInt&amp; val);
void xReadUvlc(UInt&amp; val);
void xReadSvlc(UInt&amp; val);
void xReadFlag(UInt&amp; val); public:
void setBitstream(TComInputBitstream* p) { m_pcBitstream = p; }
TComInputBitstream* getBitstream() { return m_pcBitstream; } } {% endcodeblock %}
</code></pre>

<p>其实读取 syntax 值的这几个函数，主要是 SPEC 中第 9 部分的代码实现。这几个函数共同调用了<code>Read</code>函数。
{% codeblock lang:C++ TcomBitStream.cpp %}</p>

<p>Void TcomInputBitstream::read (UInt uiNumberOfBits, UInt&amp; ruiBits)
{
  assert( uiNumberOfBits &lt;= 32 );</p>

<p>m_numBitsRead += uiNumberOfBits;</p>

<p>/* NB, bits are extracted from the MSB of each byte. <em>/
  UInt retval = 0;
  if (uiNumberOfBits &lt;= m_num_held_bits)
  {
    /</em> n=1, len(H)=7:   -VHH HHHH, shift_down=6, mask=0xfe
     * n=3, len(H)=7:   -VVV HHHH, shift_down=4, mask=0xf8
     */
    retval = m_held_bits » (m_num_held_bits - uiNumberOfBits);
    retval &amp;= ~(0xff « uiNumberOfBits);
    m_num_held_bits -= uiNumberOfBits;
    ruiBits = retval;
    return;
  }</p>

<p>/* all num_held_bits will go into retval
   *   =&gt; need to mask leftover bits from previous extractions
   *   =&gt; align retval with top of extracted word <em>/
  /</em> n=5, len(H)=3: —- -VVV, mask=0x07, shift_up=5-3=2,
   * n=9, len(H)=3: —- -VVV, mask=0x07, shift_up=9-3=6 */
  uiNumberOfBits -= m_num_held_bits;
  retval = m_held_bits &amp; ~(0xff « m_num_held_bits);
  retval «= uiNumberOfBits;</p>

<p>/* number of whole bytes that need to be loaded to form retval <em>/
  /</em> n=32, len(H)=0, load 4bytes, shift_down=0
   * n=32, len(H)=1, load 4bytes, shift_down=1
   * n=31, len(H)=1, load 4bytes, shift_down=1+1
   * n=8,  len(H)=0, load 1byte,  shift_down=0
   * n=8,  len(H)=3, load 1byte,  shift_down=3
   * n=5,  len(H)=1, load 1byte,  shift_down=1+3
   */
  UInt aligned_word = 0;
  UInt num_bytes_to_load = (uiNumberOfBits - 1) » 3;
  assert(m_fifo_idx + num_bytes_to_load &lt; m_fifo-&gt;size());</p>

<p>switch (num_bytes_to_load)
  {
  case 3: aligned_word  = (<em>m_fifo)[m_fifo_idx++] « 24;
  case 2: aligned_word |= (</em>m_fifo)[m_fifo_idx++] « 16;
  case 1: aligned_word |= (<em>m_fifo)[m_fifo_idx++] «  8;
  case 0: aligned_word |= (</em>m_fifo)[m_fifo_idx++];
  }</p>

<p>/* resolve remainder bits */
  UInt next_num_held_bits = (32 - uiNumberOfBits) % 8;</p>

<p>/* copy required part of aligned_word into retval */
  retval |= aligned_word » next_num_held_bits;</p>

<p>/* store held bits */
  m_num_held_bits = next_num_held_bits;
  m_held_bits = aligned_word;</p>

<p>ruiBits = retval;
}
{% endcodeblock %}</p>

<p>{% codeblock lang:C++ SyntaxElementParser.cpp %}
Void SyntaxElementParser::xReadCode (UInt uiLength, UInt&amp; ruiCode)
{
  assert ( uiLength &gt; 0 );
  m_pcBitstream-&gt;read (uiLength, ruiCode);
}</p>

<p>Void SyntaxElementParser::xReadUvlc( UInt&amp; ruiVal)
{
  UInt uiVal = 0;
  UInt uiCode = 0;
  UInt uiLength;
  m_pcBitstream-&gt;read( 1, uiCode );</p>

<p>if( 0 == uiCode )
  {
    uiLength = 0;</p>

<pre><code>while( ! ( uiCode &amp; 1 ))
{
  m_pcBitstream-&gt;read( 1, uiCode );
  uiLength++;
}

m_pcBitstream-&gt;read( uiLength, uiVal );

uiVal += (1 &lt;&lt; uiLength)-1;   }
</code></pre>

<p>ruiVal = uiVal;
}</p>

<p>Void SyntaxElementParser::xReadSvlc( Int&amp; riVal)
{
  UInt uiBits = 0;
  m_pcBitstream-&gt;read( 1, uiBits );
  if( 0 == uiBits )
  {
    UInt uiLength = 0;</p>

<pre><code>while( ! ( uiBits &amp; 1 ))
{
  m_pcBitstream-&gt;read( 1, uiBits );
  uiLength++;
}

m_pcBitstream-&gt;read( uiLength, uiBits );

uiBits += (1 &lt;&lt; uiLength);
riVal = ( uiBits &amp; 1) ? -(Int)(uiBits&gt;&gt;1) : (Int)(uiBits&gt;&gt;1);   }   else   {
riVal = 0;   } }
</code></pre>

<p>Void SyntaxElementParser::xReadFlag (UInt&amp; ruiCode)
{
  m_pcBitstream-&gt;read( 1, ruiCode );
}</p>

<p>{% endcodeblock %}</p>

<p>与<code>SyntaxElementParser</code>相对应的是<code>SyntaxElementWrite</code>，其中包含了<code>xWriteCode</code> <code>xWriteUvlc</code> <code>xWriteSvlc</code> <code>xWriteFlag</code>四个函数。此处不在分析。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HM源码分析之帧内编码（一）：帧内编码的原理]]></title>
    <link href="http://lazybing.github.io/blog/2015/09/07/intra-prcture-prediction/"/>
    <updated>2015-09-07T20:42:26-07:00</updated>
    <id>http://lazybing.github.io/blog/2015/09/07/intra-prcture-prediction</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HM源码分析（一）：HEVC编码结构]]></title>
    <link href="http://lazybing.github.io/blog/2015/09/04/the-hierarchical-of-coding-structure/"/>
    <updated>2015-09-04T09:57:17-07:00</updated>
    <id>http://lazybing.github.io/blog/2015/09/04/the-hierarchical-of-coding-structure</id>
    <content type="html"><![CDATA[<p>本文主要记录了 HEVC 的编码时的分层处理架构和编码完成后码流的语法结构两个方面的学习。
<!--more--></p>

<h2 id="section">编码分层处理架构</h2>
<p>GOP(Group Of Pictures,GOP):若干时间连续的图像构成视频序列，视频序列分割成的图像组就为 GOP。GOP 分为封闭式 GOP 和 开放式 GOP,其中封闭式 GOP 其第一帧为 IDR, GOP内的图像不会参考到其他 GOP 内图像;开放式 GOP 只有第一个 GOP 内的第一帧才是 IDR，后续的 GOP 中的第一个帧内编码图像为 non-IDR，会参考前一个 GOP 中的已编码图像做参考图像。</p>

<p>{% img /images/HM/gop_type.png %}</p>

<p>Slice,每个 GOP 又被划分为多个 Slice 片，每个片由一个或多个片段(Slice Segment, SS) 组成。</p>

<p>CTU(Coding Tree Unit, CTU):每个 CTU 包括一个亮度树形编码块(Coding Tree Block, CTB) 和两个色差树形编码块。</p>

<p>一个 SS 在编码时，先被分割为相同大小的 CTU ，每个CTU 按照四叉树分割方式被划分为不同类型的编码单元(Coding Unit, CU)。</p>

<p>{% img /images/HM/slice_cu.png %}</p>

<h2 id="section-1">码流的语法架构</h2>
<p>VPS(Video Parameter Set):视频参数集，主要用于传输视频分级信息，包含多个子层和操作点共享的语法元素、会话所需要的有关操作的关键信息（档次/级别等）、其他不属于 SPS 的操作点特性信息（如HRD）。</p>

<p>SPS(Sequence Parameter Set):序列参数集，主要包含一个 CVS 中所有编码图像的共享编码参数。如图像格式信息（采样格式/图像分辨率/量化深度/Crop信息）、编码参数信息（编码块/变换块的尺寸等）、与参考图像相关的信息、可视话可用性信息(VUI)等。</p>

<p>PPS(Picture Parameter Set):图像参数集。主要包括编码工具的可用性标志、量化过程相关的句法元素、Tile 相关句法元素、去方块滤波相关句法元素、片头中的控制信息。</p>

<p>{% img /images/HM/vps_sps_pps.png %}</p>

<p>由上图可看出，SPS 会根据 parse 出来的<code>VPS index</code>来引用 VPS 的信息，同样的 PPS 会根据 parse 出来的<code>SPS index</code>来引用 PPS 的信息。当 SPS 中包含有 VPS 的信息时，使用 SPS 的信息，VPS内的信息失效，同样的当 PPS 中含有 SPS 的信息时，使用 PPS 中的信息，SPS 中的信息失效。</p>

<p>参考内容：<a href="https://www.amazon.cn/%E6%96%B0%E4%B8%80%E4%BB%A3%E9%AB%98%E6%95%88%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81H-265-HEVC-%E5%8E%9F%E7%90%86-%E6%A0%87%E5%87%86%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E4%B8%87%E5%B8%85/dp/B00QXIN7B2/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1473127274&amp;sr=1-1&amp;keywords=%E6%96%B0%E4%B8%80%E4%BB%A3%E9%AB%98%E6%95%88%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81h.265+hevc+%E5%8E%9F%E7%90%86+%E6%A0%87%E5%87%86%E4%B8%8E%E5%AE%9E%E7%8E%B0">新一代高效视频编码H.265/HEVC:原理、标准与实现</a>第三章编码结构。</p>

<p><a href="https://hevc.hhi.fraunhofer.de/">HM</a>中关于<code>VPS</code> <code>SPS</code> <code>PPS</code>编码结构的介绍主要在<code>lib\tlibcommon\TComSlice.h</code>内，稍后会对它们进行详细分析。</p>

]]></content>
  </entry>
  
</feed>
