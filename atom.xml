<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2021-07-11T01:38:17-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[H.264 Rate Control Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/"/>
    <updated>2021-06-22T06:49:35-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基础知识</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">模糊复杂度估计</a></li>
  <li><a href="#vbv-algorithm" id="markdown-toc-vbv-algorithm">VBV Algorithm</a>    <ul>
      <li><a href="#lookahead-vbv-" id="markdown-toc-lookahead-vbv-">Lookahead vbv 调整</a></li>
      <li><a href="#vbv-" id="markdown-toc-vbv-">实时 VBV 调整</a></li>
      <li><a href="#mingop-vbv-" id="markdown-toc-mingop-vbv-">minGOP vbv 调整</a></li>
    </ul>
  </li>
  <li><a href="#mb-tree-algorithm" id="markdown-toc-mb-tree-algorithm">MB-Tree Algorithm</a>    <ul>
      <li><a href="#macroblock-tree-" id="markdown-toc-macroblock-tree-">Macroblock-Tree 的高层概述</a></li>
      <li><a href="#x264-lookahead" id="markdown-toc-x264-lookahead">x264 lookahead</a></li>
      <li><a href="#macroblock-tree-algorithm-mb-tree-" id="markdown-toc-macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</a></li>
    </ul>
  </li>
  <li><a href="#adaptive-quantization-algorithm" id="markdown-toc-adaptive-quantization-algorithm">Adaptive Quantization Algorithm</a></li>
</ul>

<p>码率控制是 H.264 编码器中非常重要的一个模块。码率控制主要包括两部分：码率分配(Bit Allocation)、量化参数调整(Quantitative Parameter Adjustment)。X264 的码率控制算法大致分为帧级码率控制、宏块级码率控制。帧级码率控制算法比如：VBV 调整。宏块级别码率控制比如：MBTree 算法、VAQ 感知量化算法。</p>

<!--more-->

<h1 id="section">基础知识</h1>

<p>码率控制的主要过程是：</p>

<ol>
  <li>根据前面已经编好的帧计算 SATD 值来预测当前帧的复杂度(第一帧 I 帧除外)；</li>
  <li>计算好复杂度后，根据复杂度和线性量化控制参数(qcomp)来计算 qpscale。qpscale 会影响最终编码时所用的 qp。</li>
  <li>根据目标码率和之前编码所用的比特数可以确定一个 rate_factor，若之前编码的比特数多与目标实际产生，则 rate_factor 减小。这个 rate_factor 是调整 qpscale 用的，还有 overflow 来对qpscale 来做溢出补偿处理来控制文件大小。</li>
  <li>最后根据计算公式得到 qp。</li>
</ol>

<p>参考文档：</p>

<p><a href="https://pianshen.com/article/4198342118">x264 码率控制算法原理</a></p>

<p>编码所需的 bits 与实际编码的复杂度和量化参数有关，复杂度越复杂，量化参数越小，所需 bits 越少。复杂度用运动补偿后残差的 SATD 表示。</p>

<p>qscale = 0.85 * 2^((qp - 12)/6.0)   (1) <br />
qp = 12 + 6 * log2(qscale / 0.85)   (2)</p>

<p>x264 中的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">qp2scale</span><span class="p">(</span><span class="kt">float</span> <span class="n">qp</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">powf</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span> <span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">))</span> <span class="o">/</span> <span class="mf">6.0f</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">qscale2qp</span><span class="p">(</span><span class="kt">float</span> <span class="n">qscale</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">)</span> <span class="o">+</span> <span class="mf">6.0f</span> <span class="o">*</span> <span class="n">log2f</span><span class="p">(</span><span class="n">qscale</span> <span class="o">/</span> <span class="mf">0.85f</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="section-1">模糊复杂度估计</h1>

<p>One Pass 编码中，由经过运动补偿后残差的 SATD 代表一帧的复杂度，SATD 是将残差做  Hadrmard 变换后再取绝对值的总和，它作为一种简单的时频交换，能在一定程度上衡量生产码流的大小。</p>

<p>模糊复杂度是基于已编码帧的复杂度加权得到的。使用复杂度加权，相对于使用单独一帧的复杂度，能避免 QP 的波动：</p>

<p>blurred_complexity = cplxsum/cplxcount  <br />
cplxsum[i]   = cplxsum[i - 1] * 0.5 + satd[i - 1]<br />
cplxcount[i] = cplxcount[i - 1] * 0.5 + 1</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">double</span> <span class="n">wanted_bits</span><span class="p">,</span> <span class="n">overflow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="o">=</span> <span class="n">x264_rc_analyse_slice</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLIP_DURATION</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">f_duration</span><span class="p">)</span> <span class="o">/</span> <span class="n">BASE_FRAME_DURATION</span><span class="p">);</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">rce</span><span class="p">.</span><span class="n">text_bits</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">last_satd</span><span class="p">;</span>
</span><span class="line"><span class="n">rce</span><span class="p">.</span><span class="n">blurred_complexity</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="vbv-algorithm">VBV Algorithm</h1>

<p>VBV 是一种帧级别的码率控制算法，它是这样一种机制: VBV 相当于一个容器，每编码一帧，都从容器内取走对应 bit 的数据；与此同时，往容器内以固定的速度输入 bit。每编码完一帧，根据容器内的充盈状态(上溢/下溢)，更新接下来编码参数，使得容器的充盈程都总是处于合理的范围内。</p>

<p>视频缓冲检测器(VBV, Video Buffer Verifer)是 MPEG 视频缓冲模型，可以确保码率不会超过某个最大值。VBV Buffer Size 通常设置为 maximum rate 的两倍;如果客户端缓存比较小，设置 bufsize 等于 maxrate;如果想要限制码流的码率，设置 buffersize 为 maximum rate 的一半或更小。</p>

<p>先来看一下，x264 中关于 VBV 的几个变量定义：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="kt">x264_ratecontrol_t</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">b_vbv</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">b_vbv_min_rate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/*VBV stuff*/</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">buffer_size</span><span class="p">;</span>     <span class="c1">//VBV buffer size, 容器的总容量</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">buffer_fill_final</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">buffer_fill_final_min</span><span class="p">;</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">buffer_fill</span><span class="p">;</span> <span class="c1">//planned buffer, if all in-progress frames hit their bit budget</span>
</span><span class="line">    <span class="n">doublt</span> <span class="n">buffer_rate</span><span class="p">;</span> <span class="c1">//# of bits added to buffer_fill after each frame</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">vbv_max_rate</span><span class="p">;</span><span class="c1">//# of bits added to buffer_fill per second</span>
</span><span class="line">    <span class="kt">predictor_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>  <span class="c1">//predict frame size from satd</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">single_frame_vbv</span><span class="p">;</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">rate_factor_max_increment</span><span class="p">;</span> <span class="c1">//Don&#39;t allow RF above(CRF + this value)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>X264 中，关于 VBV 的调整在 clip_qscale 中。根据是否有 lookahead，可以分为 lookahead vbv 调整和实时 VBV 调整两种。</p>

<h2 id="lookahead-vbv-">Lookahead vbv 调整</h2>

<p>从 lookahead 模块可以得到未来若干帧的复杂度。vbv 算法的原理是：一样的 qscale 应用到 lookahead 中的所有帧中，检测会不会有帧使得 VBV 缓存下溢，并且 lookahead 中所有帧编码结束后，缓存填充度在一个合理的范围内，小步调整 qscale 直到满足上述要求。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">terminate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="cm">/*Avoid an infinite loop*/</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">terminate</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">iterations</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">buffer_fill_cur</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">target_fill</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">total_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">last_duration</span> <span class="o">=</span> <span class="n">fenc_cpb_duration</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">?</span> <span class="n">q</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="nl">f_ip_factor</span> <span class="p">:</span> <span class="n">q</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_pb_factor</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_ip_factor</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="cm">/* Loop over the planned future frames. */</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer_fill_cur</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_fill_cur</span> <span class="o">&lt;=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">total_duration</span> <span class="o">+=</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class="line">	    <span class="n">buffer_fill_cur</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class="line">	    <span class="kt">int</span> <span class="n">i_type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">i_planned_type</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	    <span class="kt">int</span> <span class="n">i_satd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">i_planned_satd</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	    <span class="k">if</span><span class="p">(</span> <span class="n">i_type</span> <span class="o">==</span> <span class="n">X264_TYPE_AUTO</span> <span class="p">)</span>
</span><span class="line">		<span class="k">break</span><span class="p">;</span>
</span><span class="line">	    <span class="n">i_type</span> <span class="o">=</span> <span class="n">IS_X264_TYPE_I</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_I</span> <span class="p">:</span> <span class="n">IS_X264_TYPE_B</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_B</span> <span class="p">:</span> <span class="n">SLICE_TYPE_P</span><span class="p">;</span>
</span><span class="line">	    <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">frame_q</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">i_satd</span> <span class="p">);</span>
</span><span class="line">	    <span class="n">buffer_fill_cur</span> <span class="o">-=</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class="line">	    <span class="n">last_duration</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">f_planned_cpb_duration</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="cm">/* Try to get to get the buffer at least 50% filled, but don&#39;t set an impossible goal. */</span>
</span><span class="line">	<span class="n">target_fill</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">+</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="p">);</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span> <span class="n">buffer_fill_cur</span> <span class="o">&lt;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">q</span> <span class="o">*=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class="line">	    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">	    <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="cm">/* Try to get the buffer no more than 80% filled, but don&#39;t set an impossible goal. */</span>
</span><span class="line">	<span class="n">target_fill</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="p">);</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">b_vbv_min_rate</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_fill_cur</span> <span class="o">&gt;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">q</span> <span class="o">/=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class="line">	    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">	    <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="k">break</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="vbv-">实时 VBV 调整</h2>

<p>如果没有 lookahead，未来帧的复杂度未知，只能根据当前帧的复杂度，控制缓存的充盈程度。算法主要流程如下：</p>

<ol>
  <li>对于 P 帧和第一个 I 帧，让当前帧编码完成后，缓存区至少还有一半容量。</li>
  <li>限制每帧大小不能超过当前缓存量的一半。</li>
  <li>限制每帧大小至少是 buffer_rate 的一半。buffer_rate = vbv-maxrate/fps。</li>
  <li>限制 qscale 不能小于输入 qscale。</li>
</ol>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_P</span> <span class="o">||</span>
</span><span class="line">        <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">&amp;&amp;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_non_b_pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class="line">        <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">q</span> <span class="o">/=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* Now a hard threshold to make sure the frame fits in VBV.</span>
</span><span class="line"><span class="cm">     * This one is mostly for I-frames. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class="line">    <span class="cm">/* For small VBVs, allow the frame to use up the entire VBV. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">max_fill_factor</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_buffer_size</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_max_bitrate</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">fps</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* For single-frame VBVs, request that the frame use up the entire VBV. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">min_fill_factor</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">single_frame_vbv</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">max_fill_factor</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="p">(</span><span class="n">max_fill_factor</span><span class="o">*</span><span class="n">bits</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">        <span class="n">q</span> <span class="o">/=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">        <span class="n">bits</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&lt;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_rate</span><span class="o">/</span><span class="n">min_fill_factor</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">bits</span><span class="o">*</span><span class="n">min_fill_factor</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_rate</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">        <span class="n">q</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="mingop-vbv-">minGOP vbv 调整</h2>

<p>B 帧 QP 不直接被 VBV 调整，它由 P 帧加一个偏移量得到。这一步检查当前 P 帧和（编码顺序）到下一个 P 帧之前的 B 帧的复杂度。适当调低 qscale (调高码率预算)，使得本 minGOPher 过后，缓存区没有上溢。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span><span class="p">);</span>
</span><span class="line"><span class="kt">double</span> <span class="n">frame_size_maximum</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">frame_size_maximum</span><span class="p">,</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">));</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="n">frame_size_maximum</span><span class="p">)</span>
</span><span class="line">    <span class="n">q</span> <span class="o">*=</span> <span class="n">bits</span> <span class="o">/</span> <span class="n">frame_size_maximum</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">b_vbv_min_rate</span><span class="p">)</span>
</span><span class="line">    <span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>参考文档:<br />
<a href="https://codesequoia.wordpress.com/2010/04/19/what-are-cbr-vbv-and-cpb/">What are CBR, VBV and CPB</a>  <br />
<a href="https://www.youtube.com/watch?v=Mn8v1ojV80M">The Hypothetical Reference Decoder(HRD)</a></p>

<h1 id="mb-tree-algorithm">MB-Tree Algorithm</h1>

<h2 id="macroblock-tree-">Macroblock-Tree 的高层概述</h2>

<p>MB-tree 算法的目的是预测信息量，该信息量表示每个宏块对未来帧的贡献。该信息允许MB-tree基于其贡献，加权每个树的质量宏块。为此，MB-tree的工作方向与预测方向相反，将信息从将来的帧传播回要编码的当前帧。</p>

<p>为此，MB-tree 需要知道多种信息，或者至少近似的信息量。首先，它必须知道即将分析的未来帧的帧类型。其次，它必须知道这些帧的运动向量。第三，它必须知道每个步骤要传播多少信息量，这会根据帧内和帧间消耗来计算。接下来描述的lookahead会说明如何获取这些信息。</p>

<h2 id="x264-lookahead">x264 lookahead</h2>

<p>x264 有个复杂的lookahead模块，该模块设计用来，在真正的编码模块分析之前，预测帧的编码消耗。它用这些预测信息来做很多的决定，比如自适应的B帧的位置、显示加权预测、以及缓冲区受阻的码率控制的比特分配。因为性能的原因，它的操作是对一半分辨率进行的，并且仅仅计算SATD残差，并不做量化和重建。</p>

<p>lookahead的核心是<code>x264_slicetype_frame_cost</code>函数，它会被重复的调用来计算p0/p1/b的帧代价。p0是被分析帧的前向预测帧，p1是被分析帧的后向预测帧，b是被分析的帧。如果p1等于b，则分析的帧是P帧。如果p0等于b，则分析的帧是I帧。因为<code>x264_slicetype_frame_cost</code>可能会在算法中被重复调用很多次，每次调用的结果都要保存下来以备未来使用。</p>

<p><code>x264_slicetype_frame_cost</code>针对每个宏块调用<code>x264_slicetype_mb_cost</code>。因为帧只有一半的分辨率，每个宏块是<code>8x8</code>的，而不是<code>16x16</code>的。<code>x264_slicetype_mb_cost</code>对每个参考帧执行向量搜索。向量搜索是典型的六边形运动搜索。</p>

<p>对于B帧，它还会检查一些可能的双向模式：一个模式类似于264的时间方向，零向量；一个模式使用运动矢量结果来自list0和list1运动搜索。<code>x264_slicetype_mb_cost</code>同样计算合适的帧内代价。所有的这些代价被保存下来，用于将来使用。这对于MB-tree非常重要，它需要这些信息用于计算。</p>

<p>这些分析的结果主要用于Viterbi算法中自适应B帧的放置。Viterbi 算法的输出不仅仅在下一帧的类型判断时使用到，而且在后面N帧的类型判断中会用到，其中N是lookahead的大小。该计划实际上是一个队列：it changes over time as frames are pulled from one end and encoded using the specified frame types, frames are added to the other end as new frames enter the encoder, and the plan is recalculated. 该计划的存在对于宏块树非常重要：它意味着很多需要知道未来帧帧类型的算法，有个可信赖的精准预测。即使GOP的结构是变化的。</p>

<p>结果，MB-tree知道未来N帧的帧类型，即近似的运动矢量和模式决策以及帧内/帧间模式代价。这样的计算成本接近于零，因为这些数据在做其他任务时，在编码器内部已经计算完了。即使这样，相对于总的编码时间，lookahead的计算消耗也是成本很低的。</p>

<h2 id="macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</h2>

<p>对于每一帧，我们在所有宏块上执行 propagate step，MacroBlock-Tree 操作的 propagate step 如下：</p>

<ol>
  <li>对于当前宏块，读取下面变量的值：
    <ul>
      <li>intra_cost: 该宏块的帧内模式的预测 SATD 代价。</li>
      <li>inter_cost: 该宏块的帧间模式的预测 SATD 代价。如果该值比 intra_cost 大，设置其为 intra_cost。</li>
      <li>propatate_in: 该宏块的 propagate_cost。因为没有任何信息，执行 propagate 的第一帧，它的 propagate_cost 值为 0。</li>
    </ul>
  </li>
  <li>计算要执行 propagate 的当前宏块对其参考帧的宏块的信息的分数，称为 propagate_fraction。计算方法为 1 - intra_cost / inter_cost。例如，如果 inter_cost 是 intra_cost 的 80%，我们说该宏块有 20% 的信息来自于它的参考帧。</li>
  <li>和当前宏块有关的所有信息总和大约为 intra_cost + propagate_cost（自身信息和提供给后续帧的信息），使用这个总和乘以继承率 propagate fraction, 可以得到来继承自参考帧的信息量 propagate amount。</li>
  <li>将 propagate_amount 划分给参考帧中相关的宏块，由于当前宏块在参考帧中运动搜索得到的补偿区域可能涉及多个宏块，即参考帧中的多个宏块都参与了当前宏块的运动补偿，所以我们根据参考帧宏块参与补偿的部分尺寸大小来分配 propagate amount。特别的，对于 B 帧，我们把 propatate amount 先平分给两个参考帧，再进一步分配给参考帧中的宏块。参考帧中的宏块最终被分到的 propagate amount 加起来就是它的 propagate cost。</li>
  <li>从前向预测的最后一帧向前一直计算到当前帧，可以得到当前帧中每个宏块对后续 n 帧的 propagate_cost，最后根据当前帧每个宏块的 propatate_cost，计算相应的偏移系数 qp_offset，所使用的公式如下：</li>
</ol>

<p>MacroblockQP = -strength * log2((intra_cost + propagate_cost) / intra_cost)。</p>

<p>其中强度系数 strength 为常量，对于未被参考的宏块而言，propagate_cost = 0, qp_offset = 0。</p>

<p>X264 源码中实现MB-Tree 的函数为 macroblock_tree，其中调用了如下三个函数来实现上述步骤：</p>

<ol>
  <li>slicetype_frame_cost():计算宏块的帧内代价和帧间代价。</li>
  <li>macroblock_tree_propagate():计算当前宏块的遗传代价。</li>
  <li>macroblock_tree_finish():计算量化参数偏移系数。</li>
</ol>

<p>参考文档：<br />
<a href="https://download.csdn.net/download/To_Be_IT_1/19848868?spm=1001.2014.3001.5501">A novel macroblock-tree algorithm for high-performance optimization of.pdf</a></p>

<h1 id="adaptive-quantization-algorithm">Adaptive Quantization Algorithm</h1>

<p>自适应量化就是根据宏块的复杂度来调整每个宏块量化时的量化参数。自适应量化的基本原理是：根据当前宏块的复杂度 SSD，与当前帧的平均复杂度做对比，若高于平均，则分配更多的码率，即用小于当前帧 QP 值的量化步长；低于平均值则分配更少的码率，即用大于当前帧的 QP 值的量化步长。</p>

<p>自适应量化主要有两个参数：aq-mode（自适应量化模式）、aq-strength（自适应量化强度）。自适应量化强度决定码率偏向于低细节(SSD)部分的强度。</p>

<p>X264 中，自适应量化的实现在<code>x264_adaptive_quant_frame</code>中：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* constants chosen to result in approximately the same overall bitrate as without AQ.</span>
</span><span class="line"><span class="cm"> * FIXME: while they&#39;re written in 5 significant digits, they&#39;re only tuned to 2. */</span>
</span><span class="line"><span class="kt">float</span> <span class="n">strength</span><span class="p">;</span>
</span><span class="line"><span class="kt">float</span> <span class="n">avg_adj</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line"><span class="kt">float</span> <span class="n">bias_strength</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">bit_depth_correction</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">avg_adj_pow2</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class="line">            <span class="kt">float</span> <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">powf</span><span class="p">(</span> <span class="n">energy</span> <span class="o">*</span> <span class="n">bit_depth_correction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.125f</span> <span class="p">);</span>
</span><span class="line">            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">            <span class="n">avg_adj</span> <span class="o">+=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">            <span class="n">avg_adj_pow2</span> <span class="o">+=</span> <span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="n">avg_adj</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class="line">    <span class="n">avg_adj_pow2</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class="line">    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class="line">    <span class="n">avg_adj</span> <span class="o">=</span> <span class="n">avg_adj</span> <span class="o">-</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="n">avg_adj_pow2</span> <span class="o">-</span> <span class="mf">14.f</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class="line">    <span class="n">bias_strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">else</span>
</span><span class="line">    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="mf">1.0397f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">float</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">mb_xy</span> <span class="o">=</span> <span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">)</span> <span class="o">+</span> <span class="n">bias_strength</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="mf">14.f</span> <span class="o">/</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">x264_log2</span><span class="p">(</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">14.427f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">quant_offsets</span> <span class="p">)</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">+=</span> <span class="n">quant_offsets</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span>
</span><span class="line">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset_aq</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">.</span><span class="n">b_have_lowres</span> <span class="p">)</span>
</span><span class="line">            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">i_inv_qscale_factor</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">x264_exp2fix8</span><span class="p">(</span><span class="n">qp_adj</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264 Loop Filter Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/09/h264-loop-filter/"/>
    <updated>2021-06-09T17:05:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/09/h264-loop-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">引入环路滤波的原因</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">环路滤波的介绍</a></li>
</ul>

<p>本文将从去块滤波的引入原因出发，分析去块滤波的原理、强度、决策、实现，并给出一个具体的实例，最后会给出 x264 中关于 Deblock 的代码实现。</p>

<!--more-->

<h2 id="section">引入环路滤波的原因</h2>

<p>在编码过程中，会因如下原因引入块效应：</p>

<ol>
  <li>每个宏块的变换、量化过程都是独立进行的，采用的量化参数不同，这就会引入量化误差，导致相邻块边界步连续。</li>
  <li>在运动补偿中，相邻块的预测值可能来自不同图像的不同位置，导致预测残差信号在边界产生数值不连续。</li>
</ol>

<p>环路滤波的引入，可以调整相邻宏块边缘上的像素值，降低不连续性，使其看起来更平滑。</p>

<h2 id="section-1">环路滤波的介绍</h2>

<p>下面给出两篇论文中，关于环路滤波部分的介绍：首先给出<code>Overview of the H.264/AVC Video Coding Standard</code> 中的<code>K. In-Loop Deblocking Filter</code>的介绍。我把它翻译成长中文如下。</p>

<blockquote>
  <p>基于块的编码的一个特殊特征是偶然产生可见的块结构。块边缘通常以低于内部像素的精度重建，块通常被认为是当前压缩方法中最明显的伪影之一。为此，H.264/AVC 定义了一种自适应的环路去块滤波器，其中滤波的强度由若干语法元素的值控制。有关自适应去块滤波器的详细说明，请参阅<a href="">Adaptive deblocking filter</a>;</p>

  <p>图 16 给出了使用一维边缘的可视化的去块滤波器的原理。样本 p0 和 q0 以及 p1 和 q1 是否被滤波取决于使用的量化参数(QP)和量化阈值α(QP)和β(QP)。因此，仅当满足以下每个条件时，才进行 p0 和 q0 的滤波：<br />
1. |p0 - q0 | &lt; α(QP) <br />
2. |p1 - p0 | &lt; β(QP)<br />
3. |q1 - q0 | &lt; β(QP) <br />
其中 β(QP) 比 α(QP) 小的多。如果满足相应的以下条件，则进行 p1 或 q1 的滤波： |p2 - p0| &lt; β(QP) 或者 |q2 - q0| &lt; β(QP)</p>

  <p>基本思想是，如果测量块边缘附近的样本之间相对较大的绝对差，则很可能是块伪影，因此应减少。然而，如果该差异的幅度太大以致不能用编码中使用的量化的粗糙度来解释，则边缘更可能反映源图片的实际行为，并且不应被平滑。</p>

  <p>块效应降低，而内容的锐化程度基本不变。因此，主观质量显著提高。滤波器通常将比特率降低 5%-10%，同时产生与未滤波视频相同的客观质量。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intra-frame Prediction Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/05/26/intra-frame-algorithm/"/>
    <updated>2021-05-26T07:38:25-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/05/26/intra-frame-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#intra-frame-prediction-elements" id="markdown-toc-intra-frame-prediction-elements">Intra-Frame Prediction Elements</a></li>
  <li><a href="#the-existing-intra-frame-prediction-algorithm-flows-and-questions" id="markdown-toc-the-existing-intra-frame-prediction-algorithm-flows-and-questions">The Existing Intra-Frame Prediction Algorithm Flows And Questions</a></li>
</ul>

<p>本论文详细分析了帧内预测算法的原则和流程，同时提出了一个提升算法，并阐述了优势。通过实现关于H.264/AVC的标准和和应用实验，证明算法具有实用价值和促进作用。</p>

<p>“Intra-frame Prediction Algorithm Based on the H.264/AVC Research and Improvement”</p>

<!--more-->

<h2 id="introduction">Introduction</h2>

<p>在帧内编码的过程中，有很多帧内预测模式已被采用提高效率。通过这种方法，空间图像信息的冗余将被删除。亮度预测被分为四个部分，它们分别是 4x4 帧内预测、16x16 帧内预测、8x8 帧内预测和 I-PCM 模式。</p>

<p>4x4 模式用于小的预测宏块，来处理详细而复杂的图像。在图像编码中，处理平坦区域使用更大的宏块的帧内 16x16 模式。I-PCM 模式是一个特别模式，它在特殊情况下使用，当原始数据直接传输比预测编码传输还要低时使用。帧内 8x8 预测用于高清，这个是在 2005 年提出的预测。拉格朗日 RD 模型，决定在正确的时间选择。</p>

<h2 id="intra-frame-prediction-elements">Intra-Frame Prediction Elements</h2>

<p>帧内预测编码使用图像信息字段的相关性以压缩冗余。它基于在宏块的边界上，主要是指左边宏块、上方宏块和右方宏块来预测当前宏块。之后进行 DCT 和量化，从而达到压缩编码的目的。</p>

<p>在编码过程中，有时需要根据具体的算法和 RDO 模型来选择最终成本最低的预测模式。</p>

<p>16x16 亮度采用垂直预测(模型 0)、水平预测(模型 1)、DC 预测(模型 2)、平面预测(模型 3)。这些预测模式均小于 4x4 亮度。通过 16x16 宏块通常是应用到简单的场景，并且没有很多细节。因此不需要支持多个纹理预测，亮度很可能与预测模式不同，唯一的区别是模型码。</p>

<p>为了减少标准中 4x4 预测模式差异带来的额外信息，采用了一种将帧内预测信息转换为信号模式的方法，从而实现基本信息压缩。</p>

<h2 id="the-existing-intra-frame-prediction-algorithm-flows-and-questions">The Existing Intra-Frame Prediction Algorithm Flows And Questions</h2>

<p>对一对 16x16 亮度和两个 8x8 亮度宏块的 RDO 帧内预测模式的完全搜索如下：</p>

<p>1).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H264 Motion Estimation Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/05/17/h264-motion-estimation-algorithm/"/>
    <updated>2021-05-17T07:54:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/05/17/h264-motion-estimation-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">整数像素运动估计</a>    <ul>
      <li><a href="#diamond-search-algorithm" id="markdown-toc-diamond-search-algorithm">钻石搜索算法(Diamond Search Algorithm)</a></li>
      <li><a href="#hexagon-search-algorithm" id="markdown-toc-hexagon-search-algorithm">六边形搜索算法(Hexagon Search Algorithm)</a></li>
      <li><a href="#uneven-multi-hexagon-grid-search-algorithm" id="markdown-toc-uneven-multi-hexagon-grid-search-algorithm">非对称交叉多层次六边形网格搜索算法(Uneven Multi-hexagon-grid Search Algorithm)</a>        <ul>
          <li><a href="#umh-the-proposed-algorithm-for-umh" id="markdown-toc-umh-the-proposed-algorithm-for-umh">UMH 优化思路(The Proposed Algorithm For UMH)</a>            <ul>
              <li><a href="#search-range-decision-for-uneven-cross-pattern" id="markdown-toc-search-range-decision-for-uneven-cross-pattern">Search Range Decision for Uneven Cross Pattern</a></li>
              <li><a href="#optimize-for-multi-hexagon-grid-search" id="markdown-toc-optimize-for-multi-hexagon-grid-search">Optimize for Multi-hexagon-grid Search</a></li>
              <li><a href="#optimize-for-iterative-hexagon-search" id="markdown-toc-optimize-for-iterative-hexagon-search">Optimize for Iterative Hexagon Search</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">分数像素运动估计</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">亚像素搜索算法</a></li>
    </ul>
  </li>
</ul>

<p>运动估计是在参考帧中为当前编码的宏块寻找最佳匹配快，找到最佳匹配块后，运动估计会输出是运动矢量。</p>

<!--more-->

<p>运动估计的下一步是运动补偿(Motion Compensation)，即从当前块中减去匹配块得到残差块。在整个编码过程中，运动估计耗时占了整个编码过程的60%-80%不等，因此，对运动估计的优化是实现视频实时应用的关键。</p>

<p>H264 中运动估计的过程分为两步：1. 整数像素精度的估计。2. 分数像素级精度的估计。其中整数像素级的运动估计包括两类算法：全搜索算法、快速搜索算法(DIA/HEX/UMH)。</p>

<p>几个运动估计中用到的缩写：</p>

<ul>
  <li>MV: 运动矢量。被用来表示一个宏块基于该宏块中的另一个图像的位置。</li>
  <li>MVP:预测运动矢量。</li>
  <li>MVD：两个运动矢量的差值。</li>
  <li>SATD(Sum of Absolute Transformed Difference):即 hadamard 变换后再绝对值求和。</li>
  <li>SSD(Sum of Squared Difference) = SSE(Sum of Squared Error) 即差值的平方和。</li>
  <li>MAD(Mean Absolute Difference) = MAE(Mean Absolute Error) 即平均绝对差值。</li>
  <li>MSD(Mean Squared Difference) = MSE(Mean Squared Error) 即平均平方误差。</li>
</ul>

<h1 id="section">整数像素运动估计</h1>

<h2 id="diamond-search-algorithm">钻石搜索算法(Diamond Search Algorithm)</h2>

<p>钻石搜索算法有两种搜索模式： 大钻石搜索算法(LDSP)和小钻石搜索算法(SDSP)。大钻石搜索算法有 9 个搜索点，小钻石搜索算法有 5 个搜索点。</p>

<p>钻石搜索的步骤是：先使用 LDSP 进行搜索，直到最佳匹配点位于大菱形的中心位置；之后使用小菱形搜索，直至最佳匹配点位于小菱形的中心位置。</p>

<ul>
  <li>LDSP:</li>
</ul>

<ol>
  <li>从中心搜索位置开始，设置步长 S = 2</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>使用钻石搜索点图案搜索 8 个位置像素(X, Y), 以使(</td>
          <td>x</td>
          <td>+</td>
          <td>Y</td>
          <td>= S) 围绕位置 (0, 0)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>从搜索到的 9 个地点中选择，其中一个地点的费用最低</li>
  <li>如果在搜索窗口的中心找到了最小重量，请转到 SDSP 步骤</li>
  <li>如果在除中心以为的 8 个位置之一中找到最小重量，则将新的原点设置为此位置</li>
  <li>重复 LDSP</li>
</ol>

<ul>
  <li>SDSP：</li>
</ul>

<ol>
  <li>设置新的搜索原点</li>
  <li>将新步长设置为 S = S / 2</li>
  <li>重复搜索过程以找到重量最轻的位置</li>
  <li>选择权重最小的位置作为运动矢量权重最小的运动矢量位置。</li>
</ol>

<p><img src="http://lazybing.github.io/images/h264_me/diamond_search.png" title="'H264 Motion Estimation Diamond Search'" /></p>

<p>上图可以看出，LDSP 又可分为两种模式，LDSP(1) 中的两个菱形，有 4 个重合点；LDSP(2) 中的两个菱形，有 6 个重合点。不重复计算这些点，可以节省运算复杂度。</p>

<p>SDSP 中, 4 个菱形的角距离中心点距离相等，因此 SDSP(1) 和 SDSP(2) 可以看出是一种模式。两个临近的搜索菱形，有 2 个重合点，不重复计算这些点，同样可以节省运算复杂度。</p>

<p>x264 中只采用了钻石搜索里的小钻石搜索算法, 搜索半径为 1。 具体代码实现如下:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//diamond search, radius 1</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span>
</span><span class="line"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i_me_range</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">COST_MV_X4_DIR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">costs</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">))</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmx</span> <span class="o">-=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmy</span> <span class="o">-=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
</span><span class="line">    <span class="n">bcost</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">15</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&amp;&amp;</span><span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span><span class="p">));</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意：这段代码写的比较 trick，先把 bcost 左移四位，留出的最后四位，每一位都代表一个搜索点，初始化时，默认菱形中心点为最佳匹配点。若菱形周边点 cost 更小，就将该点作为中心点继续进行菱形搜索，直到最佳匹配点确为中心点，跳出循环。</p>

<p>这段代码的速度优化空间，正如上面分析的那样，可以避开两个相邻菱形的搜索重叠搜索点。</p>

<h2 id="hexagon-search-algorithm">六边形搜索算法(Hexagon Search Algorithm)</h2>

<p>所谓的六边形搜索算法，不止包括六边形搜索(搜索半径为 2)，还有小菱形搜索和正方形搜索(搜索半径为 1)两种。</p>

<p><img src="http://lazybing.github.io/images/h264_me/Hexagon_Search_Algorithm.png" title="'H264 Motion Estimation Hexagon Search'" /></p>

<p>六边形搜索算法采用 1 个大模板(六边形模板)和 2 个小模板（小菱形模板和小正方形模板），具体步骤如下：</p>

<ol>
  <li>
    <p>以搜索起点为中心，采用上图中左边的六边形模板进行搜索。计算区域中心及周围 6 个点处的匹配误差并比较，如最小 MBD 点位于模板中心点，则转至步骤 2；否则以上一次的 MBD 点作为中心点，以六边形模板为模板进行反复搜索。</p>
  </li>
  <li>
    <p>以上一次的 MBD 点为中心点，采用小菱形模板搜索和小正方形模板搜索，计算各点的匹配误差，找到 MBD点, 即为最优匹配点。</p>
  </li>
</ol>

<p>从上图中的六边形搜索可以看出，两个临近的六边形，有三个重叠搜索点，因此，可以通过减少重复计算，来提升搜索性能。事实上，x264 中已经采用了这种优化方法。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* equivalent to the above, but eliminates duplicate candidates */</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* hexagon */</span>
</span><span class="line"><span class="n">COST_MV_X3_DIR</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">costs</span>   <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X3_DIR</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">costs</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span> <span class="cm">/* +4 for 16-byte alignment */</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">6</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span> <span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmx</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="n">bmy</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* half hexagon, not overlapping the previous iteration */</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span><span class="p">);</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">COST_MV_X3_DIR</span><span class="p">(</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">costs</span> <span class="p">);</span>
</span><span class="line">        <span class="n">bcost</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="n">dir</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="n">dir</span> <span class="o">=</span> <span class="n">mod6m1</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">bmx</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">        <span class="n">bmy</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* square refine */</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line"><span class="n">COST_MV_X4_DIR</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">costs</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4_DIR</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">costs</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">6</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span> <span class="p">);</span>
</span><span class="line"><span class="n">bmx</span> <span class="o">+=</span> <span class="n">square1</span><span class="p">[</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line"><span class="n">bmy</span> <span class="o">+=</span> <span class="n">square1</span><span class="p">[</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="uneven-multi-hexagon-grid-search-algorithm">非对称交叉多层次六边形网格搜索算法(Uneven Multi-hexagon-grid Search Algorithm)</h2>

<p>运动估计中，起始搜索点和提前终止技术非常重要。</p>

<p>UMH 算法是基于 MV 具有时空相关性，因此可以结合上一帧和上一步中 MV 的方向和角度，来修改多层六边形的形状。</p>

<p>UMH 算法包含四中搜索模式:不均匀交叉搜索、多六边形网格搜索、迭代六边形搜索、菱形搜索。主要流程步骤如下:</p>

<p><img src="http://lazybing.github.io/images/h264_me/umhexagon.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<ol>
  <li>
    <p>选取合适的搜索起点。有以下几种起点的选择。</p>

    <p>①  mvp: 由于还是整像素搜索，所以这里对 MVP 取整，得到的整数的 mv 后采用小菱形搜索以得到比较优秀的 mv。② 原点：即 mv 为0，即当前块的位置。
 ③  上层块 mv。④ 共同位置块 mv，取上一参考图像与当前块相同位置的块为 mv，然后取整。⑤  共同位置参考 mv 通过参考图像距离计算后得到的 mv，然后取整。</p>
  </li>
  <li>
    <p>小菱形搜索和中菱形搜索。</p>

    <p>首先对中值 MV 和(0, 0)点进行小钻石搜索，计算出每个搜索点的 SAD 值，并找出新的 MBD 搜索点。如果新的 MBD 点的 SAD 值比门限1 的值(2000)还要大，就执行 Step4，否则继续。</p>

    <p>对搜索点进行中钻石搜索，来找出新的 MBD 搜索点。若 SAD 值小于门限值2(500)，停止搜索。否则继续。</p>
  </li>
  <li>
    <p>对称交叉搜索和六边形搜索。</p>

    <p>对上一步中找到的新的 MBD 搜索点，执行对称交叉搜索(半径为 7)和六边形搜索(半径为 2),计算这 20 个点的 SAD 值，并且找出本步最新的 MBD 点。</p>

    <p>如果该步找到的 MBD 点与上一步中的 MBD 点吻合，停止搜索。否则继续。</p>
  </li>
  <li>
    <p>非对称交叉搜索。执行非对称的交叉搜索，找到最新的 MBD 点。</p>
  </li>
  <li>
    <p>5x5搜索和多六边形网格搜索。执行 5x5 全搜索和多六边形网格搜索。</p>
  </li>
  <li>
    <p>迭代六边形搜索。设置上步中的 MBD 点作为搜索中心，执行迭代六边形搜索。</p>
  </li>
</ol>

<p>x264 中关于 UMH 算法的代码如下</p>

<figure class="code"><figcaption><span>X264_ME_UMH </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">        <span class="k">case</span> <span class="nl">X264_ME_UMH</span><span class="p">:</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="cm">/* Uneven-cross Multi-Hexagon-grid Search</span>
</span><span class="line"><span class="cm">             * as in JM, except with different early termination */</span>
</span><span class="line">
</span><span class="line">            <span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">pixel_size_shift</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class="line">
</span><span class="line">            <span class="kt">int</span> <span class="n">ucost1</span><span class="p">,</span> <span class="n">ucost2</span><span class="p">;</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">cross_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* refine predictors */</span>
</span><span class="line">            <span class="n">ucost1</span> <span class="o">=</span> <span class="n">bcost</span><span class="p">;</span>
</span><span class="line">            <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="n">pmx</span><span class="p">,</span> <span class="n">pmy</span> <span class="p">);</span> <span class="c1">//1. 小菱形搜索算法用于median MV, the small diamond search</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">pmx</span> <span class="o">|</span> <span class="n">pmy</span> <span class="p">)</span>
</span><span class="line">                <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">//1. 小菱形搜索算法用于(0, 0), the small diamond search</span>
</span><span class="line">
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">==</span> <span class="n">PIXEL_4x4</span> <span class="p">)</span>
</span><span class="line">                <span class="k">goto</span> <span class="n">me_hex2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="n">ucost2</span> <span class="o">=</span> <span class="n">bcost</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">bmx</span> <span class="o">|</span> <span class="n">bmy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">bmx</span><span class="o">-</span><span class="n">pmx</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bmy</span><span class="o">-</span><span class="n">pmy</span><span class="p">))</span> <span class="p">)</span>
</span><span class="line">                <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span> <span class="p">);</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                <span class="n">cross_start</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">            <span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* early termination */</span>
</span><span class="line"><span class="cp">#define SAD_THRESH(v) ( bcost &lt; ( v &gt;&gt; pixel_size_shift[i_pixel] ) )</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="o">&amp;&amp;</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span> <span class="p">);</span> <span class="c1">//2. 中菱形搜索算法，找出新的MBD, the middle diamond search point</span>
</span><span class="line">                <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="mi">2</span> <span class="p">);</span> <span class="c1">//2. 中菱形搜索算法，找出新的MBD, the middle diamond search point</span>
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost1</span> <span class="o">&amp;&amp;</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">                    <span class="k">break</span><span class="p">;</span>
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                    <span class="n">CROSS</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">range</span> <span class="p">);</span> <span class="c1">//3. 对称的交叉搜索, symmetric cross search(radius 7)</span>
</span><span class="line">                    <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <span class="c1">//3. 六边形搜索，octagon search(radius 2)</span>
</span><span class="line">                    <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">//3. 六边形搜索，octagon search(radius 2)</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                        <span class="k">break</span><span class="p">;</span>
</span><span class="line">                    <span class="n">cross_start</span> <span class="o">=</span> <span class="n">range</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* adaptive search range */</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">i_mvc</span> <span class="p">)</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="cm">/* range multipliers based on casual inspection of some statistics of</span>
</span><span class="line"><span class="cm">                 * average distance between current predictor and final mv found by ESA.</span>
</span><span class="line"><span class="cm">                 * these have not been tuned much by actual encoding. */</span>
</span><span class="line">                <span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">range_mul</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">},</span>
</span><span class="line">                <span class="p">};</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">mvd</span><span class="p">;</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">sad_ctx</span><span class="p">,</span> <span class="n">mvd_ctx</span><span class="p">;</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">i_mvc</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">==</span> <span class="n">PIXEL_16x16</span> <span class="p">)</span>
</span><span class="line">                        <span class="cm">/* mvc is probably the same as mvp, so the difference isn&#39;t meaningful.</span>
</span><span class="line"><span class="cm">                         * but prediction usually isn&#39;t too bad, so just use medium range */</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span><span class="line">                    <span class="k">else</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">                            <span class="o">+</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="cm">/* calculate the degree of agreement between predictors. */</span>
</span><span class="line">                    <span class="cm">/* in 16x16, mvc includes all the neighbors used to make mvp,</span>
</span><span class="line"><span class="cm">                     * so don&#39;t count mvp separately. */</span>
</span><span class="line">                    <span class="n">denom</span> <span class="o">=</span> <span class="n">i_mvc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                    <span class="n">mvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">!=</span> <span class="n">PIXEL_16x16</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">                            <span class="o">+</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">                        <span class="n">denom</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                    <span class="n">mvd</span> <span class="o">+=</span> <span class="n">x264_predictor_difference</span><span class="p">(</span> <span class="n">mvc</span><span class="p">,</span> <span class="n">i_mvc</span> <span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="n">sad_ctx</span> <span class="o">=</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">4000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">                <span class="n">mvd_ctx</span> <span class="o">=</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">0</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">1</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="n">i_me_range</span> <span class="o">=</span> <span class="n">i_me_range</span> <span class="o">*</span> <span class="n">range_mul</span><span class="p">[</span><span class="n">mvd_ctx</span><span class="p">][</span><span class="n">sad_ctx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* FIXME if the above DIA2/OCT2/CROSS found a new mv, it has not updated omx/omy.</span>
</span><span class="line"><span class="cm">             * we are still centered on the same place as the DIA2. is this desirable? */</span>
</span><span class="line">            <span class="n">CROSS</span><span class="p">(</span> <span class="n">cross_start</span><span class="p">,</span> <span class="n">i_me_range</span><span class="p">,</span> <span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">);</span> <span class="c1">//4. 非对称交叉搜索, an uneven cross search</span>
</span><span class="line">
</span><span class="line">            <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span> <span class="p">);</span> <span class="c1">//5. 5x5 search</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* hexagon grid */</span>
</span><span class="line">            <span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">p_cost_omvx</span> <span class="o">=</span> <span class="n">p_cost_mvx</span> <span class="o">+</span> <span class="n">omx</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">p_cost_omvy</span> <span class="o">=</span> <span class="n">p_cost_mvy</span> <span class="o">+</span> <span class="n">omy</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">            <span class="k">do</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="k">static</span> <span class="k">const</span> <span class="kt">int8_t</span> <span class="n">hex4</span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">//5. 多六边形网格搜索, multi-hexagon-grid search</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span><span class="line">                <span class="p">};</span>
</span><span class="line">
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">X264_MIN4</span><span class="p">(</span> <span class="n">mv_x_max</span><span class="o">-</span><span class="n">omx</span><span class="p">,</span> <span class="n">omx</span><span class="o">-</span><span class="n">mv_x_min</span><span class="p">,</span>
</span><span class="line">                                     <span class="n">mv_y_max</span><span class="o">-</span><span class="n">omy</span><span class="p">,</span> <span class="n">omy</span><span class="o">-</span><span class="n">mv_y_min</span> <span class="p">)</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">omx</span> <span class="o">+</span> <span class="n">hex4</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">                        <span class="kt">int</span> <span class="n">my</span> <span class="o">=</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">hex4</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">                        <span class="k">if</span><span class="p">(</span> <span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">                            <span class="n">COST_MV</span><span class="p">(</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="p">);</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                    <span class="n">pixel</span> <span class="o">*</span><span class="n">pix_base</span> <span class="o">=</span> <span class="n">p_fref_w</span> <span class="o">+</span> <span class="n">omx</span> <span class="o">+</span> <span class="p">(</span><span class="n">omy</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">stride</span><span class="p">;</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">stride</span><span class="p">;</span>
</span><span class="line"><span class="cp">#define SADS(k,x0,y0,x1,y1,x2,y2,x3,y3)\</span>
</span><span class="line"><span class="cp">                    h-&gt;pixf.fpelcmp_x4[i_pixel]( p_fenc,\</span>
</span><span class="line"><span class="cp">                            pix_base x0*i+(y0-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x1*i+(y1-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x2*i+(y2-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x3*i+(y3-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            stride, costs+4*k );\</span>
</span><span class="line"><span class="cp">                    pix_base += 2*dy;</span>
</span><span class="line"><span class="cp">#define ADD_MVCOST(k,x,y) costs[k] += p_cost_omvx[x*4*i] + p_cost_omvy[y*4*i]</span>
</span><span class="line"><span class="cp">#define MIN_MV(k,x,y)     COPY2_IF_LT( bcost, costs[k], dir, x*16+(y&amp;15) )</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">+</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="cp">#undef SADS</span>
</span><span class="line"><span class="cp">#undef ADD_MVCOST</span>
</span><span class="line"><span class="cp">#undef MIN_MV</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">dir</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="n">bmx</span> <span class="o">=</span> <span class="n">omx</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">dir</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">);</span>
</span><span class="line">                        <span class="n">bmy</span> <span class="o">=</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">((</span><span class="n">dir</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">28</span><span class="p">);</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">++</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bmy</span> <span class="o">&lt;=</span> <span class="n">mv_y_max</span> <span class="o">&amp;&amp;</span> <span class="n">bmy</span> <span class="o">&gt;=</span> <span class="n">mv_y_min</span> <span class="o">&amp;&amp;</span> <span class="n">bmx</span> <span class="o">&lt;=</span> <span class="n">mv_x_max</span> <span class="o">&amp;&amp;</span> <span class="n">bmx</span> <span class="o">&gt;=</span> <span class="n">mv_x_min</span> <span class="p">)</span>
</span><span class="line">                <span class="k">goto</span> <span class="n">me_hex2</span><span class="p">;</span>   <span class="c1">//6. iterative hexagon search</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="umh-the-proposed-algorithm-for-umh">UMH 优化思路(The Proposed Algorithm For UMH)</h3>

<p>由于视频帧间具有时间相关性，大多数视频序列，当前宏块的方向与上一帧中相同位置宏块的方向高度相关。这意味着连续帧间，运动矢量有高度一致性。因此，当前宏块的运动方向可以通过之前帧对应坐标的方向来预测。基于运动方向预测，不同形状的搜索模式应用到 UMH 搜索模式。目标就是提升估计的运行时间，同时获得相同的质量。</p>

<p>方向可以通过运动矢量的角度来度量，可以使用如下公式：arcsin(-y / sqrt(x^2 + y^2)) * 180 / π 。</p>

<p>下面提出的算法使用上一帧中相同坐标块的运动矢量动态设置搜索非对称搜索模式的搜索长度，决定多六边形网格搜索的四分之一模式。同时，它根据上一步的方向来设计迭代六边形搜索模式。</p>

<h4 id="search-range-decision-for-uneven-cross-pattern">Search Range Decision for Uneven Cross Pattern</h4>

<p>在大多数视频序列中，水平方向上的运动要比垂直方向上的运动更加剧烈。正如上面提到的非对称交叉搜索中，水平方向上的长度是垂直方向上的长度的两倍。</p>

<p>在某些特殊的视频序列中，垂直方向上的运动比水平方向上的运动更加剧烈。因此我们可以动态的设置非对称交叉搜索模式的长度，来确保运动估计的质量。</p>

<p>基于连续帧的相关性，我们可以使用上一帧中相同坐标块的 MV（pmv）来预测当前块的的运动矢量，并且设置非对称交叉搜索模式的长度。如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">if (pmv.dx &gt; 2 * pmv.dy)
</span><span class="line">    PATTERN_SEARCH(CROSS1, 21, 1) //an uneven cross search: search length in vertical direction is 15 and in horizontal direction is 7.
</span><span class="line">else if (pmv.dy &gt; 2 * pmv.dx)
</span><span class="line">    PATTERN_SEARCH(CROSS2, 21, 1) //an uneven cross search: search length in vertical direction is 7 and in horizontal direction is 15.
</span><span class="line">else
</span><span class="line">    PATTERN_SEARCH(CROSS3, 21, 1) //an uneven cross search: search length in vertical direction is the same as in horizontal direction.</span></code></pre></td></tr></table></div></figure>

<h4 id="optimize-for-multi-hexagon-grid-search">Optimize for Multi-hexagon-grid Search</h4>

<p>多六边形网格搜索包括两部分：5x5 搜索和多六边形网格搜索。</p>

<p>大多数真实世界的视频序列都有中心偏移运动矢量分布。有超过 80% 的运动矢量在 5x5 区域的预测内，而有 70% 的运动矢量在 3x3 区域的预测内。尽管 5x5 的区域，比 3x3 的区域有更高(10%)的预测概率,但是搜索点的数量是它的 3 倍之多。因此我们选择 3x3 搜索而不是 5x5 搜索。</p>

<p>x264 中已经对 5x5 全搜索做了优化，甚至比上面提到的优化，还要更加彻底，x264 中关于 5x5 的全搜索，仅检查 4 个搜索点。它的代码更新迭代过程如下：</p>

<figure class="code"><figcaption><span>5x5_ESA </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/*5x5 ESA method 1*/</span>
</span><span class="line"><span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">square2</span><span class="p">[</span><span class="mi">24</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">    <span class="n">COST_MV</span><span class="p">(</span><span class="n">omx</span> <span class="o">+</span> <span class="n">square2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">square2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line">
</span><span class="line"><span class="cm">/*5x5 ESA method 2*/</span>
</span><span class="line"><span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">!=</span> <span class="n">ucost2</span><span class="p">)</span>
</span><span class="line">    <span class="n">COST_MV_X4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="cm">/*optimize 5x5 ESA method 3*/</span>
</span><span class="line"><span class="n">COST_MV_x4</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>第二部分是多六边形网格搜索，它有 64 个点需要检查。在此步骤中，我们根据当前宏块的运动方向预测，设计了 4 种模式，它有 20 个搜索点需要检查，这回极大的降低计算复杂度。算法描述如下：</p>

<p><img src="http://lazybing.github.io/images/h264_me/multi_hexagon_grid.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<p>计算 pmv(x, y)的角度α：</p>

<p>a) 如果 α = 0-90，寻找 20 个搜索点，如图3(b),并找到新的 MBD，之后处理第 6 步<br />
b) 如果 α = 90-180，寻找 20 个搜索点，如图3(c),并找到新的 MBD，之后处理第 6 步<br />
c) 如果 α = 180-270，寻找 20 个搜索点，如图3(d),并找到新的 MBD，之后处理第 6 步<br />
d) 如果 α = -90-0，寻找 20 个搜索点，如图3(e),并找到新的 MBD，之后处理第 6 步</p>

<p>x264 中并没有进行此项优化，此处可能有一个搜索优化空间。</p>

<h4 id="optimize-for-iterative-hexagon-search">Optimize for Iterative Hexagon Search</h4>

<p>第六步是迭代六边形搜索模式，设置第五步中的 MBD 点作为搜索中心，最开始有 7 个点需要检查。然后在搜索过程中，六边形搜索不断前进，中心移动到六个端点中的任何一个。每次总是有三个新的点出现，而其他三个点是重复的。该算法根据前一步的方向设计新的六边形图案，避免了重复搜索冗余点。对第 6 步的优化过程如下：</p>

<p><img src="http://lazybing.github.io/images/h264_me/iterative_hexagon.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<p>步骤6-1：</p>

<p>图4(a) 所示的六边形位于步骤 5 的 MBD 点的中心。如果在本步骤中找到的 MBD 点仍然与在上一步中找到的 MBD 点一致，则转至步骤6-3；否则计算上一步方向的角度，进行下一步处理。</p>

<p>a) 如果 α = 0-90,如图4(b)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
b) 如果 α = 90-180,如图4(c)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
a) 如果 α = 180-270,如图4(d)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
a) 如果 α = -90-0,如图4(e)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。</p>

<p>步骤6-2：</p>

<p>以上一步搜索的 MBD 点为中心，形成一个新的六边形。检查三个新的候选点，再次确定 MBD 点。如果 MBD 仍然与上一步中发现的 MBD 点重合，则转至步骤6-3；否则，如果 4 所示重复此步骤。</p>

<p>步骤6-3：</p>

<p>将搜索模式从六边形切换到小尺寸的六边形搜索。将检查基于角度评估的两个候选点。先的 MBD 点是运动矢量的最终解。</p>

<p>图 4(f) 显示了该方法的一个例子。</p>

<p>X264 中已经采用了此种优化方法，实现代码就是上一种的 X264_ME_HEX 代码。</p>

<h1 id="section-1">分数像素运动估计</h1>

<h2 id="section-2">亚像素搜索算法</h2>

<p>当整数像素搜索算法优化完毕后，亚像素搜索算法的时间占比就会提升，此时对亚像素搜索算法的优化，就不能忽视了。</p>

<H.264 标准="">中规定，运动估计为1/4像素精度，因此在 H.264 编码和解码的过程中，需要将画面中的像素进行插值——简单地说就是把原先的 1 个像素点拓展成 4x4 一共 16 个点。

下图显示了  H.264 编码和解码过程中像素插值情况。可以看出原先的 G 点的右下方通过插值的方式产生了 a、b、c、d 等一共 16 个点。  

<img src="http://lazybing.github.io/images/h264_me/Interpolation_of_luma_half-pel.PNG" title="'H264 Motion Estimation UMHexagonS Search'" />    

如图所示，1/4 像素内插一般分成两成：1. 半像素内插。这一步通过 6 抽头滤波器获得 5 个半像素点。2. 线性内插。这一步通过简单的线性内插获得剩余的 1/4 像素点。   

<img src="http://lazybing.github.io/images/h264_me/Interpolation_of_luma_quanter-pel.PNG" title="'H264 Motion Estimation UMHexagonS Search'" />   

图中半像素内插点为 b、m、h、s、j五个点。半像素内插方法是对整像素点进行 6 抽头滤波得到，滤波器的权重为(1/32, -5/32, 5/8, 5/8, -5/32, 1/32)。例如 b 的计算公式为： `b = round((E - 5F + 20G + 20H - 5I + J)/32)`。  

剩下几个半像素点的计算关系如下：

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">m: 由 B、D、H、N、S、U计算  
</span><span class="line">h：由A、C、G、M、R、T计算  
</span><span class="line">s：由K、L、M、N、P、Q计算  
</span><span class="line">j：由cc、dd、h、m、ee、ff计算。 
</span><span class="line">需要注意j点的运算量比较大，因为cc、dd、ee、ff都需要通过半像素内插方法进行计算。</span></code></pre></td></tr></table></div></figure>
在获得半像素点之后，就可以通过简单的线性内插获得 1/4 像素内插点了。1/4 像素内插的方式如下图所示。例如图中 a 点的计算公式如下： `A = round((G + b) / 2)`

在这里有一点需要注意： 位于 4 个角的 e、g、p、r 四个点并不是通过j 点计算的，而是通过b、h、s、m四个半像素点计算的。


</H.264>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacking VMAF With Video Color and Contrast Distortion]]></title>
    <link href="http://lazybing.github.io/blog/2020/06/30/hack-vmaf/"/>
    <updated>2020-06-30T04:57:24-07:00</updated>
    <id>http://lazybing.github.io/blog/2020/06/30/hack-vmaf</id>
    <content type="html"><![CDATA[
<p>视频质量测量在许多应用中占有重要的地位。全参考质量指标(通常被用在视频编解码比较中)将反映视频中的任何变换。在这篇文章中，我们考虑经过不同颜色校正的压缩视频，它会增加全参考度量 VMAF，同时，几乎不减少其他广泛使用的度量 SSIM。所提出的视频对比度增强方法显示了该度量在某些情况下，对视频编解码器比较的适用性，因为它可以通过调整来改进该度量值，从而在比较中作弊。</p>

<p><strong>关键字</strong>：<strong>视频质量</strong>、<strong>质量度量</strong>、<strong>视频编解码压缩</strong>、<strong>质量调节</strong>、<strong>参考特征</strong>、<strong>颜色校正</strong></p>

<!--more-->

<p>未完待续</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序链接(Program Linking)]]></title>
    <link href="http://lazybing.github.io/blog/2020/06/25/program-linking/"/>
    <updated>2020-06-25T15:22:39-07:00</updated>
    <id>http://lazybing.github.io/blog/2020/06/25/program-linking</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">链接示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">静态链接</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">目标文件</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">可重定位目标文件</a>    <ul>
      <li><a href="#section-4" id="markdown-toc-section-4">符号和符号表</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">符号解析</a>        <ul>
          <li><a href="#section-6" id="markdown-toc-section-6">链接器如何解析多重定义的全局符号</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">与静态库链接</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">链接器如何使用静态库来解析引用</a></li>
        </ul>
      </li>
      <li><a href="#section-9" id="markdown-toc-section-9">重定位</a>        <ul>
          <li><a href="#section-10" id="markdown-toc-section-10">重定位条目</a></li>
          <li><a href="#section-11" id="markdown-toc-section-11">重定位符号引用</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-12" id="markdown-toc-section-12">可执行目标文件</a></li>
  <li><a href="#section-13" id="markdown-toc-section-13">共享目标文件</a></li>
  <li><a href="#section-14" id="markdown-toc-section-14">处理目标文件的工具</a></li>
</ul>

<p><strong>链接</strong>是将各种代码和数据片段收集并组合成一个单一文件的过程，该文件可以被加载到内存并执行。理解链接的几个好处有：</p>

<!--more-->

<ul>
  <li>理解链接器将帮助你构造大型程序。</li>
  <li>理解链接器将帮助你避免一些危险的编程错误。</li>
  <li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
  <li>理解链接器将帮助你理解其他重要的系统概念。</li>
  <li>理解链接器将使你能够利用共享库</li>
</ul>

<p>下面会介绍静态链接、加载时的共享库的动态链接、运行时的共享库动态链接等方面。</p>

<h2 id="section">链接示例</h2>

<p>通常说的编译程序包括如下四个方面：预处理(cpp)、编译(ccl)、汇编(as)、链接(ld)。比如，有如下 main.c 和 sum.c 两个文件。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int sum(int *a, int n);
</span><span class="line">
</span><span class="line">int array[2] = {1, 2};
</span><span class="line">
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int val = sum(array, 2);
</span><span class="line">    return val;
</span><span class="line">}
</span><span class="line">
</span><span class="line">int sum(int *a, int n)
</span><span class="line">{
</span><span class="line">    int i, s = 0;
</span><span class="line">    
</span><span class="line">    for (i = 0; i &lt; n; i++) {
</span><span class="line">        s += a[i];
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return s;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>编译命令：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc -Og -o prog main.c sum.c 或
</span><span class="line">$gcc -Og -v -o prog main.c sum.c</span></code></pre></td></tr></table></div></figure>

<p>对上面的源文件进行如下操作:</p>

<p>main.c—&gt;预处理(cpp)—&gt;main.i—&gt;编译器(ccl)—&gt;main.s—&gt;汇编器(as)—&gt;main.o<br />
sum.c—-&gt;预处理(cpp)—&gt;sum.i—-&gt;编译器(ccl)—&gt;sum.s—-&gt;汇编器(as)—&gt;sum.o<br />
main.o + sum.o—&gt;链接器(ld)—&gt;prog</p>

<h2 id="section-1">静态链接</h2>

<p>静态链接以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行可执行目标文件作为输出。</p>

<p>为构造可执行文件，链接器主要完成两项任务：</p>

<ul>
  <li><strong>符号解析。</strong> 符号解析的目的是使得目标文件中符号的定义和引用匹配起来。例如引用一个函数名符号时，符号解析的功能就是找到函数的引用和定义，并将其匹配起来。</li>
  <li><strong>重定位。</strong> 由编译器和汇编器生成的 .code 和 .data 节，都是从地址 0 开始的。链接器通过将每个符号定义为一个与内存关联起来，完成重定位，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class=""><span class="line">main.o:     file format elf64-x86-64
</span><span class="line">Disassembly of section .text:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;main&gt;:
</span><span class="line">   0:	55                   	push   %rbp
</span><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp
</span><span class="line">   4:	48 83 ec 10          	sub    $0x10,%rsp
</span><span class="line">   8:	be 02 00 00 00       	mov    $0x2,%esi
</span><span class="line">   d:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 14 &lt;main+0x14&gt;
</span><span class="line">  14:	e8 00 00 00 00       	callq  19 &lt;main+0x19&gt;
</span><span class="line">  19:	89 45 fc             	mov    %eax,-0x4(%rbp)
</span><span class="line">  1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
</span><span class="line">  1f:	c9                   	leaveq 
</span><span class="line">  20:	c3                   	retq   
</span><span class="line">  
</span><span class="line">sum.o:     file format elf64-x86-64
</span><span class="line">
</span><span class="line">Disassembly of section .text:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;sum&gt;:
</span><span class="line">   0:	55                   	push   %rbp
</span><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp
</span><span class="line">   4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
</span><span class="line">   8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
</span><span class="line">   b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
</span><span class="line">  12:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
</span><span class="line">  19:	eb 1d                	jmp    38 &lt;sum+0x38&gt;
</span><span class="line">  1b:	8b 45 f8             	mov    -0x8(%rbp),%eax
</span><span class="line">  1e:	48 98                	cltq   
</span><span class="line">  20:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
</span><span class="line">  27:	00 
</span><span class="line">  28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
</span><span class="line">  2c:	48 01 d0             	add    %rdx,%rax
</span><span class="line">  2f:	8b 00                	mov    (%rax),%eax
</span><span class="line">  31:	01 45 fc             	add    %eax,-0x4(%rbp)
</span><span class="line">  34:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
</span><span class="line">  38:	8b 45 f8             	mov    -0x8(%rbp),%eax
</span><span class="line">  3b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
</span><span class="line">  3e:	7c db                	jl     1b &lt;sum+0x1b&gt;
</span><span class="line">  40:	8b 45 fc             	mov    -0x4(%rbp),%eax
</span><span class="line">  43:	5d                   	pop    %rbp
</span><span class="line">  44:	c3                   	retq</span></code></pre></td></tr></table></div></figure>

<p>上面 text section 是 main.o 和 sum.o 反编译出来的，可以看出，main 函数和 sum 函数都是从地址 0 开始的。将 main.o 和 sum.o 链接生成 prog 可执行文件，反编译可执行文件后，部分 section 如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00000000000005fa &lt;main&gt;:
</span><span class="line"> 5fa:	48 83 ec 08          	sub    $0x8,%rsp
</span><span class="line"> 5fe:	be 02 00 00 00       	mov    $0x2,%esi
</span><span class="line"> 603:	48 8d 3d 06 0a 20 00 	lea    0x200a06(%rip),%rdi        # 201010 &lt;array&gt;
</span><span class="line"> 60a:	e8 05 00 00 00       	callq  614 &lt;sum&gt;
</span><span class="line"> 60f:	48 83 c4 08          	add    $0x8,%rsp
</span><span class="line"> 613:	c3                   	retq   
</span><span class="line">
</span><span class="line">0000000000000614 &lt;sum&gt;:
</span><span class="line"> 614:	b8 00 00 00 00       	mov    $0x0,%eax
</span><span class="line"> 619:	ba 00 00 00 00       	mov    $0x0,%edx
</span><span class="line"> 61e:	eb 09                	jmp    629 &lt;sum+0x15&gt;
</span><span class="line"> 620:	48 63 ca             	movslq %edx,%rcx
</span><span class="line"> 623:	03 04 8f             	add    (%rdi,%rcx,4),%eax
</span><span class="line"> 626:	83 c2 01             	add    $0x1,%edx
</span><span class="line"> 629:	39 f2                	cmp    %esi,%edx
</span><span class="line"> 62b:	7c f3                	jl     620 &lt;sum+0xc&gt;
</span><span class="line"> 62d:	f3 c3                	repz retq 
</span><span class="line"> 62f:	90                   	nop</span></code></pre></td></tr></table></div></figure>

<p>从上面可以看出，可执行文件中的 main 和 sum 的地址已经不再是 0， main 中调用了 sum 的地址为 614,切好就是 sum 的地址。</p>

<h2 id="section-2">目标文件</h2>

<p>目标文件有三种形式：可重定位的目标文件、可执行的目标文件、共享目标文件。</p>

<ul>
  <li><strong>可重定位的目标文件</strong> 是包含二进制代码的数据，其可以在编译时与其他可重定位目标文件结合生成可执行文件。</li>
  <li><strong>可执行目标文件</strong> 包含二进制代码和数据，可直接复制到内存中执行。</li>
  <li><strong>共享目标文件</strong> 特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。</li>
</ul>

<h2 id="section-3">可重定位目标文件</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">ELF 头</th>
      <th style="text-align: center">描述生成该文件的系统的字的大小和字节顺序，以及包含帮助链接器语法分析和解释目标文件的信息</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">.text</td>
      <td style="text-align: center">已编译程序的机器代码</td>
    </tr>
    <tr>
      <td style="text-align: center">.rodata</td>
      <td style="text-align: center">只读数据，比如 printf 中的字符串</td>
    </tr>
    <tr>
      <td style="text-align: center">.data</td>
      <td style="text-align: center">已初始化的全局和静态 C 变量</td>
    </tr>
    <tr>
      <td style="text-align: center">.bss</td>
      <td style="text-align: center">未初始化的全局和静态 C 变量, 以及所有被初始化为 0 的全局或静态变量</td>
    </tr>
    <tr>
      <td style="text-align: center">.symtab</td>
      <td style="text-align: center">一个符号表，它存放在程序中定义和引用的函数和全局变量的信息</td>
    </tr>
    <tr>
      <td style="text-align: center">.rel.text</td>
      <td style="text-align: center">一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置</td>
    </tr>
    <tr>
      <td style="text-align: center">.rel.data</td>
      <td style="text-align: center">被模块引用或定义的所有全局变量的重定位信息</td>
    </tr>
    <tr>
      <td style="text-align: center">.debug</td>
      <td style="text-align: center">调试符号表，与上面的 symtab 不同，它还包含了局部变量和类型定义，以及原始的 C 源文件</td>
    </tr>
    <tr>
      <td style="text-align: center">.line</td>
      <td style="text-align: center">原始 C 源程序中的行号和 .text 节中机器指令之间的映射</td>
    </tr>
    <tr>
      <td style="text-align: center">.strtab</td>
      <td style="text-align: center">一个字符串表，包括 .symtab 和 .debug 节中的符号表</td>
    </tr>
    <tr>
      <td style="text-align: center">节点头部</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>给出一个程序示例 obj.c：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">
</span><span class="line">int AAA = 3;
</span><span class="line">
</span><span class="line">int sum(int a, int b)
</span><span class="line">{
</span><span class="line">    return a + b;
</span><span class="line">}
</span><span class="line">
</span><span class="line">int main(int argc, char **argv)
</span><span class="line">{
</span><span class="line">    int a = 0;
</span><span class="line">    int b = 1;
</span><span class="line">    int c;
</span><span class="line">
</span><span class="line">    static int aa = 0;
</span><span class="line">    static int bb = 1;
</span><span class="line">    static int cc;
</span><span class="line">
</span><span class="line">    printf("a %d aa %d b %d bb %d c %d cc %d AAA %d\n", a, aa, b, bb, c, cc, AAA);
</span><span class="line">    c = sum(AAA, AAA);
</span><span class="line">
</span><span class="line">    return 0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>编译该文件 obj.c ：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -g -c obj.c
</span><span class="line">$ objdump -D obj.o &gt; obj.txt</span></code></pre></td></tr></table></div></figure>

<p>反编译生成的可重定位目标文件，下面给出几部分</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Disassembly of section .data:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;AAA&gt;:
</span><span class="line">   0:	03 00                	add    (%rax),%eax
</span><span class="line">	...
</span><span class="line">
</span><span class="line">0000000000000004 &lt;bb.2260&gt;:
</span><span class="line">   4:	01 00                	add    %eax,(%rax)
</span><span class="line">	...
</span><span class="line">
</span><span class="line">Disassembly of section .bss:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;cc.2261&gt;:
</span><span class="line">   0:	00 00                	add    %al,(%rax)
</span><span class="line">	...
</span><span class="line">
</span><span class="line">0000000000000004 &lt;aa.2259&gt;:
</span><span class="line">   4:	00 00                	add    %al,(%rax)
</span><span class="line">	...</span></code></pre></td></tr></table></div></figure>

<p>可以看出，<code>.data</code> 包含了已初始化的全局变量 AAA、和静态变量 bb。<code>.bss</code>包含了未初始化的静态变量 cc 和初始化为零的静态变量 aa。但要注意，对于局部的变量 a、b、c并没有出现在上面的几个节中，因为局部变量在运行时被保护在栈中，既不出现在<code>.data</code>节中，也不出现在<code>.bss</code> 中。</p>

<h3 id="section-4">符号和符号表</h3>

<p>对于一个可重定位的模块 m 来说，它包含的定义和引用的符号，包含三种类型：
* 由模块 m 定义并能被其他模块引用的全局符号。
* 由其他模块定义并被模块 m 引用的全局符号。
* 只被模块 m 定义和引用的局部符号。</p>

<p>注意，链接器符号和程序变量是不同的，.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号，非静态程序变量符号在运行时在栈中管理，链接器对此类符号不感兴趣，（但带有static 属性的变量除外）。</p>

<p>下面给出符号表的一个示例 m.o 和 swap.o：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void swap();
</span><span class="line">
</span><span class="line">int buf[2] = {1, 2};
</span><span class="line">
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    sawp();
</span><span class="line">    return 0;
</span><span class="line">}
</span><span class="line">
</span><span class="line">
</span><span class="line">extern int buf[];
</span><span class="line">
</span><span class="line">int *bufp0 = &amp;buf[0];
</span><span class="line">int *bufp1;
</span><span class="line">
</span><span class="line">void swap()
</span><span class="line">{
</span><span class="line">    int temp;
</span><span class="line">
</span><span class="line">    bufp1 = &amp;buf[1];
</span><span class="line">    temp  = *bufp0;
</span><span class="line">    *bufp0 = *bufp1;
</span><span class="line">    *bufp1 = temp;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>使用 readelf 工具对 swap.o 查看符号表如下:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Symbol table '.symtab' contains 13 entries:
</span><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
</span><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS swap.c
</span><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
</span><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
</span><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
</span><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
</span><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 
</span><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 
</span><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
</span><span class="line">     9: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    5 bufp0
</span><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND buf
</span><span class="line">    11: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM bufp1
</span><span class="line">    12: 0000000000000000    63 FUNC    GLOBAL DEFAULT    1 swap</span></code></pre></td></tr></table></div></figure>

<p>从上面可以看出几个符号的解析如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">符号</th>
      <th style="text-align: center">.symtab 条目</th>
      <th style="text-align: center">符号类型</th>
      <th style="text-align: center">所属模块</th>
      <th style="text-align: center">节</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">buf</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">extern</td>
      <td style="text-align: center">m.o</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">bufp0</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">bufp1</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.common</td>
    </tr>
    <tr>
      <td style="text-align: center">swap</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">temp</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
  </tbody>
</table>

<h3 id="section-5">符号解析</h3>

<p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对全局符号的解析，如果多个目标文件中定义相同名字的全局符号，链接器要么给出错误提示，要么以某种方法选出一个定义并抛弃其他定义。</p>

<h4 id="section-6">链接器如何解析多重定义的全局符号</h4>

<p>编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。链接规则如下：
* 不允许有多个同名的强符号。
* 如果有一个强符号和多个弱符号同名，选择强符号。
* 如果有多个弱符号同名，从中任选一个。</p>

<h4 id="section-7">与静态库链接</h4>

<p>静态库，将所有相关的目标文件模块打包成一个单独的文件，该文件可以作为链接器的输入，当链接器构造一个输出的可执行文件时，链接器只会复制该文件中被应用程序引用的目标模块，这样的文件称为静态库。</p>

<h4 id="section-8">链接器如何使用静态库来解析引用</h4>

<p>解析阶段，链接器<strong>从左到右(有序的)</strong>按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。链接器会维护三个集合：可重定位目标文件集合E、未解析的符号集合U、已定义的符号集合D。链接器的解析过程如下:</p>

<ul>
  <li>对命令行上的每个输入文件 f，链接器判断是否为目标文件或静态库，如果是目标文件，将其添加到E，修改U 和 D，继续解析下一个文件。</li>
  <li>如果 f 是静态库，链接器尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。匹配成功，将模块添加到E 中，修改 U 和 D。</li>
  <li>链接器扫描完输入文件后，U 非空，链接器输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，生成可执行文件。</li>
</ul>

<p>从链接器解析静态库的原理可以看出，编译时，静态库存放的位置很重要，同样的目标文件和静态库，位置不同，可能编译结果就不同了。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc -static ./libvector.a main.c
</span><span class="line">$gcc -static main.c ./libvector.a</span></code></pre></td></tr></table></div></figure>

<h3 id="section-9">重定位</h3>

<p>链接器完成符号解析后，就把代码中的每个符号和定义关联起来了。现在链接器就可以重定位了，重定位由两步组成：</p>

<ul>
  <li>重定位节和符号定义。链接器将所有相同类型的 section 合并成一个新的 section。比如，将所有模块的 .data 合并成一个新的 .data。之后将运行时的内存地址赋给新的 section 以及每个模块的定义。</li>
  <li>重定位节中的符号引用。链接器修改 .data 和 .text 中对每个符号的引用，使得它们指向正确的运行时地址。</li>
</ul>

<h4 id="section-10">重定位条目</h4>

<p>汇编器遇到对最终位置未知的目标引用，会生成一个重定位条目，告知链接器在将目标文件合并成可执行文件时如何修改该引用。代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中.</p>

<p>重定位类型有 32 种，最常用的两种是:</p>

<ul>
  <li><strong>R_X86_64_P32</strong>，重定位一个使用 32 位 PC  相对地址的引用。比如调用函数常用的 call 指令</li>
  <li><strong>R_X86_64_32</strong>，重定位一个使用 32 位绝对地址的引用</li>
</ul>

<h4 id="section-11">重定位符号引用</h4>
<p>链接器的重定位算法的伪代码如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">foreach section s {
</span><span class="line">    foreach relocation entry r {
</span><span class="line">        refptr = s + r.offset;  /*ptr to reference to be relocated*/
</span><span class="line">        
</span><span class="line">        /* Relocate a PC-relative reference */
</span><span class="line">        if (r.type == R_X86_64_PC32) {
</span><span class="line">            refaddr = ADDR(s) + r.offset; /* ref's run-time address */
</span><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr);
</span><span class="line">        }
</span><span class="line">        
</span><span class="line">        /* Relocate an absolute reference */
</span><span class="line">        if (r.type == R_X86_64_32) {
</span><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h2 id="section-12">可执行目标文件</h2>

<p>可执行目标文件格式类似于可重定位的目标文件格式，稍有不同的是：可执行目标文件有程序的入口点（程序运行时要执行的第一条指令地址）、<code>.text/.rodata/.data</code>节已经被重定位到它们最终运行时内存地址、可执行文件已经被重定位所以不需要 <code>.rel</code> 节。</p>

<p>加载器会将可执行目标文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的第一条指令或入口点来运行该程序。</p>

<h2 id="section-13">共享目标文件</h2>

<p>静态库需要定期维护和更新，静态库的代码被复制到每个运行进程的文本段中，会极大的浪费内存系统资源。共享库可以解决静态库的问题，共享库是一个目标模块，在运行和加载时，可加载到任意的内存地址，并和内存中的程序连接起来。</p>

<p>动态加载和链接共享库:Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;dlfcn.h&gt;
</span><span class="line">void *dlopen(const char *filename, int flag);
</span><span class="line">void *dlsym(void *handle, char *symbol);
</span><span class="line">int dlclose(void *handle);
</span><span class="line">const char *dlerror(void);</span></code></pre></td></tr></table></div></figure>

<p>共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，从而节约宝贵的内存资源。现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用该方法，无限多个进程可以共享一个共享模块的代码段的单一副本。加载而无需重定位的代码称为位置无关吗。</p>

<h2 id="section-14">处理目标文件的工具</h2>
<p>Linux系统中有很多工具可以帮忙处理目标文件。</p>

<ul>
  <li><strong>ar</strong> 创建静态库，插入、删除、列出和提取成员。</li>
  <li><strong>strings</strong> 列出目标文件中所有可打印的字符串。</li>
  <li><strong>strip</strong> 从目标文件中删除符号表信息。</li>
  <li><strong>nm</strong> 列出一个目标文件的符号表中定义的符号。</li>
  <li><strong>size</strong> 列出目标文件中节的名字和大小。</li>
  <li><strong>readelf</strong> 显示目标文件的完整结构。</li>
  <li><strong>objdump</strong> 所有二进制工具之母。能够显示目标文件中所有信息，最大作用是反编译 .text 节中的二进制指令。</li>
  <li><strong>ldd</strong> 列出可执行文件在运行时所需要的共享库。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(八)DAV1D源码优化 Dav1d_optimization]]></title>
    <link href="http://lazybing.github.io/blog/2019/12/22/dav1d-optinization/"/>
    <updated>2019-12-22T09:05:50-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/12/22/dav1d-optinization</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">程序流程</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">算法实现</a>    <ul>
      <li><a href="#looprestoration-" id="markdown-toc-looprestoration-">1. 局部性原理用在 LoopRestoration 中。</a></li>
      <li><a href="#film-grain-" id="markdown-toc-film-grain-">2. 局部性原理用在 Film Grain 优化。</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">编程语言</a></li>
</ul>

<p>DAV1D 作为 AV1 最高效的解码器，仍然有可优化的空间，根据自己的理解，可执行的优化方案大概从三个方面实现：程序流程、算法实现、编程语言三个角度进行优化。</p>

<!--more-->

<h2 id="section">程序流程</h2>

<p>DAV1D  解码器的流程如下图所示：
<img src="http://lazybing.github.io/images/dav1d_opt/dav1d_decoder_flow.png" /></p>

<p>从图中可以看出，DAV1D 解码器本身有三个线程，Main Thread、Frame Thread 和 Tile Thread。</p>

<ul>
  <li>Main Thread 主要控制整个解码流程，包括读取数据、Parse Obu Header（Sequence、Frame、Tile）、Film Grain、将AV1 数据给到另外两条 Thread、写数据。</li>
  <li>Tile Thread 主要完成重建帧部分，包括read_coef_blocks、recon_b_intra/recon_b_inter、itxfm_add。</li>
  <li>Frame Thread 主要完成滤波部分，是在一帧内，所有的Tile 解码完成后，Loop Filter、CDEF Filter、LoopRestoration Filter。</li>
</ul>

<p>分析上面的流程可以看出 Film Grain 部分，属于后处理部分，不会影响到其他帧的解码，因此，可以将 Film Grain 部分单独创建一个 Thread 来实现。这条优化肯定是可以实现的，只是代码库中还没有实现。</p>

<p>另外，Frame Thread 主要包括三种滤波：Loop Filter 、CDEF Filter、LoopRestoration Filter 三种，而且是顺序执行，因此可以考虑将这三种滤波，用不同的 Thread 实现。</p>

<h2 id="section-1">算法实现</h2>

<h3 id="looprestoration-">1. 局部性原理用在 LoopRestoration 中。</h3>

<p>LoopRestoration_tmpl.c 中，维纳滤波的实现有如下一段代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int j = 0; j &lt; w; j++) {
</span><span class="line">    for (int i = 0; i &lt; h; i++) {
</span><span class="line">        int sum = (hor[(j + 3) * REST_UNIT_STRIDE + i] &lt;&lt; 7) - round_offset;
</span><span class="line">
</span><span class="line">        for (int k = 0; k &lt; 7; k++) {
</span><span class="line">            sum += hor[(j + k) * REST_UNIT_STRIDE + i] * filterv[k];
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        p[j * PXSTRIDE(p_stride) + i] = 
</span><span class="line">            iclip_pixel((sum + rounding_off_v) &gt;&gt; round_bits_v);
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>上面的实现是按照列实现完成的，其实硬件的存储结构导致，行实现完成效率更高。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int j = 0; j &lt; h; j++) {
</span><span class="line">    for (int i = 0; i &lt; w; i++) {
</span><span class="line">        int sum = (hor[(j + 3) * REST_UNIT_STRIDE + i] &lt;&lt; 7) - round_offset;
</span><span class="line">
</span><span class="line">        for (int k = 0; k &lt; 7; k++) {
</span><span class="line">            sum += hor[(j + k) * REST_UNIT_STRIDE + i] * filterv[k];
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        p[j * PXSTRIDE(p_stride) + i] = 
</span><span class="line">            iclip_pixel((sum + rounding_off_v) &gt;&gt; round_bits_v);
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h3 id="film-grain-">2. 局部性原理用在 Film Grain 优化。</h3>

<p>Film Grain 的流程主要包括两部分：1. 从 Grain_lut 中获取 grain值。2. 通过获取的 grain 值，执行 add_noise_y。</p>

<p>因为获取 grain 值时，访问的内存是不连续的。此时可以考虑，先将获取的grain 值存起来，放到一块连续的buffer中，之后在执行 add_noise_y 的操作。
实现完上述步骤后，可以利用这种方式继续执行，继续使用 NEON 优化。</p>

<p>测试下来发现，960x540 分辨率，解码模块耗时 8ms，利用局部性原理优化完成后，该模块耗时 7ms，使用NEON优化后，该模块耗时5ms。</p>

<p>这还只是优化了 Y 方向的计算，如果后续优化完成 UV 方向的计算后，效果会更加明显。</p>

<h2 id="section-2">编程语言</h2>

<p>SIMD 指令优化，在编解码中一直起着非常非常重要的作用，这也解释了为什么所有的编解码器，都有 SIMD 指令的优化，可以说，SIMD 指令优化是仅次于线程优化的方案了。
在 DAV1D 最初的版本中，还不支持持 10 bit汇编的情况下，自己手动实现了 LoopFilter、CDEF Filter、LoopRestoration Filter、Film Grain Filter、MC 等模块后，解码效率提升了150%-200%。这还是在没实现 IDXT 模块的前提下。如果将所有能够使用SIMD指令优化的结果，都实现了，预估应该能做到 200%-250% 的解码效率。</p>

<p>绝大多数的 NEON 汇编优化，核心代码都可以简化为如下模式：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int i = 0; i &lt; height; i++)
</span><span class="line">    for (int j = 0; j &lt; width; j++)
</span><span class="line">        dst[i * stride + j] = iclip((src1[i][j] * weight1 + src2[i][j] * weight2 + offset) &lt;&lt; shift, min, max);</span></code></pre></td></tr></table></div></figure>
<p>使用 NEON 汇编优化上面的代码实现，假设 src1 的地址在寄存器 x0 中，src2 的地址在寄存器 x2 中。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ld1 {v0.8b, v1.8b}, [x1]
</span><span class="line">ld1 {v2.8b, v2.8b}, [x2]
</span><span class="line">movi v9.8h, #offset
</span><span class="line">movi v12.8h, #shift
</span><span class="line">movi v3.8b, #255
</span><span class="line">movi v4.8b, #128
</span><span class="line">smul v5.8h, v0.8b, v3.8b
</span><span class="line">smul v6.8h, v1.8b, v3.8b
</span><span class="line">smul v7.8h, v2.8b, v4.8b
</span><span class="line">smul v8.8h, v3.8b, v5.8b
</span><span class="line">add  v5.8h, v5.8h, v7.8h
</span><span class="line">add  v6.8h, v6.8h, v8.8h
</span><span class="line">add  v5.8h, v5.8h, v9.8h
</span><span class="line">add  v6.8h, v6.8h, v9.8h
</span><span class="line">ushl v5.8h, v5.8h, v12.8h
</span><span class="line">ushl v6.8h, v6.8h, v12.8h
</span><span class="line">smax v5.8h, v5.8h, v10.8h
</span><span class="line">smax v6.8h, v6.8h, v10.8h
</span><span class="line">smin v5.8h, v5.8h, v11.8h
</span><span class="line">smin v6.8h, v6.8h, v11.8h</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(七)之帧间编码 Inter Predicton]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/20/inter-prediction/"/>
    <updated>2019-11-20T08:04:43-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/20/inter-prediction</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#obmc-" id="markdown-toc-obmc-">OBMC 概述</a></li>
  <li><a href="#warped-motion-" id="markdown-toc-warped-motion-">Warped Motion 概述</a></li>
</ul>

<p>Motion Compensation 在视频编解码中是非常重要的模块。(未完待续)</p>

<!--more-->

<h2 id="obmc-">OBMC 概述</h2>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<p>本文通过学习文献<code>Variable Block-Size Overlapped Block Motion Compensation In The Next Generation Open-Source Video Codec</code>学习 OBMC 算法在 AV1 中的应用，并对应到 DAV1D 源码中的应用。</p>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<p>运动补偿技术通过高效的降低时间冗余，对现代视频压缩工具的成功，有非常大的贡献。主流的视频编解码标准中（AV1/VP9/HEVC/H264），它主要是基于块匹配上。</p>

<h2 id="warped-motion-">Warped Motion 概述</h2>

<p>Warped motion 模型在 AV1 中是通过两个仿射预测模型完成的，全局和局部的 warped 运动补偿。在真实世界中，物体除了简单的平移运动外，还有淡入、淡出、旋转、视角运动、不规则运动等，对于这种运动，使用放射预测能很好地提高编码性能。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(六)之帧内编码 Intra Prediction]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/12/intra-prediction/"/>
    <updated>2019-11-12T14:00:19-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/12/intra-prediction</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#spec-recursive-filtering-" id="markdown-toc-spec-recursive-filtering-">1. SPEC Recursive Filtering 概述</a>    <ul>
      <li><a href="#dav1d--recursive-filtering-" id="markdown-toc-dav1d--recursive-filtering-">DAV1D 中 Recursive Filtering 代码</a></li>
    </ul>
  </li>
  <li><a href="#smooth-intra-prediction-" id="markdown-toc-smooth-intra-prediction-">2. Smooth Intra Prediction 概述</a>    <ul>
      <li><a href="#dav1d--smooth-intra-prediction-" id="markdown-toc-dav1d--smooth-intra-prediction-">DAV1D 中 Smooth Intra Prediction 代码</a></li>
    </ul>
  </li>
  <li><a href="#intra-block-copy-" id="markdown-toc-intra-block-copy-">3. Intra Block Copy 概述</a>    <ul>
      <li><a href="#intrabc-" id="markdown-toc-intrabc-">IntraBC 几个概念</a></li>
    </ul>
  </li>
  <li><a href="#section" id="markdown-toc-section">4. 调色板模式概述</a>    <ul>
      <li><a href="#color-palette" id="markdown-toc-color-palette">Color Palette</a></li>
    </ul>
  </li>
  <li><a href="#chroma-from-luma-" id="markdown-toc-chroma-from-luma-">5. Chroma From Luma 概述</a>    <ul>
      <li><a href="#dav1d--cfl-" id="markdown-toc-dav1d--cfl-">DAV1D 中 CFL 代码</a></li>
      <li><a href="#cfl-" id="markdown-toc-cfl-">CFL 结论</a></li>
    </ul>
  </li>
</ul>

<p>VP9 支持 10 种 帧内预测模式，包括 8 个方向的模式，对应到 45-207 的角度，以及 2 个非方向的预测模式（DC 和 True Motion 模式）。AV1 中，帧内编码器从多个角度进行了扩展：角度预测的粒度进行了升级、利用亮度和色度信号的相干性等等。</p>

<!--more-->

<p>AV1 中的帧内预测器，有一种称之为基于递归滤波的帧内预测器。该帧内预测器利用滤波的方式递归地对每个像素值进行预测，在编码方面复杂度会有所提升。</p>

<h2 id="spec-recursive-filtering-">1. SPEC Recursive Filtering 概述</h2>

<p>下面给出 SPEC 中对该预测模式的概述：</p>

<blockquote>
  <p>The inputs to this process are:<br />
1. a variable w specifying the width of the region to be predicted.<br />
2. a variable h specifying the height of the region to be predicted.<br />
The output of this process is a 2D array named pred containing the intra predicted samples.<br />
For each block of 4x2 samples, this process first prepares an array p of 7 neighboring samples, and then produces the output block by filtering this array.<br />
The variable w4 is set equal to w » 2.<br />
The variable h2 is set equal to h » 1.<br />
The following steps apply of i2 = 0…h2 - 1, for j4 = 0…w4 - 1:<br />
The array p is derived as follows for i = 0…6:<br />
  1. If i is less than 5, p[i] is derived as follows:<br />
      1. If i2 is equal to 0, p[i] is set equal to AboveRow[(j4 « 2) + i -1].<br />
      2. Otherwise, if j4 is equal to 0 and i is equal to 0, p[i] is set equal to LeftCol[(i2 « 1) - 1].<br />
      3. Otherwise, p[i] is set equal to pred[(i2 « 1) - 1][(j4 « 2) + i - 1].<br />
  2. Otherwise (i is greater than or equal to 5), p[i] is derived as follows:<br />
      1. If j4 is equal to 0, p[i] is set equal to LeftCol[(i2 « 1) + i - 5].<br />
      2. Otherwise(j4 is not equal to 0), p[i] is set equal to pred[(i2 « 1) + i - 5][(j4 « 2) - 1]<br />
The following steps apply for i1 = 0..1, j1 = 0..3:<br />
  1. The variable pr is set equal to 0.<br />
  2. The variable pr is incremented by Intra_Filter_Taps[filter_intra_mode][(i1 « 2) + j1][i] * p[i] for i = 0…6<br />
  3. pred[(i2 « 1) + i1][(j4 « 2) + j1] is set equal to Clip1(Round2Signed(pr, INTRA_FILTER_SCALE_BITS)).</p>

  <p>The output of the process is the array pred.</p>
</blockquote>

<p>对于每个 4x2 采样点的块，该预测模式首先准备包含 7 个相邻样本的数组,之后通过对该数组进行滤波产生输出块。</p>

<h3 id="dav1d--recursive-filtering-">DAV1D 中 Recursive Filtering 代码</h3>

<p>Dav1d 中关于此预测模式的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* Up to 32x32 only */</span>
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_filter_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft_in</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filt_idx</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                           <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">filt_idx</span> <span class="o">&amp;=</span> <span class="mi">511</span><span class="p">;</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">filt_idx</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">const</span> <span class="kt">int8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">dav1d_filter_intra_taps</span><span class="p">[</span><span class="n">filt_idx</span><span class="p">];</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line">    <span class="kt">ptrdiff_t</span> <span class="n">left_stride</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">topleft</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">top</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">topleft_in</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">topleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">topleft_in</span><span class="p">[</span><span class="o">-</span><span class="n">y</span><span class="p">];</span>
</span><span class="line">        <span class="n">left</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">left_strie</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p0</span> <span class="o">=</span> <span class="o">*</span><span class="n">topleft</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">left_stride</span><span class="p">],</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">left_stride</span><span class="p">];</span>
</span><span class="line">            <span class="n">pixel</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int8_t</span> <span class="o">*</span><span class="n">flt_ptr</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">yy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">yy</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">yy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">,</span> <span class="n">flt_ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">flt_ptr</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">*</span> <span class="n">p4</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">*</span> <span class="n">p5</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">*</span> <span class="n">p6</span><span class="p">;</span>
</span><span class="line">                    <span class="n">ptr</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="n">iclip_pixel</span><span class="p">((</span><span class="n">acc</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="n">ptr</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="n">left_stride</span> <span class="o">=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">            <span class="n">top</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="n">topleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">top</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">bitfn</span><span class="p">(</span><span class="n">dav1d_intra_pred_dsp_init</span><span class="p">)(</span><span class="n">Dav1dIntaPredDSPContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">intra_pred</span><span class="p">[</span><span class="n">FILTER_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_filter_c</span><span class="p">;</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="smooth-intra-prediction-">2. Smooth Intra Prediction 概述</h2>

<p>帧内预测种，除了方向预测模式外，AV1 还支持非定向帧内预测模式，它有 4 种不同的方法对当前值进行预测，其中包括 3 种平滑预测模式 SMOOTH_V、SMOOTH_H、SMOOTH 以及 PAETH 预测器。</p>

<h3 id="dav1d--smooth-intra-prediction-">DAV1D 中 Smooth Intra Prediction 代码</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_paeth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">tl_ptr</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                          <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">topleft</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">cont</span> <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">top</span> <span class="o">-</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">ldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tdiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">topleft</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tdiff</span> <span class="o">&amp;&amp;</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">left</span> <span class="p">:</span>
</span><span class="line">                    <span class="n">tdiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">top</span> <span class="p">:</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>3 种平滑预测的方法如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_startup/smooth_intra_predictors.png" /></p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_v_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span><span class="p">,</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_ver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span><span class="line">                        <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="o">*</span> <span class="n">bottom</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_h_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_hor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span>
</span><span class="line">                        <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                           <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_hor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_ver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">width</span><span class="p">],</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="o">*</span> <span class="n">bottom</span> <span class="o">+</span>
</span><span class="line">                                <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="intra-block-copy-">3. Intra Block Copy 概述</h2>
<p>AV1 允许它的帧内编码器在预测当前块时，反向搜索当前帧中之前已经重建的部分，该方式在某种程度上与帧间编码搜索之前的帧是类似的。
该方法对于屏幕内容的视频压缩非常有效，因为屏幕内容的视频通常会在同一帧中包含相同的文本、字符等内容。</p>

<p>帧内块拷贝(Intra Block Copy，简称 IntraBC)，除了传统的帧内和帧间预测模式外，IBC 模式采用当前帧中已重建帧作为预测块，可以认为 IntraBC 是当前编码图像内的运动补偿。</p>

<h3 id="intrabc-">IntraBC 几个概念</h3>

<p>AV1 SPEC 中关于 IntraBC 的几点。</p>

<blockquote>
  <p><strong>allow_intrabc</strong> equal to 1 indicates that intra block copy may be used in this frame. allow_intrabc equal to 0 indicates that intra block copy is not allowed in this frame.<br />
<strong>Note:</strong> intra block copy is only allowed in intra frames, and disables all loop filtering. force_integer_mv will be equal to 1 for intra frames, so only integer offsets are allowed in block copy mode.<br />
<strong>force_integer_mv</strong> equal to 1 specifies that motion vectors will always be integers. force_integer_mv equal to 0 specifies that motion vectors can contain fractional bits.</p>
</blockquote>

<p>allow_intrabc 为1，表示该帧中可能存在 intra block copy，否则不存在。同时，intra block copy 仅仅在帧内编码图像中允许，使用了 intra block copy 的块，禁止任何的滤波。</p>

<blockquote>
  <p><strong>use_intrabc</strong> equal to 1 specifies that intra block copy should be used for this block. use_intrabc equal to 0 specifies that intra block copy should not be used.</p>
</blockquote>

<p>use_intrabc 为 1，表示该宏块使用 intra_block_copy ，否则不使用该方法。</p>

<h2 id="section">4. 调色板模式概述</h2>

<p>调色板模式，对于屏幕内容图像，很多编码块内部的颜色数是有限的，调色板模式枚举这些颜色生成颜色表，然后为每个样本传递一个索引以指示它属于颜色表中的哪种颜色。和基于预测-变换的传统编码方法相比，对于颜色数相对集中的屏幕内容图像，调色板模式往往更加有效。</p>

<p>调色板模式将块内的元素当做几种离散的颜色，不同于直接传输像素本身的参数值，而是通过传输色块的颜色编号实现压缩的目的。
AV1 支持从 8x8 到 64x64 的块，支持调色板模式，编码器会自动根据视频内容选择是否使用调色板模式。调色板模式对于当前块
有单一色调的场景十分有用，一般这种场景出现在屏幕内容的压缩当中。</p>

<h3 id="color-palette">Color Palette</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">pal_pred_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">pal</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">pal</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">x</span><span class="p">]];</span>
</span><span class="line">        <span class="n">idx</span> <span class="o">+=</span> <span class="n">w</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="chroma-from-luma-">5. Chroma From Luma 概述</h2>
<p>AV1 在帧编码中使用了Chroma_From_Luma 的工具，它是利用视觉图像中亮度值和色度值具有高度相似性的特点，通过选择适当的参数结合重建亮度值来预测色度值，该工具在游戏视频中具有很好地压缩效果。</p>

<p>Chrom_From_Luma(CFL) 的整个流程可以由下图表示。</p>

<p>当 chroma 分量通过下采样得到时，为使得像素分量一致，重建的 luma 分量需要对应的下采样。之后相应的重建 luma 像素减去平均值，得到 AC 分量。 scale 因子和符号，是通过码流中解码获得。CFL 预测值通过将重建 luma 像素的 AC 分量和 scale 因子相乘，并将结果与帧内的 DC 预测相加得到。如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_cfl/chroma_from_luma.png" /></p>

<p>该流程分为三步：</p>

<ol>
  <li>Compute Luma AC Contribution。</li>
  <li>Scale Chroma Plane</li>
  <li>Add Chroma DC_PRED</li>
</ol>

<h3 id="dav1d--cfl-">DAV1D 中 CFL 代码</h3>

<p>DAV1D 中关于 CFL 的部分，主要由下面两类函数完成，其中一类就是求 AC Contribution。第二类就是 alpha * AC + DC_PRED。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">dav1d_inta_ped_dsp_init</span><span class="p">(</span><span class="n">Dav1dIntraPredDSPContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I420</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_420_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I422</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_422_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I444</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_444_c</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_128_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_128_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">TOP_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_top_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">LEFT_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_left_c</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>关于求 AC Contribution 的函数如下，它根据 YUV 三个分量的组成比例，会有不同的参数传递，但整体思路是一样的.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cfl_ac_c</span><span class="p">(</span><span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">ypx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">w_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_hor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_ver</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">ac_orig</span> <span class="o">=</span> <span class="n">ac</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">w_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">);</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">h_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">h_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">h_pad</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">w_pad</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">ac_sum</span> <span class="o">=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">ss_hor</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_ver</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">ss_hor</span><span class="p">)</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac_sum</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_ver</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_hor</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">ypx</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ss_ver</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">memcpy</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">[</span><span class="o">-</span><span class="n">width</span><span class="p">],</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ac</span><span class="p">));</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">log2sz</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">log2sz</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">sum</span> <span class="o">&gt;&gt;=</span> <span class="n">log2s</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//subtract DC</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sum</span><span class="p">;</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define cfl_ac_fn(fmt, ss_hor, ss_ver)  \</span>
</span><span class="line"><span class="cp">    static void cfl_ac_##fmt##_c(int16_t *const ac, const pixel *const ypx, \</span>
</span><span class="line"><span class="cp">                                 const ptrdiff_t stide, const int w_pad, \</span>
</span><span class="line"><span class="cp">                                 const int h_pad, const int cw, const int ch) \</span>
</span><span class="line"><span class="cp">{   \</span>
</span><span class="line"><span class="cp">    cfl_ac_c(ac, ypx, stride, w_pad, h_pad, cw, ch, ss_hor, ss_ver);    \</span>
</span><span class="line"><span class="cp">}</span>
</span><span class="line">
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">422</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">444</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来是求解 DC PRED 的值以及最终的 Chroma 值。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">    <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">!=</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">*=</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">MULTIPLIER_1x4</span> <span class="p">:</span>
</span><span class="line">                                                            <span class="n">MULTIPLIER_1x2</span><span class="p">;</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">BASE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span>
</span><span class="line"><span class="nf">cfl_pred</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">iclip_pixel</span><span class="p">(</span><span class="n">dc</span> <span class="o">+</span> <span class="n">apply_sign</span><span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">,</span> <span class="n">diff</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_128_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="cp">#if BITDEPTH == 16</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitdepth_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="cp">#else</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
</span><span class="line"><span class="cp">#endif</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span> <span class="n">stride</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_left</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">++</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">)];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_top</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_left_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen_left</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_top_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">widht</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc_gen_top</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="cfl-">CFL 结论</h3>

<p>AV1 中采用的 Chroma_From_Luma 预测工具，该工具不仅降低了解码器复杂度，同时降低了预测错误率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(五)之DEBLOCK FILTER]]></title>
    <link href="http://lazybing.github.io/blog/2019/07/10/deblock-filter/"/>
    <updated>2019-07-10T07:07:33-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/07/10/deblock-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析及优化</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">参考资料</a></li>
</ul>

<p>AV1 使用了非常多的环路滤波器工具应用于解码帧。环路滤波的第一个阶段是去块滤波器(Deblocking Filter)。</p>

<!--more-->

<p>AV1 的去块滤波器与 VP9 中使用的滤波器基本相同，只是做了很小的改动————最长滤波从 VP9 的 15 抽头降成了 13 抽头。除了去块滤波器，AV1 还采用了CDEF 滤波器、Loop Restoration 滤波器、Film Grain 滤波器。</p>

<p>去块滤波器(Deblocking Filter, DBF)又称去块效应滤波器，是一种减少在区块边界产生视觉上瑕疵的滤波器。这种视觉瑕疵称为区块效应，这种效应主要构成原因是以区块为基础的编解码器所造成的人造边界，以区块为基底的编解码器（AVC/HEVC/AV1）都会在解码过程中利用去块滤波器将区块效应的影响降低以改善视频影像的质量。</p>

<h3 id="section">介绍</h3>

<p>以区块为基础的编解码器在预测(Prediction)或转换(Transform)编码时，都会将影像分成区块再做编码。因此影像重建时会造成在区块间边缘处不连续的现象，该现象称为去块效应，而这些区块边缘间视觉上的不连续称为人造边界。人造边界的主要成因有两个：</p>

<ul>
  <li>预测时出现不准的地方称为残量(Residual)，残量会利用离散余弦变换做量化，由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。</li>
  <li>运动补偿，同一个画面内部相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此会造成不连续的现象。同样的，画面内预测的方式也可能造成影像不连续。</li>
</ul>

<p>去区块滤波器主要有三个工作，分别是边界强度计算(Boundary Strength Computation)、边界分析(Boundary Analysis)以及滤波器应用(Filter Implementation)。</p>

<ol>
  <li>边界强度计算：主要是去计算边界强度(Boundary Strength, Bs)这个参数，边界强度呈现出相邻区块边界不连续的程序，而这个参数会跟量化的方式、区块类型、移动向量以及边界取样的梯度有关。</li>
  <li>边界分析：因为区块边缘不连续的现象可能真的是对象边缘所产生，并非所谓的人造边界，这个工作主要是判断是否为人造边界。</li>
  <li>滤波器的应用：做完前面两个工作可以决定边界强度以及判断是否真的为人造边界，这个工作主要对人造边界对应的边界强度选择该应用的滤波器。</li>
</ol>

<h3 id="section-1">源码分析及优化</h3>

<p>首先看 DAV1D 中，关于去块滤波的 C 实现函数：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_filter_h_sb128y_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">vmast</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">ptrdiff_t</span> <span class="n">b4_stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="n">AvFilterLUT</span> <span class="o">*</span><span class="n">lut</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">vm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">         <span class="n">y</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="n">l</span> <span class="o">+=</span> <span class="n">b4_stride</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">vm</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">H</span> <span class="o">=</span> <span class="n">L</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">E</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">I</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">[</span><span class="n">L</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="o">!!</span><span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">loop_filter</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面只是给出 Y 分量上的 水平滤波函数，从上面给出的 C 实现看，要实现 NEON 优化，并不简单，但如果再看它的汇编优化，简直太聪明了，在 DAV1D 发布0.3版本时，官方就称，仅仅去块滤波这一个模块，解码 8bit 流时，解码效率提升7%~34%之高。
后来我自己实现 10bit NEON 优化时，因为寄存器个数的限制（10bit，一个128位寄存器只能存放8个像素;而8bit，一个128位寄存器可存放16个像素），简码效率也有至少5%的提升。当时仿照 8bit 实现时，感慨汇编的技巧使用，惊为天人！</p>

<h3 id="section-2">参考资料</h3>

<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%8E%BB%E5%8D%80%E5%A1%8A%E6%BF%BE%E6%B3%A2%E5%99%A8">去块滤波器</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之性能分析工具perf]]></title>
    <link href="http://lazybing.github.io/blog/2019/05/17/perf/"/>
    <updated>2019-05-17T08:43:15-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/05/17/perf</id>
    <content type="html"><![CDATA[<p>本文主要记录性能优化工具 perf 的方法技巧。</p>

<!--more-->

<p><strong>perf</strong>有些子命令：</p>

<ul>
  <li>stat: 测试单个程序的事件总数。</li>
  <li>top:类似top命令，动态显示最耗时的函数。</li>
  <li>record:测试并保存单个程序的抽样数据。</li>
  <li>report:分析由 perf record 命令生成的文件，可以生成 flat 或 graph profile   文件。</li>
  <li>annotate:annotate源文件或汇编。</li>
  <li>sched:调度程序操作和延迟的追踪和测量。</li>
  <li>list:列出可能的事件。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之分支预测]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/26/branch-predictor/"/>
    <updated>2019-04-26T08:58:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/26/branch-predictor</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">预测种类</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">程序示例</a></li>
</ul>

<p>分支预测是在分支指令执行结束之前猜测哪一路分支将会被执行，以提高处理器的指令流水线的性能。使用分支预测器的目的，在于改善指令管线化的流程。</p>

<!--more-->

<h2 id="section">预测种类</h2>

<ul>
  <li>
    <p>静态预测：最简单的分支预测技术，不依赖于代码执行的动态历史信息。静态预测可以再次细分，有的是总是预测条件跳转不发生，有的假定向后分支将会发生，向前的分支不发生。向后分支是指跳转到的新地址总比当前地址要低。</p>
  </li>
  <li>
    <p>双模特预测器：该预测器是一种有 4 个状态的状态机：强不选择、弱不选择、弱选择、强选择。当一个分支命令被求值，对应的状态机被修改。分支不采纳，则向“强不选择”方向降低状态值；如果分支被采纳，则向“强选择”方向提高状态值。</p>
  </li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/saturating_counter-dia.png" /></p>

<ul>
  <li>两级自适应预测器：对于一条分支指令，如果每 2 次执行发生一次条件跳转，或者其他的规则发生模式，那么用上文提到的双模态预测器就很难预测了。如图所示，一种两级自适应预测器可以记住过去 n 次执行指令时的分支情况的历史，可能的 2^n 种历史模式的每一种都有 1 个专用的双模态预测器，用来表示如果刚刚过去的 n 次执行历史是此种情况，那么根据这个双模态预测器预测为跳转还是不跳转。</li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/Two-level_branch_prediction.png" /></p>

<h2 id="section-1">程序示例</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line"><span class="cp">#include &lt;chrono&gt;</span>
</span><span class="line"><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line">
</span><span class="line"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">arraySize</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">        <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">arraySize</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">               <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">())</span><span class="o">*</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">num</span><span class="o">/</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">den</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;const total &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; sec&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的双重 for 循环，如果对数组不排序、或者修改循环体内的条件语句为</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">;</span>
</span><span class="line">        <span class="n">sum</span> <span class="o">+=</span> <span class="o">~</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>三种相同功能的代码，耗时如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">代码结构</th>
      <th style="text-align: center">耗时</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">不排序</td>
      <td style="text-align: center">26.27s</td>
    </tr>
    <tr>
      <td style="text-align: center">排序</td>
      <td style="text-align: center">9.87s</td>
    </tr>
    <tr>
      <td style="text-align: center">不分支预测</td>
      <td style="text-align: center">10.97s</td>
    </tr>
  </tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之利用局部性原理]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/21/locality-of-reference/"/>
    <updated>2019-04-21T02:56:40-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/21/locality-of-reference</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">局部性示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">局部性原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">存储器层次结构</a></li>
</ul>

<p>局部性原理是指程序通常倾向于引用邻近于其最近引用过的数据项的数据项，或最近引用过的数据本身。</p>

<!--more-->

<h2 id="section">局部性示例</h2>

<p>先看下面两个对数组访问的示例，</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define ARRAY_ROW_SIZE 1000</span>
</span><span class="line"><span class="cp">#define ARRAY_COL_SIZE 1000</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_col</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_row</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<table>
  <thead>
    <tr>
      <th style="text-align: center">used time</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">access_array_row</td>
      <td style="text-align: center">3521</td>
      <td style="text-align: center">4287</td>
      <td style="text-align: center">4741</td>
    </tr>
    <tr>
      <td style="text-align: center">access_array_col</td>
      <td style="text-align: center">12389</td>
      <td style="text-align: center">10713</td>
      <td style="text-align: center">11985</td>
    </tr>
  </tbody>
</table>

<p>从上面的例子可以看出，同样是访问一个数组，采用列访问和采用行访问，事件相差非常大，原因就是<code>access_array_row</code>利用局部性原理。</p>

<h2 id="section-1">局部性原理</h2>

<p>局部性主要包括两种形式，时间局部性和空间局部性。</p>

<ul>
  <li>时间局部性：被引用过一次的存储器位置很可能在不远的将来再被多次引用。</li>
  <li>空间局部性：如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。</li>
</ul>

<p>有良好局部性的程序比局部性差的程序运行得更快，计算机系统设计中，局部性原理在硬件和软件中都有应用，硬件层上，采用了<strong>高速缓存存储器</strong>充分利用了局部性原理；软件层上，操作系统用主存来缓存硬盘文件系统。</p>

<h2 id="section-2">存储器层次结构</h2>

<p>局部性原理在存储器中使用特别频繁。</p>

<p><img src="http://lazybing.github.io/images/locality/locality.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之减少调用]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call/"/>
    <updated>2019-04-19T09:59:18-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">简单函数处理</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数处理</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">减少调用后续优化</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">总结</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">参考资料</a></li>
</ul>

<p>函数调用会带来相当大的开销，而且它会阻碍其他形式的程序优化。单独的较少调用次数可能对性能提升并不明显，但考虑到减少调用后，可以进一步进行其他形式的优化，减少函数调用还是很有必要的。</p>

<!--more-->

<h2 id="section">简单函数处理</h2>

<ul>
  <li>
    <p>直接将函数展开，写入调用函数处，去掉调用函数。</p>
  </li>
  <li>
    <p>使用<strong>inline</strong>关键字，将经常调用的函数写成内联函数。</p>
  </li>
  <li>
    <p>使用<strong>define</strong>关键字，使得代码在编译时将其展开。</p>
  </li>
</ul>

<p>例如，下面的函数调用</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>可以使用上面提到的三种优化方式：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">// method 1</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="c1">//method 2</span>
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class="line"><span class="c1">//method 3</span>
</span><span class="line"><span class="cp">#define IMIN(a, b) return ((a) &lt; (b) ? (a) : (b))</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">IMIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-1">函数处理</h2>

<p>上面的方法针对小函数、频繁调用的情况较试用，当函数较复杂时，我们就不适合直接展开了，那样会显得整个代码特别繁琐；另外如果被调用函数并不是我们自己的代码，就更没办法用上面提到的方法了。此时，就要分析函数的功能，选择替代方案减少调用。举个例子：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="n">vec_rec</span><span class="p">,</span> <span class="o">*</span><span class="n">vec_ptr</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">vec_ptr</span> <span class="nf">new_vec</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">vec_ptr</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec_ptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vec_rec</span><span class="p">));</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">result</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">data_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">data_t</span><span class="p">));</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">){</span>
</span><span class="line">            <span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
</span><span class="line">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">get_vec_element</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">long</span> <span class="kt">int</span> <span class="nf">vec_length</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">        <span class="n">get_vec_element</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的<code>combine2</code>函数的 for 循环中会一直调用 <strong>get_vec_element</strong>函数来获取一个元素，通过分析该函数可以看出，它获取的其实是<strong>vec_rec.v-&gt;data</strong>数组的元素，该元素也是随着循环索引<strong>i</strong>来递增的，因此可以把该函数提到<strong>for</strong>循环的外面，减少函数调用，修改后的函数如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">data_t</span> <span class="o">*</span><span class="nf">get_vec_start</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2_reducing_proc_call</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>分析上面的优化，其实它是破坏了函数的结构的，这种方法会损害函数的模块性和抽象性，上面的例子中，我们是通过分析<code>get_vec_element</code>函数和<code>for</code>循环才确定的减少调用是可用的。</p>

<h3 id="section-2">减少调用后续优化</h3>

<p>上面提到的都是针对减少调用本身来提升性能的，减少调用本身对系统性能的提升非常有限，但减少调用后，可以方便的进行进一步的优化，而进一步的优化可能效果非常显著。例如上面提到的 combine 函数，将调用函数提取到 for 循环外后，可以对整个 for 循环进行 NEON 优化，效率的提升会更加明显。</p>

<p>在做 AV1 效率优化时，也遇到过类似的优化案例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define add_noise_y(x, y, grain)    \</span>
</span><span class="line"><span class="cp">    pixel *src = src_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    pixel *dst = dst_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    int noise  = round2(scaling[ *src ] * (grain), data-&gt;scaling_shift); \</span>
</span><span class="line"><span class="cp">    *dst = iclip(*src + noise, min_value max_value);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bw</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">grain</span> <span class="o">=</span> <span class="n">sample_lut</span><span class="p">(</span><span class="n">grain_lut</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">add_noise_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>未优化前，此段代码在解码过程中，大概耗时 8ms，优化完成后，降低到 7ms，效率提升了 12.5%。提升还是很大的。</p>

<h2 id="section-3">总结</h2>

<h2 id="section-4">参考资料</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之循环展开]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/17/loop-unroll/"/>
    <updated>2019-04-17T07:36:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/17/loop-unroll</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例分析</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">循环展开扩展</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结论总结</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">参考资料</a></li>
</ul>

<p>循环展开是通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开只能针对整形加法和乘法的性能改进。</p>

<!--more-->

<p>循环展开从两个方面改变程序的性能：</p>

<ul>
  <li>分支预测失败减少。</li>
  <li>减少不直接有助于程序结果的操作的数量，如循环索引计算和条件分支。</li>
  <li>提供了一种方法，可以进一步变换代码，减少整个计算中关键路径上的操作数量。</li>
</ul>

<h2 id="section">示例分析</h2>

<figure class="code"><figcaption><span>loop_unrolling.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span><span class="p">;</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll1</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll2</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll3</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>运行上面的程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -funroll-loops -pg loop_unrolling.c -o loop_unrolling</span></code></pre></td></tr></table></div></figure>

<p>执行三次后，结果如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Executions</th>
      <th style="text-align: center">loop_unroll1</th>
      <th style="text-align: center">loop_unroll2</th>
      <th style="text-align: center">loop_unroll3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">12618</td>
      <td style="text-align: center">1890</td>
      <td style="text-align: center">3162</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7456</td>
      <td style="text-align: center">1987</td>
      <td style="text-align: center">1629</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">9868</td>
      <td style="text-align: center">2446</td>
      <td style="text-align: center">2388</td>
    </tr>
  </tbody>
</table>

<p>上面的结果可以看出，产开次数为2相对于未展开时，性能有明显提升，但展开次数为4时，性能相对于展开次数为2并没有多少提升。另外，编译器选项<code>-funroll-loops</code>好像并没有起到什么作用。但是如果添加编译选项<code>-O1</code>或<code>-O2/-O3</code>时，编译器会自动优化该函数。</p>

<p>关于展开次数和性能之间的关系，CSAPP 这本书里有介绍一个实验结果，如图所示：</p>

<p><img src="http://lazybing.github.io/images/loop_unroll/loop_unrolling.png" /></p>

<p>从图中可以看出，当循环展开到6次时的CPE(Cycles Per Element,每元素的周期数)测量值，对于展开2次或3次时观察到的趋势还在继续——循环展开对浮点数运算没有帮助，但对整数加法和乘法，CPE降至1.00.</p>

<p>实验过程中发现，CSAPP中描述的结论与我自己测试的结果有几点需要注意：</p>

<ol>
  <li>测试中，循环展开对于浮点数的加法和乘法是有效的。</li>
  <li>编译器选项<code>-funroll-loops</code>并没有起到循环展开的作用。</li>
  <li>循环展开对于性能的提升确实是都有帮助的。</li>
</ol>

<h2 id="section-1">循环展开扩展</h2>

<p>循环展开的本质是降低循环开销、增加并行运行的可能性。网上找到的大部分讲解循环展开的都是针对<strong>for</strong>循环的，既然是循环展开，那么对于<strong>while</strong>循环，理论上也是适用的，最后找到了<a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling</a>。关于<strong>while</strong>循环展开的方法，可以用下面的描述语言表示：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">while B do S; &lt;==&gt; while B ^ wp(S, B) do begin S;S end; while B do S;</span></code></pre></td></tr></table></div></figure>
<p>按照论文的讲解，手动写了两个替换的等价循环</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>遗憾的是，运行后，两者的时间并没有太大的差别，有时第二段代码方法甚至更慢。猜测可能原因有两点：现代编译器对此类优化方法已经完成的很好；不同运行环境运行效果不同；所以，循环展开这类方法，最好是实际操作运行看结果，理论与实际可能有出入。</p>

<h2 id="section-2">结论总结</h2>

<p>循环展开对于性能的提升是由帮助的，但这种帮助并不是无限的，随着展开次数的增多，性能并不会继续增加，相反，循环展开次数过多，会使得程序代码膨胀、代码可读性降低。另外，编译器优化选项<code>-O1</code>或<code>-O2</code>等，会使得编译器自身会对代码进行优化，此时手动循环展开并不是一个好的方法。再者，受运行环境的影响（我的测试用例都是在Ubuntu虚拟机下完成），其测试结果可能有不同。</p>

<h2 id="section-3">参考资料</h2>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80">循环展开</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop Unrolling</a></li>
  <li><a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling: a Method for Program Speed-Up</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/37582101">C++性能榨汁机之循环展开</a></li>
  <li><a href="https://github.com/shihyu/CSAPP2e/blob/master/Computer%20Systems%20-%20A%20Programmer's%20Perspective%20(2nd).pdf">Computer Systems - A Programmer’s Perspective</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之vallgrind之callgrind分析瓶颈]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/15/profiler/"/>
    <updated>2019-04-15T08:08:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/15/profiler</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#callgrind-" id="markdown-toc-callgrind-">Callgrind 概述</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">主要功能</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">基本使用方法</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">高级使用方法</a>    <ul>
      <li><a href="#profile-" id="markdown-toc-profile-">生成多个 profile 文件</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">限制收集事件的范围</a></li>
    </ul>
  </li>
  <li><a href="#callgrind--1" id="markdown-toc-callgrind--1">Callgrind 命令行选项</a>    <ul>
      <li><a href="#dump-" id="markdown-toc-dump-">dump 生成选项</a></li>
      <li><a href="#activity-" id="markdown-toc-activity-">activity 选项</a></li>
      <li><a href="#data-collection-" id="markdown-toc-data-collection-">data collection 选项</a></li>
      <li><a href="#cost-entity-separations-" id="markdown-toc-cost-entity-separations-">cost entity separations 选项</a></li>
      <li><a href="#simulation-" id="markdown-toc-simulation-">simulation 选项</a></li>
      <li><a href="#cache-simulation-" id="markdown-toc-cache-simulation-">cache simulation 选项</a></li>
    </ul>
  </li>
  <li><a href="#callgrindannotate-" id="markdown-toc-callgrindannotate-">callgrind_annotate 命令行选项</a></li>
  <li><a href="#callgrindcontrol-" id="markdown-toc-callgrindcontrol-">callgrind_control 命令行选项</a></li>
</ul>

<p>对程序进行性能优化的前提是知道程序性能瓶颈在哪里。本文记录 vallgrind 工具之 callgrind 来测试程序性能。</p>

<!--more-->

<p>在优化 AV1 解码库时，使用 callgrind 和 kcachegrind 来检测程序性能，下面先给出测试结果，然后用一个小的程序进行逐步分析。</p>

<p><img src="http://lazybing.github.io/images/valgrind_callgrind/valgrind_callgrind_dav1d.png" /></p>

<h2 id="callgrind-">Callgrind 概述</h2>

<p>使用该工具，必须在使用 valgrind 命令行时指定工具<code>--tool=callgrind</code>。</p>

<p>callgrind 是一个性能剖析工具，它记录一个程序运行时函数间调用历史。默认状态下，收集到的数据包括执行指令的个数、指令与源码行的对应关系、函数间调用和被调用的关系以及调用次数。除此外，模拟缓存和分支预测可能会产生更多关于应用程序运行的信息。</p>

<p>分析的数据在程序结束时会写到一个文件中。用于显示数据以及剖析互动控制，有如下两个命令 <strong>callgrind_annotate</strong> 和 <strong>callgind_control</strong>。</p>

<ul>
  <li><strong>callgrind_annotate</strong> 该命令读取 profile 数据，将函数占用时间打印出来，也可以使用图形化工具 Kcachegrind。</li>
  <li><strong>callgrind_control</strong> 该命令在执行 callgrind 时，使我们可以交互的观察和控制当前运行程序的状态，而不用停止该程序。可以用该命令获取统计信息以及当前堆栈跟踪信息。</li>
</ul>

<h3 id="section">主要功能</h3>

<p><strong>cachegrind</strong> 主要是收集 flat profile 数据：数据读取和 cache 命中率等事件发生的次数直接归因于它们发生的函数。这种归因机制称为自我归因或独占归因。</p>

<p><strong>callgrind</strong> 通过跨越函数调用边界的成本将 cachegrind 的功能进行扩展。如果函数 <strong>foo</strong> 调用 <strong>bar</strong>,从 <strong>bar</strong> 返回的消耗算到 <strong>foo</strong> 消耗里。当作为一只整体应用到程序中时，这就构建成了一个所谓的包容性成本的图片，即，每个函数的消耗包括它直接调用或间接调用的函数的消耗。</p>

<p>比如，main 函数的包容性消耗应该接近整个程序消耗的 100%。因为在调用 main 函数前，还会有其他初始的运行时间，因此最终的消耗只是接近 100%。</p>

<p>同调用图一起，可以清晰的看到从 main 开始的整个调用链，调用链上会清晰的给出程序主要消耗在什么地方。函数调用对剖析函数也是非常有用的，优化的机会一般取决于更改调用者的代码，尤其是降低调用次数。</p>

<p>callgrind 的 cache 模拟是基于 cachegrind 基础之上的。接下来的描述都是在 cachegrind 的特性基础之上进行的。</p>

<p>callgrind 的主要功能是依据它运行平台的指令集，检测函数调用和返回，它能很好地运行在 x86 和 amd64 平台上，但不幸的是在 ARM、PowerPC 或 MIPS平台上运行的并不好，因为这些平台上没有明确的调用和返回指令。</p>

<h3 id="section-1">基本使用方法</h3>

<p>和 cachegrind 一样，必须在编译时添加<code>-g</code>选项来获取调试信息，并且要将优化选项打开。启动剖析程序，只需执行如下命令：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">valgrind --tool=callgrind [callgrind options] your-program [program options]</span></code></pre></td></tr></table></div></figure>

<p>程序运行过程中，想要观察执行情况，只需要执行如下命令<code>callgrind_control -b</code>。</p>

<p>程序运行完成后，会生成一个名为<code>callgrind.out.&lt;pid&gt;</code>的文件，其中 pid 就是程序的线程 ID。该文件就包含了程序执行过程中各个函数的调用情况以及指令读取(<strong>Instruction Read(Ir)</strong>)情况。</p>

<p>想要从 profile 数据文件中生成函数的总结，使用<code>callgrind_annotate [options] callgrind.out.&lt;pid&gt;</code>。该命令与 cachegrind 中的<code>cg_annotate</code>类似，函数会按照消耗排序。callgrind 的额外的重要的特性是如下两个选项：</p>

<ul>
  <li><code>--inclusive=yes</code>:使用该选项后，会使用并显示包容性消耗的函数排序，而不是独立性消耗的排序。</li>
  <li><code>--tree=both</code>:</li>
</ul>

<h2 id="section-2">高级使用方法</h2>

<h3 id="profile-">生成多个 profile 文件</h3>

<p>有些时候，我们对完成程序运行的特性并不关心，而只是关注其中很小的一部分，比如执行某个算法。如果有多个算好或一个算法有不同的输入数据，一个单独程序运行的不同部分的 profile 数据是非常有用的。profile 数据文件有如下形式的名字<code>callgrind.out.pid.part-threadID</code>。</p>

<p>dump 多个 profile 文件的方法和形式有多种，举例如下：</p>

<ul>
  <li><strong>Dump on program termination</strong>, 该方法就是标准的方法，不需要额外的做任何操作。</li>
  <li><strong>Spontaneous,interactive dumping</strong>，使用<code>callgrind_control -d [hint [PID/Name]]</code>来使得 profile 信息的dump带有 PID 或 Name。hint 是可以随意指定的字符串用于区分 profile dump 文件。dump 结束前，控制程序不会停止。注意，为例检测 dump 命令，应用程序必须处于运行态。如果你使用的是<code>Kcachegrind</code>，想要查看 profile 信息，可以使用工具栏按钮<strong>Force dump</strong>，就会发起一个 dump 请求。</li>
  <li><strong>Periodic dumping after execution of a apecified number of basic blocks</strong>，使用<code>--dump-every-bb=count</code>选项。</li>
  <li><strong>Dumping at enter/leave of specified functions</strong>。使用<code>--dump-before=function</code>和<code>--dump-after=function</code>选项。想要在进入某个函数前清零计数器，使用<code>--zero-before=function</code>选项。针对不同的函数，可以多次使用该选项。而且函数名可以使用如下形式<code>--dump-before='foo*'</code>，它会为每个函数名的开头为 foo 的函数生成 dump 文件。</li>
  <li><strong>Program controlled dumping</strong>。在需要 dump profile 发送的代码中插入<code>CALLGRIND_DUMP_STATS</code>。使用<code>CALLGRIND_ZERO_STATS</code>清零 profile 计数器。</li>
</ul>

<p>如果你正运行一个多线程应用程序，在命令行使用<code>--separate-threads=yes</code>选项，每个线程都会生成单独的 profile 文件。因此上面的最后两种方法只会生成当前运行线程生成的 dump 文件，其他方法，则会为每个线程生成多个dump文件。</p>

<h3 id="section-3">限制收集事件的范围</h3>

<p>默认情况下，当事件发生时(比如指令执行或cache命中或未命中)，callgrind 即可将这些事件计入事件计数器。但有时我们只对某个特定的函数或者一段程序代码感兴趣，函数或某段代码结束后，就不在将额外的部分计入事件计数器。</p>

<h2 id="callgrind--1">Callgrind 命令行选项</h2>

<h3 id="dump-">dump 生成选项</h3>

<ul>
  <li><code>--callgrind-out-file=&lt;file&gt;</code>选项影响 profile 数据文件的名称和格式，该选择指定 profile 数据写到 file 中而不是默认的输出文件<code>callgrind.out.&lt;pid&gt;</code>文件。</li>
  <li><code>--dump-line=&lt;no|yes&gt; [default:yes]</code>,该选项指定事件计数应该以源码行执行。这对于编译时带有调试信息的源码。</li>
  <li><code>--dump-instr=&lt;no|ys&gt; [default:no]</code>, 该选项指定事件计数应该以指令执行。这允许汇编。当前结果可以通过 KCachegrind 显示。</li>
  <li><code>--compress-strings=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定文件和函数名是否用数字区分。他会压缩文件，但使得更加难以读取。</li>
  <li><code>--compress-pos=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定数字位置是绝对值还是相对值。</li>
  <li><code>--combine-dumps=&lt;no|yes&gt; [default:no]</code>, 不推荐，使能该选项后，多个 profile 数据会追加到同一个输出文件。</li>
</ul>

<h3 id="activity-">activity 选项</h3>

<p>这类选项指定与事件计数相关的行为什么时候发生。对于交互控制，使用 callgrind_control 控制。</p>

<ul>
  <li><code>--dump-every-bb=&lt;count&gt; [default:0, never]</code>，Dump profile data every count basic blocks。</li>
  <li><code>--dump-before=&lt;function&gt;</code>，进入函数前 dump。</li>
  <li><code>--zero-before=&lt;function&gt;</code>, 进入函数前清零所有消耗统计。</li>
  <li><code>--dump-after=&lt;function&gt;</code>, 推出函数时 dump。</li>
</ul>

<h3 id="data-collection-">data collection 选项</h3>

<p>此类选项指定何时将事件聚合到事件计数中。</p>

<ul>
  <li><code>--instr-atstart=&lt;yes|no&gt; [default:yes]</code>，</li>
  <li><code>--collect-atstart=&lt;yes|no&gt; [default:yes]</code>,</li>
  <li><code>--toggle-collect=&lt;fucntion&gt;</code>,</li>
  <li><code>--collect-jumps=&lt;no|yes&gt; [default:no]</code></li>
  <li><code>--collect-systime=&lt;no|yes&gt; [default:no]</code>, 该选项指定系统调用的信息是否要被收集。</li>
  <li><code>--collect-bus=&lt;no|yes&gt; [default:no]</code>, 该选项指定全局总线事件的数量是否被收集。</li>
</ul>

<h3 id="cost-entity-separations-">cost entity separations 选项</h3>

<h3 id="simulation-">simulation 选项</h3>

<ul>
  <li><code>--cache-sim=&lt;yes|no&gt; [default:no]</code>,该选项指定是否做高速缓存模拟。默认情况下，只有指令读访问才会被计数(<strong>Ir</strong>)。如果启动高速缓存模拟，会有更多的事件被计数：指令读取的高速缓存命中率(<strong>I1mr/ILmr</strong>)，数据读取访问(<strong>Dr</strong>)以及相关的数据读取缓存miss(<strong>D1mr/DLmr</strong>),写数据访问(<strong>Dw</strong>)以及相关的cache misses(<strong>D1mw/DLmw</strong>)。</li>
  <li><code>--branch-sim=&lt;yes|no&gt;[default:no]</code>,该选项指定是否做分支预测模拟。使能该选项后，会有更多的事件计数被启动：执行分支预测的数量以及相关的分支miss(<strong>Bc/Bcm</strong>)，执行的间接跳跃和相关的跳转地址预测的miss(<strong>Bi/Bim</strong>)。</li>
</ul>

<h3 id="cache-simulation-">cache simulation 选项</h3>

<ul>
  <li><code>--simulate-wb=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对写块行为进行模拟。</li>
  <li><code>--simulate-hwpref=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对硬件预取器的模拟。</li>
  <li><code>--cacheuse=&lt;yes|no&gt;[default:no]</code>,该选择指定是否对高速缓存行的使用进行收集。</li>
  <li><code>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>。</li>
</ul>

<h2 id="callgrindannotate-">callgrind_annotate 命令行选项</h2>

<ul>
  <li><code>--show=A,B,C [default:all]</code>, only show figures for events A, B, C.</li>
  <li><code>--sort=A,B,C</code>,sort columns by events A, B, C[event column order], Optionally, each event is followed by a : and a threshold, to specify different thresholds depending on the event.</li>
  <li><code>--threshold=&lt;0--100&gt; [default:99%]</code>, Percentage of counts(of primary sort event) we are interested in.</li>
  <li><code>--auto=&lt;yes|no&gt; [default: no]</code>, Annotate all source files containing functions that helped reach the event count threshold..</li>
  <li><code>--context=N [default: 8]</code>, Print N lines of context before and after annotated lines.</li>
  <li><code>--inclusive=&lt;yes|no&gt; [default: no]</code>, Add subroutine costs to functions calls.</li>
  <li><code>--tree=&lt;none|caller|calling|both&gt; [default: none]</code>, Print for each function their callers, the called functions or both..</li>
  <li><code>-I, --include=&lt;dir&gt;</code>, Add dir to the list of directories to search for source files.</li>
</ul>

<h2 id="callgrindcontrol-">callgrind_control 命令行选项</h2>

<p>(未完待续。。。)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之性能分析工具gprof]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/13/profiler-gprof/"/>
    <updated>2019-04-13T09:52:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/13/profiler-gprof</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gprof">Gprof</a> 是一个 Unix 应用程序性能分析工具。
<!--more--></p>

<h2 id="gprof-">gprof 概述</h2>

<p><a href="https://sourceware.org/binutils/docs/gprof/index.html">Profiling</a> 可以使我们看到程序运行时程序的调用关系、函数的消耗时长等。这些信息可以使我们了解程序中那块代码耗时高于预期。</p>

<p>使用 Profiling 主要包括如下三步：</p>

<ul>
  <li>
    <p>编译链接程序时要使能 profiling 。</p>
  </li>
  <li>
    <p>执行编译处的可执行文件，产生 profile 数据文件。</p>
  </li>
  <li>
    <p>使用 gpro 分析 profile 数据。</p>
  </li>
</ul>

<p>根据产生的 profile ，可以产生各种不同实行的分析输出。如 The Flat Profile、The Call Graph、The Annotated Source Listing。</p>

<h2 id="gprof--1">gprof 示例代码</h2>

<p>示例分析：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun2</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10240</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun1</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">fun2</span><span class="p">();</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">fun1</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译，注意要添加<code>-pg</code>选项，这样才能与后面的 gprof 结合使用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -pg -o test test.c</span></code></pre></td></tr></table></div></figure>

<p>执行, 执行完毕后，会生成 gmon.out 文件，用于性能分析的文件。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">./test</span></code></pre></td></tr></table></div></figure>

<p>分析, 使用 gprof 分析。</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gprof test gmon.out &gt; analysis.txt</span></code></pre></td></tr></table></div></figure>

<p>此时生成的分析文件 analysis.txt 中有两种形式的分析数据。</p>

<h3 id="flat-profile-">Flat Profile 示例图</h3>

<p>Flat Profile 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Flat_profile.png" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标注</th>
      <th style="text-align: center">释义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">%time</td>
      <td style="text-align: center">每个函数占用的时间比例，所有函数占比和为100%</td>
    </tr>
    <tr>
      <td style="text-align: center">cumulative seconds</td>
      <td style="text-align: center">函数及其调用函数执行累计占用时间</td>
    </tr>
    <tr>
      <td style="text-align: center">self seconds</td>
      <td style="text-align: center">单独函数执行累计占用时间</td>
    </tr>
    <tr>
      <td style="text-align: center">calls</td>
      <td style="text-align: center">函数调用次数</td>
    </tr>
    <tr>
      <td style="text-align: center">self ms/call</td>
      <td style="text-align: center">每次调用函数花费的时间,单位毫秒, 不包含调用函数运行的时间</td>
    </tr>
    <tr>
      <td style="text-align: center">total ms/call</td>
      <td style="text-align: center">每次调用函数花费的时间,单位毫秒,包括调用函数运行的时间</td>
    </tr>
    <tr>
      <td style="text-align: center">name</td>
      <td style="text-align: center">函数名称</td>
    </tr>
  </tbody>
</table>

<h3 id="call-graph-">Call Graph 示例图</h3>

<p>Call Graph 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Call_graph.png" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标注</th>
      <th style="text-align: center">释义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">index</td>
      <td style="text-align: center">每个函数第一次出现时分配一个编号，根据编号可以方便查找函数的具体分析数据</td>
    </tr>
    <tr>
      <td style="text-align: center">%time</td>
      <td style="text-align: center">函数以及调用子函数所占用的总运行时间的百分比</td>
    </tr>
    <tr>
      <td style="text-align: center">self</td>
      <td style="text-align: center">函数的总运行时间</td>
    </tr>
    <tr>
      <td style="text-align: center">children</td>
      <td style="text-align: center">子函数执行的总时间</td>
    </tr>
    <tr>
      <td style="text-align: center">called</td>
      <td style="text-align: center">函数被调用的次数，不包括递归调用</td>
    </tr>
    <tr>
      <td style="text-align: center">name</td>
      <td style="text-align: center">函数名称, name 列中，可查看函数之间的调用关系</td>
    </tr>
  </tbody>
</table>

<h2 id="section">参考资料</h2>
<ol>
  <li><a href="https://computing.llnl.gov/tutorials/performance_tools/">Performance Analysis Tools</a></li>
  <li><a href="https://sourceware.org/binutils/docs/gprof/">GNU gprof</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(四)之LOOP RESTORATION]]></title>
    <link href="http://lazybing.github.io/blog/2019/03/02/loop-restoration/"/>
    <updated>2019-03-02T18:02:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/03/02/loop-restoration</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#switchable-restoration-framework" id="markdown-toc-switchable-restoration-framework">switchable restoration framework(可切换的恢复框架)</a></li>
  <li><a href="#wiener-filter-" id="markdown-toc-wiener-filter-">Wiener Filter 维纳滤波器</a></li>
  <li><a href="#selfguided-filter-" id="markdown-toc-selfguided-filter-">Selfguided Filter 自导向投影滤波器</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p>LOOP RESTORATION，环内重建滤波器，是一个重要的增强图像质量处理方法。它包含了两种滤波器，编码器会从两者中选择其一。Wiener Filter(维纳滤波器)采用可分离的对称设计。SelfGuided(自导向投影滤波器)使用两个重建信号的线性组合来近似真实信号。编码器通过比较滤波结果，选择合适的参数，并传输给解码器。</p>

<!--more-->

<p>图像重建是一个比较成熟的领域，它包含了很多专业技术可用，比如 deblocking、deblurring、deringring、debanding、denoising、constrast enhancement、sharpening 和 resolution enhancement。</p>

<h2 id="switchable-restoration-framework">switchable restoration framework(可切换的恢复框架)</h2>

<p>在<code>AV1</code>中实现的 restoration 工具是可切换的恢复框架，该框架中 restoration 工具在每个 tile 之间切换。restoration 的 tile size 是可选的，包括<code>256x256</code>、<code>128x128</code>、<code>64x64</code>。通常情况下，对高分辨率的源，选择更大的 tile size。
对每一帧和每个组件(Y/CbCr)，<code>frame_restoration_type</code>符号会被发送。对于 Y 组件，符号有如下几个值：</p>

<ul>
  <li>RESTORE_NOEN: 不恢复帧。</li>
  <li>RESTORE_WIENER: 帧中的每个 tile 可能不恢复或者使用 wiener 滤波。</li>
  <li>RESTORE_SGRPROJ：帧中的每个 tile 可能不恢复或者使用 self-guided 滤波。</li>
  <li>RESTORE_DOMTXFMRF: 帧中的每个 tile 可能不恢复或者使用 Domain Transform Recursive 滤波。</li>
  <li>RESTORE_SWITCHABLE: 帧中的每个 tile 可能不恢复或者使用任何支持的滤波工具。</li>
</ul>

<p>对 chroma components 来说，只有上面的前三个滤波。</p>

<p>根据每个 component 的帧恢复类型，对每个 tile 会有额外的信息来表示实际的恢复类型，如有需要，可能也会有额外的信息。编码器会根据使用的 restoration 来对合适的 RD。解码器只是将受到的信息解码出来并用到滤波器上。</p>

<p>注意：除了 domain transform filter外，其他的滤波器在解码器至少需要 3 行未滤波的像素。此外，解码器操作足够简单，对硬件非常友好。也正因为这个原因，AV1 解码器中删除了 Domain Transform filter。</p>

<h2 id="wiener-filter-">Wiener Filter 维纳滤波器</h2>

<p>Degraded 帧的每个像素都经过维纳滤波，维纳滤波的系数存在码流中。因为归一化和对称性，对于垂直和水平滤波器，只需要从编码端传递三个参数。编码器决定使用的滤波抽头(filter tap),解码端只是简单的使用从码流中获取的滤波抽头。</p>

<p>分析<code>DAV1D</code>解码中，维纳滤波主要分为三步：</p>

<ul>
  <li>填充数据(padding)，此步骤主要目的是为后面的滤波做准备，将后面用到的像素汇集到一起。因为此步骤并没有改变一些像素的值，只是为了后面的滤波更加方便，所以该步骤在优化时，可以去掉，直接进行滤波，这样就少了一步数据拷贝，可以提升解码效率，在它的 ARM 汇编的实现中，就是这样做的。</li>
  <li>水平滤波。该步通过水平滤波，将上面的填充数据滤波到另外一个临时数组中，水平滤波后的数据时为下一步的垂直滤波做数据准备的。</li>
  <li>垂直滤波。该步通过垂直滤波，将水平滤波结束的数据重新放回最初原始数据的位置，从而完成对像素的整个维纳滤波。</li>
</ul>

<p><img src="http://lazybing.github.io/images/av1_lr/wiener_filter.png" /></p>

<h2 id="selfguided-filter-">Selfguided Filter 自导向投影滤波器</h2>

<h2 id="section">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="https://static1.squarespace.com/static/56ac12221f40397fbfd21993/t/59cf3d9a2278e777855714bb/1506753947391/0000265.pdf">A SWITCHABLE LOOP-RESTORATION WITH SIDE-INFORMATION FRAMEWORK FOR THE EMERGING AV1 VIDEO CODEC</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(三)之CDEF]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter/"/>
    <updated>2019-01-28T06:32:04-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cdef-" id="markdown-toc-cdef-">CDEF 介绍</a></li>
  <li><a href="#section" id="markdown-toc-section">方向查找</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">非线性低通滤波器</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">定向滤波器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">代码实现分析</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">方向查找实现</a></li>
          <li><a href="#cdef--1" id="markdown-toc-cdef--1">CDEF 方向滤波</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">参考文档</a></li>
</ul>

<p>CDEF(constrained directional enhancement)约束方向增强滤波器是 AV1 里的几种滤波器之一， SPEC 中定义的该部分在 7.15 CDEF process 中。AOM 代码中在 cdef.c 相关的文件中。除此外，还可以参考 <code>The AV1 CONSTRAINED DIRECTIONAL ENHANCEMENT FILTER</code>论文，本文就是基于上面三个部分分析的结果。</p>

<!--more-->

<p>环路滤波器基于非线性低通滤波器，专为矢量化效率设计的。该滤波器考虑边缘方向和滤波模式，它通过确定每个 block 块的方向，然后自适应的用沿方向的滤波强度进行滤波。增强滤波目的是提高 AOM 的质量，尤其是低复杂性的配置中。</p>

<h2 id="cdef-">CDEF 介绍</h2>

<p>CDEF 的主要目的是过滤掉编码杂音，同时保留图像的详细内容。AV1 中采用的方法是非线性空间滤波器，该滤波器的设计非常适用于矢量化，即可以使用 SIMD 操作，而其他非线性滤波器（如中值滤波器和双边滤波器）并非如此。</p>

<p>CDEF 滤波器的设计基于以下观察：编码图像中杂音的数量通常与量化步长大致成比例，图像详细内容的数量是输入图像的一个属性，保留在量化过的图像中的最小的实际信息量也与量化成一定的比例。对于给定的步长，杂音的幅度要比细节的幅度小很多。</p>

<p>CDEF 首先判断每个块的方向，之后沿着判断的方向自适应的滤波，并沿着判断的方向小幅度旋转 45 度，滤波强度明确表示，对模糊的高度控制。</p>

<p>CDEF 是基于之前提到的两个环路滤波器，结合的滤波器用在了 AV1 Codec 中。</p>

<p>从 SPEC 中的7.15 节可以看出，CDEF 可以理解为，输入为重建像素的当前帧数组，输出为包含了 Deringed 像素的数组 CDEF 帧。CDEF 的作用就是在侦测到的块方向上执行 DEringing， 码流中 CDEF 参数存放到每个64x64块(luma像素)中。可以将 CDEF 模块大致分为3步：</p>

<ul>
  <li>CDEF Block 处理</li>
  <li>CDEF Direction 处理</li>
  <li>CDEF Filter 处理</li>
</ul>

<h2 id="section">方向查找</h2>

<p>方块滤波后，方向查找就作用在重建像素上。因为重建像素对解码器是可获取的，因此滤波方向不需要特定的给出。查找作用在 8x8 块上，当应用到量化过后的图像时，该大小对于充分处理非直接边缘已经足够小，而对可靠地估计出方向又已经足够大了,有一个固定方向作用在8x8区域上，使得矢量化滤波更容易。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/av1_cdef_find_dir.png" /></p>

<p>对每个方向d，每行k的平均像素是: $ u_{d,k} = \frac{1}{N_{d,k}} \sum_{p \in P_{d,k}} x_p$ 其中：</p>

<ul>
  <li>$x_p$ 是像素$p$的值</li>
  <li>$P_{d,k}$是在方向$d$上第$k$行的一组像素值</li>
  <li>$N_{d,k}$是相对$P_{d,k}$对应的基数，如$N_{1,0}=2, N_{1,4}=8$</li>
</ul>

<p><code>SSD</code>的计算公式如下：$E_{d}^2 = \sum_{k} \big[\sum_{p \in P_{d,k}} \big( x_{p} - u_{d,k}\big)^2 \big]$</p>

<p>将上面的两个公式整合后，结果如下：$E_{d}^2 = \sum_{p}x_{p}^2 - \sum_{k}\frac{1}{N_{d,k}} \big(\sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>我们可以通过计算上面公式中第二部分的最大值来寻找最佳方向 $d_{opt}$, $d_opt = max_d s_d$, 其中 $s_{d} = \sum_{k}\frac{1}{N_{d,k}} \big(sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>可以用 840 乘以$S_d$来避免除以$N_{d,k}$,840 是所有$N_{d,k}$的最小公倍数。对于 8bit 数据，数据值为$[-128, 127]$，所有$840S_d$和所有的其他计算都适用于 32位 signed 整数类型。对于更高的bit，如10bit或12bit，在查找方向时，缩放像素到 8bit。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/direction_search.png" /></p>

<p>上图展示了一个针对 8x8 块，寻找方向的例子，寻找的算法如下。为了节省解码器的复杂度，我们假定亮度和色度方向是相关的，因此我们只寻找亮度原件的方向，该方向与色度方向相同。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/algorithm_find_direction.png" /></p>

<h2 id="section-1">非线性低通滤波器</h2>

<p>CDEF 使用非线性低通滤波器，去除编码杂音的同时不会模糊块的边缘。AV1 根据特定方向寻找滤波器抽头位置，同时当滤波器运用到块边界时，要防止过度模糊。使用非线性低通滤波器，在滤波像素偏差过大时，就不再对该像素过度强调。</p>

<h3 id="section-2">定向滤波器</h3>

<p>确认方向是为了统一特定方向上滤波器抽头，来降低振铃，同时不会模糊特定的边缘。但是单纯的定向滤波器有时无法高效的降低振铃效应，因此同时需要对像素数据使用滤波器抽头，该抽头并不是直接沿着主要方向。为了降低模糊块的风险，这些额外的抽头会被更保守的处理。因此，CDEF 定义了 primary taps 和 secondary taps。</p>

<p>primary taps 沿着方向 d，它的系数如上面图 4 所示。对 primary taps，对不同的 strength，会有不同的系数，对于1/3/5的strength，与2/4/6的strength，系数是不同的。secondary tpas 会形成一个十字架，是方向 d 旋转 45° 后得到，系数如图 5。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/primary_filter.png" />
<img src="http://lazybing.github.io/images/av1_cdef/secondary_filter.png" /></p>

<p>2-D CDEF 滤波器公式如下：</p>

<p>$y(i,j) = x(i,j) + round( \sum_{m,n} w_{d,m,n}^{(p)} f(x(m,n) -x(i, j), S^{(p)}, D) + \sum_{m,n} w_{d,m,n}^{(s)} f(x(m,n) -x(i,j), S^{(s)}, D))$</p>

<ul>
  <li>$S_{p}$和$S_{s}$是 primary 和 secondary 抽头的 strength。</li>
</ul>

<p>每个要滤波的 8x8 块，方向、strength 和 damping 参数是固定的。当处理位置(i, j)处的像素时，滤波器允许使用 x(i+m, j+m)处的像素，该像素可能超出 8x8 块的边界。如果处理像素超出了帧范围，像素会被忽略(f(d, S, D) = 0)。为最大化并行，CDEF 总是作用在输入(post-deblocking)像素 x(i,j)上，这样在滤波其他像素时，不会用的之前已经滤波王城的像素。</p>

<h3 id="section-3">代码实现分析</h3>

<p>此处以 DAV1D 工程里的 CDEF 模块作为例子，主要介绍两部分，<code>cdef_find_dir</code>和<code>cdef_filter_block</code>，并把 10bit 汇编优化完成。完成后，在 pixel2 手机上测试，效率提升大概 30% 左右。</p>

<h4 id="section-4">方向查找实现</h4>

<p>DAV1D 工程里，对 CDEF 方向查找，完成了 C 代码实现和对 8bit 码流的汇编优化，对10bit优化并没有完成。</p>

<figure class="code"><figcaption><span>cdef_find_dir.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">
</span></code></pre></td></tr></table></div></figure>

<h4 id="cdef--1">CDEF 方向滤波</h4>

<p>滤波主要由两步完成，</p>

<h2 id="section-5">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="http://www.mirlab.org/conference_papers/international_conference/ICASSP%202018/pdfs/0001193.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
  <li><a href="https://jmvalin.ca/misc_stuff/icassp2018_slides.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM64 汇编指令总结]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/24/neon-of-coding/"/>
    <updated>2019-01-24T06:35:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/24/neon-of-coding</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#sqdmulhvectorby-element" id="markdown-toc-sqdmulhvectorby-element">SQDMULH(vector/by element)</a></li>
  <li><a href="#sqrdmulhvectorby-element" id="markdown-toc-sqrdmulhvectorby-element">SQRDMULH(vector/by element)</a></li>
  <li><a href="#sqrshrun-sqrshrun2" id="markdown-toc-sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</a></li>
  <li><a href="#sqshrun-sqshrun2" id="markdown-toc-sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</a></li>
  <li><a href="#shl" id="markdown-toc-shl">SHL</a></li>
  <li><a href="#shll-shll2" id="markdown-toc-shll-shll2">SHLL, SHLL2</a></li>
  <li><a href="#sshll-sshll2" id="markdown-toc-sshll-sshll2">SSHLL, SSHLL2</a></li>
  <li><a href="#ushll-ushll2" id="markdown-toc-ushll-ushll2">USHLL, USHLL2</a></li>
  <li><a href="#trn1--trn2" id="markdown-toc-trn1--trn2">TRN1 &amp; TRN2</a></li>
  <li><a href="#sxtl-sxtl2" id="markdown-toc-sxtl-sxtl2">SXTL, SXTL2</a></li>
  <li><a href="#uxtl-uxtl2" id="markdown-toc-uxtl-uxtl2">UXTL, UXTL2</a></li>
  <li><a href="#ext" id="markdown-toc-ext">EXT</a></li>
  <li><a href="#bfm-ubfm-sbfmbitfield-move" id="markdown-toc-bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</a></li>
  <li><a href="#srshr" id="markdown-toc-srshr">SRSHR</a></li>
</ul>

<p>ARMv8 指令集可以大致分为三类:A64 指令集、A32&amp;T32 指令集。</p>

<p>ARM 汇编真的太痛苦了。。。一个命令一个命令的学习记录吧</p>

<!--more-->

<p>指令格式：</p>

<p><code>&lt;Opcode&gt;[&lt;Cond&gt;]&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; [.&lt;Opcode2&gt;]</code></p>

<ul>
  <li>其中尖括号的选项是必须的，花括号是可选的。</li>
  <li>A32 : Rd==&gt;{R0-R14}</li>
  <li>A64 : Rd==&gt;Xt==&gt;{X0-X30}</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标识符</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Opcode</td>
      <td style="text-align: center">操作码，也就是助记符，说明指令需要执行的操作类型</td>
    </tr>
    <tr>
      <td style="text-align: center">Cond</td>
      <td style="text-align: center">指令执行条件码，在编码中占4bit, 0b000-0b1110</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">条件码设置项，决定本次指令是否影响 PSTATE 寄存器响应状态位值</td>
    </tr>
    <tr>
      <td style="text-align: center">Rd/Xt</td>
      <td style="text-align: center">目标寄存器，A32 指令可以选择 R0-R14，T32指令大部分只能选择R0-R7,A64指令可以选择X0-X30 或 W0-W30</td>
    </tr>
    <tr>
      <td style="text-align: center">Rn/Xn</td>
      <td style="text-align: center">第一个操作数的寄存器，和 Rd 一样，不同指令有不同要求</td>
    </tr>
    <tr>
      <td style="text-align: center">Opcode2</td>
      <td style="text-align: center">第二个操作数，可以是立即数，寄存器Rm 和寄存器移位方式(Rm, #shift)</td>
    </tr>
  </tbody>
</table>

<h2 id="sqdmulhvectorby-element">SQDMULH(vector/by element)</h2>

<p>Signed saturating Doubling Multiply return High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;T&gt;</code>:4H/8H/2S/4S 中的一个</li>
</ul>

<p>示例</p>

<ul>
  <li>sqdmulh v0.8h, v0.8h, v30.8h</li>
</ul>

<p>Signed saturation Doubling Multiply return High half(by element).该指令将第一个源寄存器的每个矢量元素乘以第二个源寄存器的某个特定矢量元素，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrdmulhvectorby-element">SQRDMULH(vector/by element)</h2>

<p>Signed saturating Rounding Doubling Multiply returning High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</h2>

<p>Signed saturating Rounded Shift Right Unsigned Narrow(immediate).</p>

<p>Scalar:</p>

<p><code>SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>sqrshrun v0.8b, v1.8h, #5</li>
</ul>

<p>Vector:</p>

<p><code>SQRSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</h2>

<p>Signed saturating Shift Right Unsigned Narror(immediate).</p>

<p>Scalar:</p>

<p><code>SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SQSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="shl">SHL</h2>

<p>Shift Left(immediate)。</p>

<p>Scalar:</p>

<p><code>SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<h2 id="shll-shll2">SHLL, SHLL2</h2>

<p>Shift Left Long(by element size)。</p>

<p>Vector:</p>

<p><code>SHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li>
    <p><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</p>
  </li>
  <li>shll  v28.8h, v30.8b,  #8</li>
  <li>shll2 v29.8h, v30.16b, #8</li>
</ul>

<h2 id="sshll-sshll2">SSHLL, SSHLL2</h2>

<p>Signed Shift Left Long(immediate)。</p>

<p><code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="ushll-ushll2">USHLL, USHLL2</h2>

<p>Unsigned Shift Left Long(immediate)。</p>

<p><code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="trn1--trn2">TRN1 &amp; TRN2</h2>

<p>TRN1:转置向量 Transpose vector(primary), 该指令从零开始读取两个源寄存器 SIMD&amp;FP 的相应偶数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn1 v4.2d, v4.2d, v5.2d</li>
</ul>

<p>TRN2:转置向量 Transpose vectors(secondary)。该指令读取两个源寄存器 SIMD&amp;FP 的相应奇数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>T</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn2 v7.2s, v5.2s, v7.2s</li>
</ul>

<p><img src="http://lazybing.github.io/images/neon_coding/trn.png" /></p>

<h2 id="sxtl-sxtl2">SXTL, SXTL2</h2>

<p>SXTL:Signed extend Long,该指令</p>

<p>Vector:</p>

<p><code>SXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>sxtl v0.8h, v0.8b</li>
</ul>

<h2 id="uxtl-uxtl2">UXTL, UXTL2</h2>

<p>UXTL:Unsigned extend Long.</p>

<p>Vector:</p>

<p><code>UXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>uxtl v4.8h, v4.8b</li>
</ul>

<h2 id="ext">EXT</h2>

<p>EXT:Extract vector from pair of vectors.</p>

<p>Advanced SIMD variant</p>

<p><code>EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</code></p>

<p><img src="http://lazybing.github.io/images/neon_coding/ext.png" /></p>

<p>示例：</p>

<ul>
  <li>ext v5.16b, v4.16b, v4.16b, #2</li>
</ul>

<h2 id="bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</h2>

<p>BFM:</p>

<p>32-bit variant</p>

<p><code>BFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>SBFM:</p>

<p>32-bit variant</p>

<p><code>SBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>UBFM:</p>

<p>32-bit variant</p>

<p><code>UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>示例：</p>

<ul>
  <li>ubfm w9, w5, #7, #13</li>
</ul>

<h2 id="srshr">SRSHR</h2>

<p>SRSHR:Signed Rounding Shift Right(immediate)。</p>

<p>Scalar variant:</p>

<p><code>SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SRSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>srshr v24.8h, v24.8h, #2</li>
</ul>

]]></content>
  </entry>
  
</feed>
