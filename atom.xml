<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-01-25T07:38:33-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARM64 汇编指令总结]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/24/neon-of-coding/"/>
    <updated>2019-01-24T06:35:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/24/neon-of-coding</id>
    <content type="html"><![CDATA[<p>ARM 汇编真的太痛苦了。。。一个命令一个命令的学习记录吧</p>

<!--more-->

<h2 id="sqdmulhvector">SQDMULH(vector)</h2>

<p>Signed saturating Doubling Multiply return High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;T&gt;</code>:4H/8H/2S/4S 中的一个</li>
</ul>

<p>示例</p>

<ul>
  <li>sqdmulh v0.8h, v0.8h, v30.8h</li>
</ul>

<h2 id="sqdmulhby-element">SQDMULH(by element)</h2>

<p>Signed saturation Doubling Multiply return High half(by element).该指令将第一个源寄存器的每个矢量元素乘以第二个源寄存器的某个特定矢量元素，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrdmulhvector">SQRDMULH(vector)</h2>

<p>Signed saturating Rounding Doubling Multiply returning High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<h2 id="sqrdmulhby-element">SQRDMULH(by element)</h2>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</h2>

<p>Signed saturating Rounded Shift Right Unsigned Narrow(immediate).</p>

<p>Scalar:</p>

<p><code>SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>sqrshrun v0.8b, v1.8h, #5</li>
</ul>

<p>Vector:</p>

<p><code>SQRSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</h2>

<p>Signed saturating Shift Right Unsigned Narror(immediate).</p>

<p>Scalar:</p>

<p><code>SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SQSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="shl">SHL</h2>

<p>Shift Left(immediate)。</p>

<p>Scalar:</p>

<p><code>SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<h2 id="shll-shll2">SHLL, SHLL2</h2>

<p>Shift Left Long(by element size)。</p>

<p>Vector:</p>

<p><code>SHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li>
    <p><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</p>
  </li>
  <li>shll  v28.8h, v30.8b,  #8</li>
  <li>shll2 v29.8h, v30.16b, #8</li>
</ul>

<h2 id="sshll-sshll2">SSHLL, SSHLL2</h2>

<p>Signed Shift Left Long(immediate)。</p>

<p><code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="ushll-ushll2">USHLL, USHLL2</h2>

<p>Unsigned Shift Left Long(immediate)。</p>

<p><code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程3——矩阵相乘]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication/"/>
    <updated>2019-01-21T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">矩阵</a></li>
  <li><a href="#algorithm" id="markdown-toc-algorithm">语法(Algorithm)</a></li>
</ul>

<p>前面两篇分别介绍了如何使用 NEON 来加载和存储数据，如何使用 NEON 处理多余的数据。这一篇介绍一点儿使用的数据处理——矩阵相乘。</p>

<!--more-->

<h2 id="section">矩阵</h2>

<p>本篇文章会分析如何有效的完成4x4矩阵相乘，这种操作在 3D 图形中经常会用到。假设矩阵存放到内存中，并且是列优先的顺序，该格式在 OpenGL-ES 中使用。</p>

<h2 id="algorithm">语法(Algorithm)</h2>

<p>先详细的检测一下矩阵相乘的操作，通过把计算扩展开，并确定哪些子操作可以使用 NEON 指令实现。</p>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/neon_matrix_multiply.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程2——处理多余的数据]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers/"/>
    <updated>2019-01-20T00:56:44-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#fixing-up" id="markdown-toc-fixing-up">修复数据(Fixing Up)</a>    <ul>
      <li><a href="#larger-arrays" id="markdown-toc-larger-arrays">Larger Arrays</a>        <ul>
          <li><a href="#notes" id="markdown-toc-notes">Notes</a></li>
          <li><a href="#code-fragment" id="markdown-toc-code-fragment">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#overlapping" id="markdown-toc-overlapping">Overlapping</a>        <ul>
          <li><a href="#notes-1" id="markdown-toc-notes-1">Notes</a></li>
          <li><a href="#code-fragment-1" id="markdown-toc-code-fragment-1">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#single-elements" id="markdown-toc-single-elements">Single Elements</a>        <ul>
          <li><a href="#notes-2" id="markdown-toc-notes-2">Notes</a></li>
        </ul>
      </li>
      <li><a href="#further-considerations" id="markdown-toc-further-considerations">Further Considerations</a>        <ul>
          <li><a href="#beginning-or-end" id="markdown-toc-beginning-or-end">Beginning or End</a></li>
          <li><a href="#alignment" id="markdown-toc-alignment">Alignment</a></li>
          <li><a href="#using-arm-to-fix-up" id="markdown-toc-using-arm-to-fix-up">Using Arm to Fix Up</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>上一篇关于NEON 加载和存储的文章中，在NEON 处理单元（寄存器）和内存之间进行数据传输。这篇文章中，我们会处理经常遇到的问题：输入数据并不对齐，也就是输入数据的长度并不是向量长度的整数倍。我们需要在数组开始或结束的位置处理剩余的元素。使用 NEON 哪种方式最有效呢？</p>

<!--more-->

<p>使用 NEON 处理数据时，通常处理的数据向量的长度从 4 个元素到 16 个元素。通常情况下，你会发现数据的实际长度并不是切好等于寄存器向量长度的倍数，你必须单独处理剩余的元素。</p>

<p>例如，你想要使用 NEON 每次加载、处理、存储 8 个元素，但你的数组有 21 个元素的长度。前面 2 组能够正常处理，但对第 3 个，还剩下 5 个元素没有处理。你要怎么做呢？</p>

<h2 id="fixing-up">修复数据(Fixing Up)</h2>

<p>有三种方法来处理剩余的数据，三种方法的需求、性能和代码大小都不相同，分别是<code>Larger Arrays</code>、<code>Overlapping</code>、<code>Single Elements</code>，第一种方法效率最高。</p>

<h3 id="larger-arrays">Larger Arrays</h3>

<p>如何可以改变处理数组的大小，使用填充元素增加数组的长度到下一个向量大小的倍数，就可以读写超出数据本身的边界而不会影响相邻的存储。下面的例子中，增加元素到 24 个元素是的第三组可以很好地完成而不会有数据损坏。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/larger_array.png" /></p>

<h4 id="notes">Notes</h4>

<ul>
  <li>分配更大的数组会消耗更大的内存。</li>
  <li>新的填充数据需要在初始化时给定一个值，该值不能够影响最后的计算结果。例如，如果是求和，填充数据就只能填充为 0.如果是要找到数组里面的最小值，可以设置填充数据为可以获取的最大值。</li>
  <li>某些情况下，没办法给定一个填充数据一个初始值，不影响最终结果，比如查找数据的范围时。</li>
</ul>

<h4 id="code-fragment">Code Fragment</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line">@ r1 = output array pointer
</span><span class="line">@ r2 = length of data in array
</span><span class="line">
</span><span class="line">@ We can assume that the array length is greater than zero, is an integer
</span><span class="line">@ number of vectors, and is greater than or equal to the length of data
</span><span class="line">@ in the array.
</span><span class="line">
</span><span class="line">    add r2, r2, #7      @ add (vector length - 1) to the data length
</span><span class="line">    lsr r2, r2, #3      @ divide the length of the array by the length
</span><span class="line">                        @ of a vector, 8, to find the number of
</span><span class="line">                        @ vectors of data to be processed
</span><span class="line">loop:
</span><span class="line">    subs r2, r2, #1     @ decrement the loop counter, and set flags
</span><span class="line">    vld1.8 {d0}, [r0]!  @ load eight elements from the array pointed to
</span><span class="line">                        @ by r0 into d0, and update r0 to point to the next vector
</span><span class="line">    ...
</span><span class="line">    ...                 @ process the input in d0
</span><span class="line">    ...
</span><span class="line">    vst1.8 {d0}, [r1]!  @ write eight elements to the output array, and 
</span><span class="line">                        @ update r1 to point to next vector
</span><span class="line">    bne loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>

<h3 id="overlapping">Overlapping</h3>

<p>如果操作合适，剩余元素可以使用重叠的方法来处理。这会对数组中的某些元素进行两次处理。</p>

<p>示例中，第一组处理元素从0-7，第二组处理元素从5-12，第三组处理元素是13-20。注意，第5-7个元素，在第一次和第二次处理的向量中有重合，它们处理了两次。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/neon_overlapping.png" /></p>

<h4 id="notes-1">Notes</h4>

<ul>
  <li>Overlapping 方法只有当输入数据的操作应用不会受操作次数的改变而改变时才能使用；例如，如果想要找到最大值可以使用该方法，而求和操作就不能使用该方法，因为 overlapping 会计算元素两次。</li>
  <li>数组中的元素数量至少能够填充一个完整的向量。</li>
</ul>

<h4 id="code-fragment-1">Code Fragment</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line">@ r1 = output array pointer
</span><span class="line">@ r2 = length of data in array
</span><span class="line">
</span><span class="line">@ We can assume that the operation is idempotent, and the array is greater
</span><span class="line">@ than or equal to one vector long.
</span><span class="line">
</span><span class="line">    ands r3, r2, #7     @ calculate number of elements left over after
</span><span class="line">                        @ processing complete vectors using
</span><span class="line">                        @ data length &amp; (vector length - 1)
</span><span class="line">    beq loopsetup       @ if the result of the ands is zero, the length
</span><span class="line">                        @ of the data is an integer number of vectors,
</span><span class="line">                        @ so there is no overlap, and processing can begin at the loop
</span><span class="line">                        @ handle the first vector separately
</span><span class="line">    vld1.8 {d0}, [r0], r3   @ load the first eight elements from the array,
</span><span class="line">                            @ and update the pointer by the number of elements left over
</span><span class="line">    ...
</span><span class="line">    ...                     @ process the input in d0
</span><span class="line">    ...
</span><span class="line">    vst1.8  {d0}, [r1], r3  @ wirte eight elements to the output array, and
</span><span class="line">                            @ update the pointer
</span><span class="line">                            @ now, set up the vector processing loop
</span><span class="line"> loopsetup:
</span><span class="line">     lsr  r2, r2, #3      @ divide the length of the array by the length
</span><span class="line">                             @  of a vector, 8, to find the number of
</span><span class="line">                             @  vectors of data to be processed
</span><span class="line"> 
</span><span class="line">                             @ the loop can now be executed as normal. the
</span><span class="line">                             @  first few elements of the first vector will
</span><span class="line">                             @  overlap with some of those processed above
</span><span class="line"> loop:
</span><span class="line">     subs    r2, r2, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0}, [r0]!  @ load eight elements from the array, and update
</span><span class="line">                             @  the pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class="line">                             @  update the pointer
</span><span class="line">     bne  loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>

<h3 id="single-elements">Single Elements</h3>

<p>NEON 提供的加载和存储指令可以对向量中的某个元素进行操作。使用这个操作，可以加载向量的单个元素，在上面执行操作，并把元素写会内存。</p>

<p>示例中的问题是，前面两组数据能够正常执行(0-7元素、8-15元素)。第三组需要处理剩余的 5 个元素，它们是单独的循环中处理的，每次都执行加载、处理和存储元素。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/neon_single_element.png" /></p>

<h4 id="notes-2">Notes</h4>

<ul>
  <li>该方法比上面提到的方法要效率低，因为每个元素都单独执行加载、处理和存储。</li>
  <li>处理剩余的元素需要两个循环——一个是向量、另一个是单个元素，这回增加函数中的代码量</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line"> @ r1 = output array pointer
</span><span class="line"> @ r2 = length of data in array
</span><span class="line"> 
</span><span class="line">     lsrs    r3, r2, #3      @ calculate the number of complete vectors to be
</span><span class="line">                             @  processed and set flags
</span><span class="line">     beq  singlesetup  @ if there are zero complete vectors, branch to
</span><span class="line">                             @  the single element handling code
</span><span class="line"> 
</span><span class="line">                             @ process vector loop
</span><span class="line"> vectors:
</span><span class="line">     subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0}, [r0]!  @ load eight elements from the array and update
</span><span class="line">                             @  the pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class="line">                             @  update the pointer
</span><span class="line">     bne  vectors      @ if r3 is not equal to zero, loop
</span><span class="line"> 
</span><span class="line"> singlesetup:
</span><span class="line">     ands    r3, r2, #7      @ calculate the number of single elements to process
</span><span class="line">     beq  exit            @ if the number of single elements is zero, branch
</span><span class="line">                             @  to exit
</span><span class="line"> 
</span><span class="line">                             @ process single element loop
</span><span class="line"> singles:
</span><span class="line">     subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0[0]}, [r0]!  @ load single element into d0, and update the
</span><span class="line">                             @  pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0[0]
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0[0]}, [r1]!  @ write the single element to the output array,
</span><span class="line">                             @  and update the pointer
</span><span class="line">     bne  singles      @ if r3 is not equal to zero, loop
</span><span class="line"> 
</span><span class="line"> exit:</span></code></pre></td></tr></table></div></figure>

<h3 id="further-considerations">Further Considerations</h3>

<h4 id="beginning-or-end">Beginning or End</h4>

<p>Overlapping 和 single element 技术可以应用到处理数组的开始或结束位置。如何应用程序更适合处理结束端，上面的代码可以很容易的改成处理末端的元素。</p>

<h4 id="alignment">Alignment</h4>

<p>加载和存储地址应该与高速缓存线对齐，这样会使得内存访问更加高效。</p>

<p>对于 Cortex-A8，至少要 16 字节对齐，如果在输入或输出数组的开始位置没有对齐，就必须在数组的开始和结束位置处理元素。</p>

<p>当对齐内存来加速时，记得使用加载和存储指令时加上<code>:64</code>或<code>:128</code>或<code>:256</code>。</p>

<h4 id="using-arm-to-fix-up">Using Arm to Fix Up</h4>

<p>在使用<code>single elements</code>方法时，你可以使用 Arm 指令来对每个元素进行单独处理。然而，同时使用 Arm 指令和 NEON 指令来存储相同的内存会降低效率，因为通过 Arm 管道来写必须在 NEON 管道写完后才能进行。</p>

<p>一般情况下，应该避免同时使用 Arm 和 NEON 代码写到相同的内存区域，尤其是同一个高速缓存区域。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程1——加载和存储]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store/"/>
    <updated>2019-01-19T06:53:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">技术细节</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">概述</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">语法</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">交错存取模式</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">元素类型</a></li>
          <li><a href="#sigle-or-multiple-elements" id="markdown-toc-sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</a></li>
          <li><a href="#addressing" id="markdown-toc-addressing">寻址(Addressing)</a></li>
        </ul>
      </li>
      <li><a href="#section-6" id="markdown-toc-section-6">其他存取指令</a></li>
    </ul>
  </li>
</ul>

<p>ARM NEON 技术是 64/128 位的混合 SIMD 架构，它的设计目的就是为了提高多媒体和信号处理应用的性能，包括视频编解码、音频编解码、3D 图像、声音和图像处理。</p>

<!--more-->

<p>针对如何利用汇编语言为 NEON 编写 SIMD，后面会出一系列文章，本篇为第一部分。该系列文章会包含如何开始 NEON，如何高效使用它，后面还会介绍编写更复杂代码的技巧。我们先从操作内存开始，以及如何利用序列指令，灵活的使用 load 和 store。</p>

<h2 id="section">示例</h2>

<p>我们从一个具体的示例开始。假设你有一个 24bit RGB 图像，像素在内存中的排列格式为 R,G,B,R,G,B…，假设你想要将其中的 R 和 B 进行交换，该如何利用 NEON，是的操作更加高效呢？</p>

<p>采用简单的线性 load 指令从内存中复制到寄存器里面，然后进行R/B 调换操作，会比较繁琐。示例如图</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/linear_load_rgb.png" /></p>

<p>基于上图中的输入，进行分割、移位、合并这种方法去交换通道会很麻烦，效率低下。</p>

<p>NEON 针对此种应用场景提供了结构化的加载和存储指令，它们会从内存中加载数据的同时将数据分发到不同的寄存器。如上面例子中，VLD3 指令可以分别将加载的 R/G/B数据分别放到三个不同的寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/structed_load_rgb.png" /></p>

<p>现在，只要交换R/B寄存器的内容(VSWP d0, d2),之后用类似的存储指令 VST3 将数据写会内存中即可。</p>

<h2 id="section-1">技术细节</h2>

<h3 id="section-2">概述</h3>

<p>NEON 结构化加载指令从内存中读取数据进入 64 位 NEON 寄存器，可以选择是否交错读取；同样的，存储指令将寄存器中的数据可以交错写回到内存中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/neon_structure_loads_stores.png" /></p>

<h3 id="section-3">语法</h3>

<p>结构化加载和存取指令的语法结构有 5 部分组成。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/neon_load_store_syntax.png" /></p>

<ul>
  <li>指令助记符，VLD 用于加载，VST 用于存储。</li>
  <li>交错存取的模式，此数字指定了相关元素之间的距离。</li>
  <li>访问的元素类型，该类型指定了元素的位宽。</li>
  <li>需要读取或者写入的寄存器集合，最大为4， 取决于交错存取的模式。</li>
  <li>ARM 地址寄存器，包含需要访问的内存地址。</li>
</ul>

<h4 id="section-4">交错存取模式</h4>

<p>NEON 指令能够加载和存储数据并以交错方式加载或存储1-4个相同位宽的元素，NEON 支持8、16、32bit的交错存取元素。</p>

<ul>
  <li>VLD1 是最简单的一种形式，该指令能从内存中线性加载数据到1-4个寄存器中，一般用于无交错存取的数据处理。</li>
  <li>VLD2 可以从内存中加载数据到 2 或 4 个寄存器中，将交错的奇数和偶数项的数据分别加载到不同的寄存器中，一般用于立体声的左右声道的分离。</li>
  <li>VLD3 加载交错距离为 3 的数据到 3 个寄存器中，一般用于图像中 RGB 通道的分离。</li>
  <li>VLD4 加载交错距离为 4 的数据到 4 个寄存器中，一般用于图像中 ARGB 通道的分离。</li>
</ul>

<p>存储指令类似加载指令，但是在写入到内存之前就已经完成了数据元素交错。</p>

<h4 id="section-5">元素类型</h4>

<p>交错元素的存取规则取决于指令本身。例如，使用 VLD2.16 加载数据，完成操作后，共加载 8 个 16bit 的元素，其中偶数项元素加载到第一个寄存器，奇数项元素加载到第二个寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/100310_MC_diag3-1.png" /></p>

<p>元素大小变成 32 之后，加载同样大小的数据(4x32),然而每个寄存器中只有2个元素(2x32)，与 VLD2.16 一样，VLD2.32 同样是偶数项元素加载到第一个寄存器中，奇数项元素加载到第二个寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/100310_MC_diag3a-1.png" /></p>

<p>元素大小还会影响字节顺序，一般来讲，如果你是在存取指令中指定了正确的元素大小，从内存中读取的字节顺序将符合你的语气，并且相同的代码能在大端或者小端系统上运行良好。</p>

<p>最后，元素大小对于指针对齐也有一定的影响，指针地址对齐到元素大小将具有更好的性能，例如，当加载 32 位的元素时，内存首地址最小要对齐 32 位。</p>

<h4 id="sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</h4>

<p>除了一次加载多个元素外，结构化的加载指令还能够一次从内存中读取一个元素，并且交错的放到不同的寄存器中，或者是放到寄存器的所有通道中，或者是放到寄存器的单个通道，其他通道不受影响。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/deinterleaving_vector_lanes.png" /></p>

<p>后面的描述对于从散乱的内存中构造出一个 vector 比较有用。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/deinterleaving_single_vect.png" /></p>

<p>存储指令和读取指令类似。</p>

<h4 id="addressing">寻址(Addressing)</h4>

<p>结构化的加载和存取指令支持 3 种格式来指定地址。</p>

<ul>
  <li><code>Register:[{,:}]</code>,这是最简单的寻址方式，数据在指定地址中进行存取</li>
  <li><code>Register with increment after:[{,:}]!</code>, 这种寻址方式在完成数据加载后将更新指针使其指向之后待处理的元素，指针的增长大小与指令存取的字节数一致。</li>
  <li><code>Register with post-index:[{,:}]</code>，这种寻址方式在完成数据存取之后将改变指针，指针增加指定量（由寄存器 Rm 指定），这种方式在存取元素分散在固定距离的情况下比较方便，如读取图像的一列像素。</li>
</ul>

<p>同样的，也可以通过指定 Rn 来指定指针的对齐，使用 optional:parameter 这样同样能加快内存的读取。</p>

<h3 id="section-6">其他存取指令</h3>

<p>这里只介绍了结构化的存取指令，NEON 还提供了如下指令：</p>

<ul>
  <li>VLDR 和 VSTR，存取单个 64 位寄存器</li>
  <li>VLDM 和 VSTM，加载多个 64 位寄存器，方便从栈上存取数据。</li>
</ul>

<p>更多关于加载和存取操作的细节，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406b/index.html&amp;_ga=2.76337745.535197283.1547875098-60705264.1529324001">Arm Architecture Reference Manual</a>, 关于每条指令所占用的时钟周期数，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexa/index.html&amp;_ga=2.41000550.535197283.1547875098-60705264.1529324001">Technical Reference Manual for each core</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 技术概述]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-technology-overview/"/>
    <updated>2019-01-19T00:10:40-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-technology-overview</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#neon-" id="markdown-toc-neon-">NEON 概述</a></li>
  <li><a href="#neon" id="markdown-toc-neon">如何使用 NEON</a>    <ul>
      <li><a href="#neon--1" id="markdown-toc-neon--1">NEON 库</a>        <ul>
          <li><a href="#arm-" id="markdown-toc-arm-">用于机器学习和计算机视觉的 Arm 计算库</a></li>
        </ul>
      </li>
      <li><a href="#autovectorization" id="markdown-toc-autovectorization">AutoVectorization（自动向量化）</a></li>
      <li><a href="#compiler-intrinsics-" id="markdown-toc-compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</a></li>
      <li><a href="#assembly-code" id="markdown-toc-assembly-code">Assembly Code(汇编代码)</a></li>
    </ul>
  </li>
  <li><a href="#section" id="markdown-toc-section">开发工具</a></li>
  <li><a href="#neon--2" id="markdown-toc-neon--2">NEON 生态系统</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">参考资源:</a></li>
</ul>

<p>ARM NEON 技术是针对<code>Arm Cortex-A/R52</code>系列处理器的一种高级 SIMD 架构扩展。NEON 技术在 Armv7-A 和 Armv7-R 架构时开始引入，现在同样是 Armv8-A 和 Armv8-R 架构的扩展。</p>

<p>NEON 技术使用场景非常多，例如通过提高音视频编解码速度来提供更好的多媒体体验、加速数字信号处理算法和功能来加速音视频处理的应用、语音和面部识别、计算机视觉和深度学习。</p>

<!--more-->

<p><img src="http://lazybing.github.io/images/neon_overview/SIMDArchitecture-20.png" /></p>

<h2 id="neon-">NEON 概述</h2>

<p>NEON 技术是一个打包的 SIMD 架构。NEON 寄存器是相同数据类型的向量元素，它可以支持多种数据类型。下表描述了不同架构版本支持的数据类型：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Armv7-A/R</th>
      <th style="text-align: center">Armv8-A/R</th>
      <th style="text-align: center">Armv8-A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Floating point</td>
      <td style="text-align: center">32-bit</td>
      <td style="text-align: center">16-bit*/32-bit</td>
      <td style="text-align: center">16-bit*/32-bit/64-bit</td>
    </tr>
    <tr>
      <td style="text-align: center">Integer</td>
      <td style="text-align: center">8-bit/16-bit/32-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
    </tr>
  </tbody>
</table>

<p>NEON 指令针对向量中的所有通道执行相同的操作，操作的个数会根据不同数据类型而不同。NEON 指令允许下面的类型：</p>

<ul>
  <li>16x8-bit, 8x16-bit, 4x32-bit, 2x64-bit整形操作</li>
  <li>8x16-bit*, 4x32-bit, 2x64-bit** 浮点型操作</li>
</ul>

<p>其中<code>*</code>代表只存在于 Armv8.2-A 架构中，<code>**</code>代表只存在于 Armv8-A/R 架构中。</p>

<p>NEON 技术也能够支持多个指令并行发布。</p>

<h2 id="neon">如何使用 NEON</h2>

<p>NEON 的使用方式有多种，比如使用 NEON 库、编译器的 auto-vectorization 功能、NEON intrinsics（内联函数）、NEON 汇编代码。
关于 NEON 编程的详细信息可以参考<a href="https://static.docs.arm.com/den0018/a/DEN0018A_neon_programmers_guide_en.pdf?_ga=2.112843328.535197283.1547875098-60705264.1529324001">NEON 编程指南</a>.</p>

<h3 id="neon--1">NEON 库</h3>

<p>利用 NEON 的最简单的方式就是使用已经使用了 NEON 的开源库。</p>

<h4 id="arm-">用于机器学习和计算机视觉的 Arm 计算库</h4>

<p>Arm 计算库的目标是对于图像处理、计算机视觉和机器学习，它包含一些列针对 Arm CPU 和 GPU 架构的低级优化。更多信息可以访问<a href="https://developer.arm.com/technologies/compute-library">compue-library</a>.</p>

<p>Ne10 是一个开源的 C 库，由 arm 公司在 github 上维护，它包含了一组最常用的功能，这些功能都已经为 arm 做了专项优化。Ne10 是一个模块化结构，包含了很多小的库，目前包含的主要功能有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Math functions</th>
      <th style="text-align: center">Signal Processing functions</th>
      <th style="text-align: center">Image processing functions</th>
      <th style="text-align: center">Physics functions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Vector Add</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center">Image Resize</td>
      <td style="text-align: center">Collision Detection</td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix-Add</td>
      <td style="text-align: center">Complex-to-Complex FFT</td>
      <td style="text-align: center">Image Rotate</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract From</td>
      <td style="text-align: center">Real-to-Complex FFT</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix Subtract</td>
      <td style="text-align: center">FIR Filters</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>libyuv 是一个开源项目库，它包含了 YUV 缩放和转换功能。</p>

<p>skia 库是一个针对 2D 图像的开源库，用作 谷歌 Chrome 和 Chrome OS, Android、Mozilla Firefox 和 Firefox OS 以及其他许多产品的图形引擎。</p>

<h3 id="autovectorization">AutoVectorization（自动向量化）</h3>

<p>auto-vectorization 特性是由 arm 编译器支持的，编译器会自动利用 NEON 功能。支持该特性的编译器有:</p>

<ul>
  <li>Arm Compiler 5</li>
  <li>Arm LLVM-based Compiler 6</li>
  <li>GCC</li>
</ul>

<p>NEON 编程指南在 arm 编译器使用用户指导部分同样对于 NEON 选项提供了额外的指导。</p>

<h3 id="compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</h3>

<p>使用内联函数，编译器会在编译时将内联函数替换成一条或几条对应的 NEON 指令。内联函数提供的功能与汇编语言差不多，但将寄存器的使用交给了编译器，
所以开发者可以专注在算法上。它同样可以执行指令调度从而移除指定目标处理器的流水线停顿。内联函数的可维护性比汇编语言更好，支持内联函数的编译器包括 ARM 编译器、GCC 编译器和 LLVM 编译器。</p>

<p>更多关于 Intrinsics 的信息，可以参考<a href="https://developer.arm.com/technologies/neon/intrinsics">Arm NEON Intrinsics Reference document</a>,该参考文档记录了 Armv7 和 Armv8 架构的 NEON Intrinsics 使用方法。示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;arm_neon.h&gt;</span>
</span><span class="line"><span class="kt">uint32x4_t</span> <span class="nf">double_elements</span><span class="p">(</span><span class="kt">uint32x4_t</span> <span class="n">input</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">vaddq_u32</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="assembly-code">Assembly Code(汇编代码)</h3>

<p>为例更高的性能，NEON 汇编代码是最好的方法，只要支持 NEON instructions 的编译器，GNU 编译器(gas) 和 ARM 编译器(armasm) 都支持汇编代码。</p>

<h2 id="section">开发工具</h2>

<p><code>Arm DS-5 Development Studio</code>为基于 Arm 平台提供了用于 C/C++ 软件开发的端到端的工具套件，DS-5 从编程到调试对 NEON 架构提供了全支持。DS-5 调试器提供 NEON 指令的完整调试功能和架构寄存器的可视化。DS-5 调试器支持所有 Arm 架构配置文件和处理器。</p>

<p><img src="http://lazybing.github.io/images/neon_overview/DS5.png" /></p>

<h2 id="neon--2">NEON 生态系统</h2>

<p>NEON 在如下表格所示的领域内有广泛的使用，其中包含了很多跨平台的开源项目：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Video Codecs</th>
      <th style="text-align: center">Audio Codecs</th>
      <th style="text-align: center">Voice and speech codecs</th>
      <th style="text-align: center">Audio enhancement algorithms</th>
      <th style="text-align: center">Computer Vision</th>
      <th style="text-align: center">Machine and deep leaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">VP9 OTT encoder, VP9 Consumer encoder/decoder</td>
      <td style="text-align: center">MP3 encoder/decoder</td>
      <td style="text-align: center">G.711</td>
      <td style="text-align: center">Echo cancellation</td>
      <td style="text-align: center">Canny Edge detection</td>
      <td style="text-align: center">On-device object recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">H.264(AVC) encoder/decoder</td>
      <td style="text-align: center">MPEG-2 layer I&amp;II encoder/decoder</td>
      <td style="text-align: center">G.722, G.722.1, G.722.2</td>
      <td style="text-align: center">Noise Reduction</td>
      <td style="text-align: center">Harris Corner</td>
      <td style="text-align: center">On-device scene recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG4 SP/ASP encoder/decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder</td>
      <td style="text-align: center">G.723.1</td>
      <td style="text-align: center">Beam Forming</td>
      <td style="text-align: center">ORB</td>
      <td style="text-align: center">Human pose recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG2 decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder /decoder</td>
      <td style="text-align: center">G.726</td>
      <td style="text-align: center">Comfort Noise</td>
      <td style="text-align: center">Convolution filter</td>
      <td style="text-align: center">Defect detection</td>
    </tr>
    <tr>
      <td style="text-align: center">H.263 decoder</td>
      <td style="text-align: center">HE-AACv1, v2 encoder/decoder</td>
      <td style="text-align: center">G.727</td>
      <td style="text-align: center">AudioZoom</td>
      <td style="text-align: center">Erosion/Dilation</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Standart encoder/decoder</td>
      <td style="text-align: center">G.728</td>
      <td style="text-align: center">Equalization</td>
      <td style="text-align: center">Face detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Pro, WMA Lossless decoder</td>
      <td style="text-align: center">G.729, G.279A, G.729B</td>
      <td style="text-align: center">Wind noise reduction</td>
      <td style="text-align: center">Pedestrian detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">SBC Bluetooth encoder/decoder</td>
      <td style="text-align: center">G.729AB</td>
      <td style="text-align: center">Automatic Gain Control</td>
      <td style="text-align: center">Fast9/Fast12 corner detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">OggVorbis encoder/decoder</td>
      <td style="text-align: center">AMR Narrowband, Wideband, Wideband+</td>
      <td style="text-align: center">Voice Activity Detection</td>
      <td style="text-align: center">Object tracking</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
  </tbody>
</table>

<p>有关 NEON 生态系统的更多合作伙伴可以参考 <a href="https://developer.arm.com/technologies/dsp/arm-dsp-ecosystem-partners">DSP Ecosystem Partners page</a>。</p>

<h2 id="section-1">参考资源:</h2>

<ol>
  <li><a href="https://www.youtube.com/watch?v=ixuDntaSnHI">Taming Armv8 NEON:from theory to benchmark results</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores">Coding for NEON - Part 1: Load and Stores</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-2-dealing-with-leftovers">Coding for NEON - Part 2: Dealing With Leftovers</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-3-matrix-multiplication">Coding for NEON - Part 3: Matrix Multiplication</a>.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(二)之film_grain]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis/"/>
    <updated>2018-10-17T08:35:36-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#film-grain-" id="markdown-toc-film-grain-">Film Grain 简介</a></li>
  <li><a href="#film-grain--1" id="markdown-toc-film-grain--1">Film Grain 流程</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p><code>Film Grain</code>在电视和电影内容中广泛存在，它经常是创作内容的一部分，在编码过程中需要保留下来，因为<code>film grain</code>的随机性，导致很难用传统的压缩算法进行压缩。</p>

<!--more-->

<h1 id="film-grain-">Film Grain 简介</h1>

<p><code>film grain</code>模型和整体框架如图所示。</p>

<p><img src="http://lazybing.github.io/images/film_grain_av1/film_grain_framework.png" /></p>

<p><code>film grain</code>在去噪音过程中会从视频中去除掉，<code>grain</code>参数会通过噪音视频序列和去噪视频序列的差异中获得,这些参数会和压缩视频流一起传输到解码端。 解码后，<code>film grain</code>会被叠加到重建视频帧中。</p>

<h1 id="film-grain--1">Film Grain 流程</h1>

<p>从上面的框架图可以看出，<code>film grain</code>包括压缩前的去噪、编码参数、解码参数、噪音叠加到重建帧等几个过程，这里不讨论去噪的过程，主要讨论<code>film grain modeling synthesis</code>。
流程可以从<code>SPEC</code>中看到，也可以从源码中学习，<code>film grain</code>中在源码中主要集中在<code>aom/aom_dsp/grain_synthesis.c</code>中的<code>av1_add_film_grain_run</code>函数中，分析源码可知大致分为如下流程：</p>

<ul>
  <li>init_array. 为<code>film grain</code>准备后面用到的内存，大致分为三类<code>grain buffer(luma_grain_block/cb_grain_block/cr_grain_block)</code>、<code>line buf(y_line_buf/cb_line_buf/cr_line_buf)</code>、<code>column buf(y_col_buf/cb_col_buf/cr_col_buf)</code>。</li>
  <li>generate_luma_grain_block 和 generate_chroma_grain_blocks. 它会根据码流中 parse 出来的<code>grain_scale_shift/ar_coeff_lag</code>的值和<code>gaussian_sequence</code>表来填充<code>grain block</code>。</li>
  <li>init_scaling_function. 它是利用码流中 parse 出来的 <code>scaling_points_y</code>来填充<code>scaling_lut_y/scaling_lut_cb/scaling_lut_cr</code>数组。</li>
  <li>add_noise_to_block。它会根据上面生成的<code>grain block</code>叠加到重建帧上。</li>
</ul>

<h1 id="section">参考文档</h1>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/">AV1 Bitstream &amp; Decoding Process</a></li>
</ol>

<p>(未完待续…)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(一)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/15/av1-startup/"/>
    <updated>2018-10-15T07:43:02-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/15/av1-startup</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#aom-" id="markdown-toc-aom-">AOM 工程</a>    <ul>
      <li><a href="#av1-" id="markdown-toc-av1-">AV1 前期准备</a></li>
      <li><a href="#section" id="markdown-toc-section">获取源码</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">编译</a>        <ul>
          <li><a href="#linux-" id="markdown-toc-linux-">Linux 下编译方法</a></li>
          <li><a href="#windows-" id="markdown-toc-windows-">Windows 下编译方法</a></li>
          <li><a href="#section-2" id="markdown-toc-section-2">交叉编译</a></li>
        </ul>
      </li>
      <li><a href="#section-3" id="markdown-toc-section-3">配置选项</a></li>
      <li><a href="#aom-vs-" id="markdown-toc-aom-vs-">AOM VS 工程</a></li>
    </ul>
  </li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 工程</a>    <ul>
      <li><a href="#dav1d--1" id="markdown-toc-dav1d--1">DAV1D 下载</a></li>
      <li><a href="#dav1d--2" id="markdown-toc-dav1d--2">DAV1D 工程编译</a></li>
      <li><a href="#dav1d-vs-" id="markdown-toc-dav1d-vs-">DAV1D VS 工程</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
    </ul>
  </li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/AV1">AV1</a>作为一个开放、免专利的视频编码格式，专为通过网络进行刘传书而设计。学习一个新的视频编解码标准除了看<a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">SPEC</a>,最好的方法是看源码<code>aom</code>。本文主要记录官方工程 AOM 和 DAV1D 两个工程的建立。</p>

<!--more-->

<h2 id="aom-">AOM 工程</h2>

<h3 id="av1-">AV1 前期准备</h3>

<ul>
  <li>安装<code>CMake</code>，版本需求 3.5 以上。</li>
  <li>安装<code>Git</code>。</li>
  <li>安装<code>Perl</code>。</li>
  <li>对于<code>x86</code>,需要安装<code>yasm</code>或<code>nasm</code>。</li>
  <li>安装<code>python</code>。</li>
</ul>

<h3 id="section">获取源码</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ git clone https://aomedia.googlesource.com/aom</span></code></pre></td></tr></table></div></figure>

<h3 id="section-1">编译</h3>

<p><code>AV1</code>采用的配制方法不再是通常的<code>config</code>命令，而是<code>cmake</code>.<code>cmake</code>会生成配置文件和编译文件，大多数系统中，默认的编译文件是<code>Makefile</code>。
执行<code>cmake</code>会得到如下提示:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cmake [options] &lt;path-to-source&gt;
</span><span class="line">...
</span><span class="line">Options
</span><span class="line">    -G &lt;generator-name&gt; = Specify a build system generator.</span></code></pre></td></tr></table></div></figure>

<p>某些参数可以直接通过 cmake传递进去，如是否编译<code>encoder</code>。</p>

<blockquote>
  <p>其实不止 AV1 的官方代码，<code>DAV1D</code>工程，同样有类似的配置过程，只不过它使用的是<code>meson</code>而不是<code>cmake</code>，但效果是一样的。</p>
</blockquote>

<h4 id="linux-">Linux 下编译方法</h4>

<p>Linux 下的编译最简单了，只需要用<code>cmake</code>配置，然后<code>make</code>编译即可。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ cmake path/to/aom
</span><span class="line">$ make</span></code></pre></td></tr></table></div></figure>
<p>上面的方法就可以用到<code>Linux</code>平台下，生成<code>aomdec</code>可执行文件，进行解码。</p>

<h4 id="windows-">Windows 下编译方法</h4>

<p><code>Windows</code>下使用<code>Visual Studio</code>同样可以编译运行<code>av1</code>的代码。只需要在<code>cmake</code>时指定 VS 版本号即可,支持的工具可以通过<code>cmake --help</code>来查看。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ make aom_vs
</span><span class="line">$ cd aom_vs
</span><span class="line">$ cmake /path/to/aom -G "Visual Studio 12 2013 Win64" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0 -DAOM_TARGET_CPU=generic</span></code></pre></td></tr></table></div></figure>
<p>此时在<code>aom_vs</code>路径下，会生成一个<code>AOM.sln</code>,用<code>VisualStudio 2013</code>打开该文件后，编译运行即可使用<code>VisualStudio</code>调试学习了。</p>

<h4 id="section-2">交叉编译</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ mkdir aom_armv7
</span><span class="line">$ cd aom_armv7
</span><span class="line">$ CFLAGS="-pie -fPIE" LDFLAGS="-pie -fpIE" cmake /path/to/aom -DCROSS=/path/to/cross_build_tool_bin/ -DCMAKE_TOOLCHAIN_FILE=/path/to/tools -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0
</span><span class="line">$ make</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">配置选项</h3>

<p>上面再编译的过程中，已经提到了很多配置选项，在此举几个例子：</p>

<ul>
  <li><code>-DCONFIG_AV1_ENCODER=0</code>表示不编译<code>av1 encoder</code>。</li>
  <li><code>-DAOM_TARGET_CPU=generic</code>表示不编译汇编。</li>
  <li><code>-G "Visual Studio 12 2013 Win64"</code>表示生成的配置文件，可以通过<code>VS2013</code>来打开编译运行。</li>
  <li><code>-DCMAKE_CONFIGURATION_TYPES=Debg</code>表示生成Debug 类型的可执行文件。</li>
</ul>

<h3 id="aom-vs-">AOM VS 工程</h3>

<p><img src="http://lazybing.github.io/images/av1_startup/aom_vs.png" /></p>

<h2 id="dav1d-">DAV1D 工程</h2>

<p>DAV1D 工程是一个跨平台的 AV1 解码器，该开源项目的目标是加速解码进度，解决目前还没有硬件支持 AV1 解码的问题。它包括了大多数 AOM 工程的特性。浏览该工程源码，该源码代码比较紧凑、很多函数甚至是宏定义完成的，调试非常困难……</p>

<h3 id="dav1d--1">DAV1D 下载</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$git clone git@code.videolan.org:videolan/dav1d.git
</span><span class="line">$git clont https://code.videolan.org/videolan/dav1d.git</span></code></pre></td></tr></table></div></figure>

<h3 id="dav1d--2">DAV1D 工程编译</h3>

<ol>
  <li>安装<code>Meson(0.47或更高版本)和 Ninja</code>，如果是 x86 平台，需要安装<code>nasm(2.13.02或更高版本)</code></li>
  <li>cd dav1d</li>
  <li><code>meson --buildtype debug --backend vs2017 ./ vs2017</code>，其中各个参数的含义，可以通过<code>meson --help</code>命令查看，注意，该命令的执行要在 Visual Studio 工程的 Native Tool Command 下执行。有时可能是安装时的配置的问题，即使在 Native Tool Command 下执行，仍然有问题，我是在<code>Developer Command Prompt for VS 2017</code>下执行成功的。</li>
  <li>安装完成后，就可以使用 Visual Studio 2017 打开 dav1d.sln 了。</li>
</ol>

<h3 id="dav1d-vs-">DAV1D VS 工程</h3>

<p><img src="http://lazybing.github.io/images/av1_startup/dav1d_vs.png" /></p>

<h3 id="section-4">参考文档</h3>

<p><a href="https://aomedia.googlesource.com/aom/+/master/README.md">AV1 Codec Library</a></p>

<p><strong><em>欢迎添加微信交流</em></strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C语言调用静态库和动态库简介]]></title>
    <link href="http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library/"/>
    <updated>2018-09-18T21:27:55-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">动态库和静态库简述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">静态库使用示例</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">动态库使用示例</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">动态库和静态库整合</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
</ul>

<p>最近工作中遇到要把第三方静态库整合到自己的动态开里的问题，在此记录并整理一些关于静态库和动态库的知识，并用特定的例子。</p>

<!--more-->

<h3 id="section">动态库和静态库简述</h3>

<p>动态库和静态库本质上是一种可执行代码的二进制形式，它们可以被操作系统载入内存执行。两者的主要区别是，静态库是在编译过程中被载入可执行程序的，体积较大；动态库是在可执行程序在运行时被载入内存的，在编译过程中仅仅使用简单的引用，体积较小。</p>

<p>给出示例代码如下：</p>

<figure class="code"><figcaption><span>sayhello.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &quot;sayhello.h&quot;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><figcaption><span>sayhello.h </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#ifndef _SAYHELLO_H_</span>
</span><span class="line"><span class="cp">#define _SAYHELLO_H_</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-1">静态库使用示例</h3>

<p>编译静态库：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -Wall -O2 -fPIC -I./ -c -o sayhello.o sayhello.c
</span><span class="line">$ ar crv libsayhello.a sayhello.o</span></code></pre></td></tr></table></div></figure>

<p><code>ar</code>命令会生成<code>libsayhello.a</code>的静态库。该命令的参数如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">参数</th>
      <th style="text-align: center">意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">将objectfile 文件插入静态库尾或替换静态库中同名文件</td>
    </tr>
    <tr>
      <td style="text-align: center">-x</td>
      <td style="text-align: center">从静态库文件中抽取文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-t</td>
      <td style="text-align: center">打印静态库的成员文件列表</td>
    </tr>
    <tr>
      <td style="text-align: center">-d</td>
      <td style="text-align: center">从静态库中删除文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-s</td>
      <td style="text-align: center">重置静态库文件索引</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">创建文件冗余信息</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">创建静态库文件</td>
    </tr>
  </tbody>
</table>

<p>生成了静态库后，可以在可执行文件中调用静态库内的函数,示例代码：</p>

<figure class="code"><figcaption><span>lang: test_hello_stactic.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="k">extern</span> <span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">helloworld</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译命令:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc test_hello_stactic.c -o test_hello_sta ./libsayhello.a</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">动态库使用示例</h3>

<p>编译动态库：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -O2 -fPIC -shared sayhello.c -o libsayhello.so
</span><span class="line">或
</span><span class="line">$ gcc -O2 -fPIC -c sayhello.c
</span><span class="line">$ gcc -shared -o libsayhello.so sayhello.o</span></code></pre></td></tr></table></div></figure>

<p>其中</p>

<ul>
  <li>fPIC:产生与位置无关码，全部使用相对地址</li>
  <li>shared:生成动态库</li>
</ul>

<p>调用动态库的示例代码：</p>

<figure class="code"><figcaption><span>lang: test_hello_shared.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;dlfcn.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define LIB &quot;./libsayhello.so&quot;</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">void</span> <span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="n">LIB</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">dl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error:faile to load libary.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="s">&quot;helloworld&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">func</span><span class="p">();</span>
</span><span class="line">    <span class="n">dlclose</span><span class="p">(</span><span class="n">dl</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">动态库和静态库整合</h3>

<h3 id="section-4">参考文档</h3>

<ol>
  <li><a href="http://answerywj.com/2016/10/10/Linux%E4%B8%8BC%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">Linux下C调用静态库和动态库</a></li>
  <li><a href="https://liam0205.me/2017/04/03/not-to-link-libstdc-statically-and-why/">为什么不能再动态库里静态链接</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何理解内存对齐]]></title>
    <link href="http://lazybing.github.io/blog/2018/08/22/memory-alignment/"/>
    <updated>2018-08-22T08:23:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/08/22/memory-alignment</id>
    <content type="html"><![CDATA[<p>数据对齐会影响到计算机访问内存以及占用内存的空间大小。</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">对齐要求</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">填充</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结构体的对齐和填充</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">结构体成员重排</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可读性与缓存局部性</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">代码测试示例</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">参考文档</a></li>
</ul>

<h3 id="section">对齐要求</h3>

<p>在<code>X86</code>或<code>ARM</code>处理器中，基本 C 数据类型通常并不存储于内存中的随机字节地址。实际情况是，除<code>char</code>外，
所有其他类型都有对齐要求：<code>char</code>可起始于任意字节地址，2 字节的 short 必须从偶数字节地址开始，4 字节<code>int</code>或<code>float</code>必须
从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从
能被 8 整除的地址开始。无论<code>signed(有符号)</code>还是<code>unsigned(无符号)</code>都不受影响。</p>

<p>简言之，<code>X86</code>和<code>ARM</code>的基本 C 类型是<code>自对齐(self-aligned)</code>的。关于指针，无论 32 位还是 64 位也都是自对齐的。</p>

<p>自对齐可令访问速度更快，因为它有利于生成单指令(single-instruction)存取这些类型的数据。另一方面，如若没有对齐约束，可能
最终不得不通过两个或更多指令访问跨越机器字边界的数据。字符数据是种特殊情况，因其始终处在单一机器字中，所以无论存取何处的字符数据，
开销都是一致的。这也就是它不需要对齐的原因。</p>

<h3 id="section-1">填充</h3>

<p>假设我们有如下一段 C 代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int function(void)
</span><span class="line">{
</span><span class="line">    char *pchar;
</span><span class="line">    char ch;
</span><span class="line">    int idx;
</span><span class="line">    ...
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>这里的占用字节空间如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *pchar;    //4 or 8 bytes
</span><span class="line">char ch;        //1 byte
</span><span class="line">char pad[3];    //3 bytes, 3 个字节的空间被浪费掉了
</span><span class="line">int idx;        //4 bytes
</span><span class="line">...</span></code></pre></td></tr></table></div></figure>

<p>如果 <code>x </code>为 2 字节 short：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *p;
</span><span class="line">char c;
</span><span class="line">short x;</span></code></pre></td></tr></table></div></figure>

<p>时间分布为:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *p;    //4 or 8 bytes
</span><span class="line">char c;     //1 byte
</span><span class="line">char pad[1];    //1 byte, 1 字节的空间被浪费掉了
</span><span class="line">short x;        //2 bytes</span></code></pre></td></tr></table></div></figure>

<p>更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-2">结构体的对齐和填充</h3>

<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>

<p>思考如下的结构体：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo1{
</span><span class="line">    char *p;
</span><span class="line">    char c;
</span><span class="line">    long x;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>64 位系统中，任何<code>struct foo1</code>的实例都采用 8 字节对齐，其内存分布如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo1{
</span><span class="line">    char *p;    //8 bytes
</span><span class="line">    char c;     //1 byte
</span><span class="line">    char pad[7];    // 7 bytes
</span><span class="line">    long x;         // 8 bytes
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>
<p>更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-3">结构体成员重排</h3>

<p>理解了结构体成员的对齐后，可以看到，最简单的节省内存的方式，是按对齐递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为
在 64 为系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。</p>

<p>以简单的链表结构为例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo7{
</span><span class="line">    char c;
</span><span class="line">    struct foo7 *p;
</span><span class="line">    short x;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>
<p><code>sizeof(foo7)</code>占用 24 字节。如果按照长度重排，可以得到:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo8{
</span><span class="line">    struct foo8 *p;
</span><span class="line">    short x;
</span><span class="line">    char c;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>重新打包后，空间降低为 16 字节。</p>

<h3 id="section-4">可读性与缓存局部性</h3>

<p>笨拙地、机械地重排结构体可能有损可读性。最好重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>

<h3 id="section-5">代码测试示例</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdbool.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo1</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo2</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="cm">/* 7 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="cm">/* 8 bytes */</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>      <span class="cm">/* 8 bytes */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo3</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="cm">/* 8 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo4</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">s</span><span class="p">;</span>     <span class="cm">/* 2 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo5</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo5_inner</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="n">inner</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo6</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">flip</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">nybble</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">septet</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo7</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo8</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield1</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield1</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield2</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield2</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo9</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield1</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield2</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield1</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield2</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo10</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo10</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo11</span> <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo11</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo12</span> <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo12_inner</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="n">inner</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(char *)        = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(long)          = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(int)           = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(short)         = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(char)          = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(float)         = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(double)        = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo1)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo1</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo2)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo2</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo3)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo3</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo4)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo4</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo5)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo5</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo6)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo6</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo7)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo7</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo8)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo8</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo9)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo9</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo10)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo10</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo11)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo11</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo12)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo12</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-6">参考文档</h3>

<ol>
  <li><a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">The Lost Art Of C Structure Packing</a></li>
  <li><a href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Memory Alignment</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data Structure Alignment</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从FFMpeg中提取CODEC(以TTA Decoder为例)]]></title>
    <link href="http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg/"/>
    <updated>2018-05-06T07:55:35-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#tta-" id="markdown-toc-tta-">TTA 简介</a></li>
  <li><a href="#ffmpeg--tta-decoder" id="markdown-toc-ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</a></li>
  <li><a href="#tta-decoder-" id="markdown-toc-tta-decoder-">提取 TTA Decoder 中可能遇到的问题</a></li>
  <li><a href="#tta-decoder--1" id="markdown-toc-tta-decoder--1">提取 TTA Decoder 实现</a></li>
</ul>

<p><a href="https://ffmpeg.org/">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理。最近一直做得工作是从 FFMpeg 中提取特定的编解码器，本位以最简单的 TTA Decoder 为例，介绍如何同 FFMpeg 中提取 CODEC。</p>

<!--more-->

<h2 id="tta-">TTA 简介</h2>

<p>TTA(The True Audio Codec) 是免费、简单、实时无损视频压缩。基于 Adaptive Prognostic Filters, TTA 同其他同类的开源项目有强竞争力。</p>

<h2 id="ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</h2>

<p>FFMpeg 中关于 TTA Decoder 的部分在<code>libavcodec/tta.c</code>中定义:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AVCodec ff_tta_decoder = {
</span><span class="line">    .name           = "tta",
</span><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL("TTA (True Audio)"),
</span><span class="line">    .type           = AVMEDIA_TYPE_AUDIO,
</span><span class="line">    .id             = AV_CODEC_ID_TTA,
</span><span class="line">    .priv_data_size = sizeof(TTAContext),
</span><span class="line">    .init           = tta_decode_init,
</span><span class="line">    .close          = tta_decode_close,
</span><span class="line">    .decode         = tta_decode_frame,
</span><span class="line">    .init_thread_copy = ONLY_IF_THREADS_ENABLED(init_thread_copy),
</span><span class="line">    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
</span><span class="line">    .priv_class       = &amp;tta_decoder_class,
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>从 TTA AVCodec 的定义可以看出，Decoder 的主要函数只有三个<code>tta_decode_init</code>、<code>tta_decode_frame</code>、<code>tta_decode_close</code>三部分。其中 init 部分主要是解析 TTA Header 信息，decode 部分是真正解码部分，close 主要是释放内存。</p>

<p>不管是硬件解码还是软件解码，Decoder 部分一般都包含六部分：解码器初始化、解码器释放、设置压缩数据给解码器、从解码器获取解码后的数据、设置参数给解码器、从解码器获取参数信息。因此我们可以按照上面的思路，将 FFMpeg 中的这几个函数拆分成相应的函数。</p>

<h2 id="tta-decoder-">提取 TTA Decoder 中可能遇到的问题</h2>

<h2 id="tta-decoder--1">提取 TTA Decoder 实现</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[音频概念介绍(采样频率、帧率、通道数等)]]></title>
    <link href="http://lazybing.github.io/blog/2018/03/25/audio-basic-concept/"/>
    <updated>2018-03-25T08:54:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/03/25/audio-basic-concept</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">音频基础概述</a></li>
  <li><a href="#pcm-" id="markdown-toc-pcm-">PCM 数据摆放格式</a></li>
</ul>

<p>最近在给现代汽车做一个从 FFMpeg 中提取各个音频解码器的项目，很多都是音频。因为之前做的大多数都是视频项目，音频知识比较匮乏。限制记录一下。
<!--more--></p>

<h2 id="section">音频基础概述</h2>

<p>首先我们用 MediaInfo 来看下音频流的一些信息如图所示：</p>

<p><img src="http://lazybing.github.io/images/audio_basic_concept/audio_basic_format.png" /></p>

<p>逐个分析：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Format:AC-3
</span><span class="line">Format/Info:Audio Coding 3
</span><span class="line">Duration:33s 984ms
</span><span class="line">Bit rate:448 Kbps
</span><span class="line">Channel(s):6 channels
</span><span class="line">Channel positions: Front:L C R, Side:L R LFE
</span><span class="line">Sampling rate:48.0KHz
</span><span class="line">Bit depth:16bits
</span><span class="line">Frame rate:31.250 fps </span></code></pre></td></tr></table></div></figure>

<p>采样率(sampling rate)：声音信号在”模数”转换过程中单位时间内采样的次数。采样率是指每一次采样周期内声音模拟信号的数值，一般的采样率包括：8kHz/11.025kHz/22.05kHz/16kHz/37.8kHz/44.1kHz/48kHz。</p>

<p>帧率(Frame rate):每秒钟中帧数，单位是fps，如上面的 31.250 fps。</p>

<p>通道数(channels):声音的通道数，常用的有单声道和立体声之分。上面的声道数是 6 通道。</p>

<p>比特率(bit rate):每秒的传输速率(比特率)。</p>

<p>bitspersample:每个 sample 占用的 bits 数。</p>

<h2 id="pcm-">PCM 数据摆放格式</h2>

<p>在做项目的过程中，经常用到的一点是在输出 PCM 数据时，经常要了解 PCM 的摆放格式。根据不同的 bps 和 channels，数据的摆放时不同的。</p>

<p><img src="http://lazybing.github.io/images/audio_basic_concept/pcm_channels_bps.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELF格式分析手册]]></title>
    <link href="http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial/"/>
    <updated>2018-03-21T07:30:48-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#elf-data-type" id="markdown-toc-elf-data-type">ELF Data Type</a></li>
  <li><a href="#the-elf-header" id="markdown-toc-the-elf-header">The ELF Header</a></li>
  <li><a href="#checking-the-elf-header" id="markdown-toc-checking-the-elf-header">Checking the ELF Header</a></li>
  <li><a href="#loading-the-elf-file" id="markdown-toc-loading-the-elf-file">Loading the ELF File</a></li>
</ul>

<p>本文主要记录目标文件是<code>i386(32位架构、小端序)ELF</code>文件的加载过程。本文中的所有代码都是 C 风格，所有代码段都会使用最简单的例子。后面可能会扩展到其他类型的 ELF 文件。
<!--more--></p>

<h1 id="elf-data-type">ELF Data Type</h1>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdint.h&gt;</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">Elf32_Half</span><span class="p">;</span>    <span class="c1">//Unsigned half int</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Off</span><span class="p">;</span>     <span class="c1">//Unsigned offset</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Addr</span><span class="p">;</span>    <span class="c1">//Unsigned address</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Word</span><span class="p">;</span>    <span class="c1">//Unsigned int</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">int32_t</span>  <span class="n">Elf32_Sword</span><span class="p">;</span>   <span class="c1">//Signed int</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="the-elf-header">The ELF Header</h1>

<p>每个 ELF 格式文件都有位于文件开始的头部<code>Header</code>。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define ELF_NIDENT 16</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class="line">    <span class="kt">uint8_t</span>     <span class="n">e_ident</span><span class="p">[</span><span class="n">ELF_NIDENT</span><span class="p">];</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_type</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_machine</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_version</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Addr</span>  <span class="n">e_entry</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Off</span>   <span class="n">e_phoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Off</span>   <span class="n">e_shoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_flags</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_ehsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_flags</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_ehsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phentsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phnum</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shentsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shnum</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shstrndx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="n">ELF32_Ehdr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">enum</span> <span class="n">Elf_Ident</span><span class="p">{</span>
</span><span class="line">    <span class="n">EI_MAG0</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//0x7F</span>
</span><span class="line">    <span class="n">EI_MAG1</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//‘E’</span>
</span><span class="line">    <span class="n">EI_MAG2</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">//‘L’</span>
</span><span class="line">    <span class="n">EI_MAG3</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">//‘F’</span>
</span><span class="line">    <span class="n">EI_CLASS</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">//Architecture(32/64)</span>
</span><span class="line">    <span class="n">EI_DATA</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="c1">//Byte Order</span>
</span><span class="line">    <span class="n">EI_VERSION</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="c1">//ELF Version</span>
</span><span class="line">    <span class="n">EI_OSABI</span>   <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="c1">//OS Specific</span>
</span><span class="line">    <span class="n">EI_ABIVERSION</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="c1">//OS Specific</span>
</span><span class="line">    <span class="n">EI_PAD</span>        <span class="o">=</span> <span class="mi">9</span>  <span class="c1">//Padding</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define ELFMAG0    0x7F   </span><span class="c1">//e_ident[EI_MAG0]</span>
</span><span class="line"><span class="cp">#define ELFMAG1    &#39;E&#39;    </span><span class="c1">//e_ident[EI_MAG1]</span>
</span><span class="line"><span class="cp">#define ELFMAG2    &#39;L&#39;    </span><span class="c1">//e_ident[EI_MAG2]</span>
</span><span class="line"><span class="cp">#define ELFMAG3    &#39;F&#39;    </span><span class="c1">//e_ident[EI_MAG3]</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define ELFDATA2LSB (1)   </span><span class="c1">//Little Endian</span>
</span><span class="line"><span class="cp">#define ELFCLASS32  (1)   </span><span class="c1">//32-bit Architecture</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">enum</span> <span class="n">Elf_Type</span><span class="p">{</span>
</span><span class="line">    <span class="n">ET_NONE</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//Unknown Type</span>
</span><span class="line">    <span class="n">ET_REL</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//Relocatable File</span>
</span><span class="line">    <span class="n">ET_EXEC</span>    <span class="o">=</span> <span class="mi">2</span>  <span class="c1">//Executable File</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="cp">#define EM_386     (3) </span><span class="c1">//x86 Machine Type</span>
</span><span class="line"><span class="cp">#define EV_CURRENT (1) </span><span class="c1">//ELF Current Version</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="checking-the-elf-header">Checking the ELF Header</h1>

<p>在对<code>ELF</code>文件进行加载、链接、重定向或其他操作之前，首先要确保机器是否支持上述的操作。</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">bool</span> <span class="nf">elf_check_file</span><span class="p">(</span><span class="n">Elf32_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG0</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG0 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG1</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG1 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG2</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG2 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG3</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG2 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">bool</span> <span class="nf">elf_check_supported</span><span class="p">(</span><span class="n">ELF32_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">elf_check_file</span><span class="p">(</span><span class="n">hdr</span><span class="p">)){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Invalid ELF File.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_CLASS</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFCLASS32</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File Class.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFDATA2LSB</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File byte order.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">!=</span> <span class="n">EM_386</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File target.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_VERSION</span><span class="p">]</span> <span class="o">!=</span> <span class="n">EV_CURRENT</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File version.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_REL</span> <span class="o">&amp;&amp;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File type.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="loading-the-elf-file">Loading the ELF File</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汇编语言实现hello World]]></title>
    <link href="http://lazybing.github.io/blog/2018/01/11/assemble-hello-world/"/>
    <updated>2018-01-11T21:29:27-08:00</updated>
    <id>http://lazybing.github.io/blog/2018/01/11/assemble-hello-world</id>
    <content type="html"><![CDATA[
<p>接下来的工作可能要用到汇编语言。</p>

<!--more-->

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">.data                   # section declaration
</span><span class="line">msg:
</span><span class="line">    .ascii  "Hello, world!\n"   # our dear string
</span><span class="line">    len = . - msg               # length of our dear string
</span><span class="line">
</span><span class="line">.text                           # section declaration
</span><span class="line">
</span><span class="line">                            # we must export the entry point to the ELF linker or
</span><span class="line">    .global _start          # loader. They conventionally recognize _start as their 
</span><span class="line">                            # entry point. Use ld -e foo to override the default.
</span><span class="line">
</span><span class="line">_start:
</span><span class="line">
</span><span class="line"># write our string to stdout
</span><span class="line">    
</span><span class="line">    movl $len, %edx        # third argument:message length
</span><span class="line">    movl $msg, %ecx        # second argument:pointer to message to write
</span><span class="line">    movl $1, %ebx          # first argument:file handle(stdout) 
</span><span class="line">    movl $4, %eax          # system call number (sys_write)
</span><span class="line">    int  $0x80             # call kernel
</span><span class="line">
</span><span class="line"># and exit
</span><span class="line">
</span><span class="line">    movl $0, %ebx           # first argument:exit code
</span><span class="line">    movl $1, %eax           # system call number (sys_exit)
</span><span class="line">    int  $0x80              # call kernel</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之x264_macroblock_encode函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode/"/>
    <updated>2017-12-25T19:52:38-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#x264macroblockencode-" id="markdown-toc-x264macroblockencode-">x264_macroblock_encode 概述</a>    <ul>
      <li><a href="#ipcm-" id="markdown-toc-ipcm-">I_PCM 编码模式</a></li>
      <li><a href="#pskip--bskip-" id="markdown-toc-pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于<code>x264_macroblock_encode</code>函数的分析，该函数主要变换和量化，对应 X264 中的宏块编码模块。<br />
<!--more--></p>

<h2 id="x264macroblockencode-">x264_macroblock_encode 概述</h2>

<p>该函数主要在<code>x264_slice_write()</code>函数调用，它主要完成了编码器中的变换、量化部分，该函数主要是封装了<code>x264_macroblock_encode_internal()</code>函数，它包括如下几个步骤：</p>

<figure class="code"><figcaption><span>x264_macroblock_encode </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_macroblock_encode</span><span class="p">(</span><span class="kt">x264_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">CHROMA444</span><span class="p">)</span>
</span><span class="line">        <span class="n">x264_macroblock_encode_internal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">        <span class="n">x264_macroblock_encode_internal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<ol>
  <li>如果宏块类型为 PCM 类型，直接存储重建帧数据。</li>
  <li>如果宏块类型为 Skip 类型，调用<code>x264_macroblock_encode_skip()</code>编码 Skip 类型宏块，包括<code>P_SKIP</code>和<code>B_SKIP</code>类型。</li>
  <li>如果宏块类型为<code>I_16x16</code>，调用<code>x264_mb_encode_i16x16()</code>编码 Intra 16x16 类型的宏块，该函数除了进行 DCT 变换之外，还对 16 个小块的 DC 系数进行 Hadamard 变换。</li>
  <li>如果宏块类型为<code>I_4x4</code>，调用<code>x264_mb_encode_i4x4()</code>编码 Intra 4x4 类型的宏块。</li>
  <li>帧间宏块编码，该部分并没有单独的函数完成，而是写在了<code>x264_macroblock_encode_internal</code>函数内部。</li>
  <li>调用<code>x264_mb_encode_chroma()</code>函数编码色度卡。</li>
</ol>

<h3 id="ipcm-">I_PCM 编码模式</h3>

<p>I_PCM 是一种帧内编码模式，在该模式下，编码器直接传输图像的像素值，而不经过预测和变换。在一些特殊的情况下，特别是图像
内容不规则或者量化参数非常低时，该模式比常规的操作（帧内预测-变换-量化-编码）效率更高。</p>

<p>I_PCM 模式用于以下目的：</p>

<ol>
  <li>允许编码器精确地表示像素值。</li>
  <li>提供表示不规则图像内容的准确性，而不引起重大的数据量增加。</li>
  <li>严格限制宏块解码比特数，但不降低编码效率。</li>
</ol>

<p>对 I_PCM 类型的编码，实现代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="p">...</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_type</span> <span class="o">==</span> <span class="n">I_PCM</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">//if PCM is chosen, we need to store reconstructed frame data</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">plane_count</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_16x16</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">chroma</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">&gt;&gt;</span> <span class="n">CHROMA_V_SHIFT</span><span class="p">;</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_8x8</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_8x8</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</h3>

<ul>
  <li>P_Skip 类型宏块：即 COPY 宏块，无像素残差，无运动矢量残差(MVD)。直接利用预测 MV 得到的像素预测值。像素重构值= 像素预测值。</li>
  <li>B_Skip 类型宏块：无像素残差，无运动矢量残差(MVD)。解码时，通过 Direct 预测模式(时间或空间)计算出前、后向 MV 后，直接利用前、后向 MV 得到像素预测值。像素重构值 = 像素预测值。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之x264_macroblock_analyse函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/11/13/x264-macroblock-analyse/"/>
    <updated>2017-11-13T07:06:23-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/11/13/x264-macroblock-analyse</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">宏块分析概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">帧内预测</a>    <ul>
      <li><a href="#intra16x16-" id="markdown-toc-intra16x16-">Intra16x16 预测模式分析</a></li>
      <li><a href="#intra4x4-" id="markdown-toc-intra4x4-">Intra4x4 预测模式分析</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">帧间预测</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">运动补偿块</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">运动矢量</a></li>
      <li><a href="#mv-" id="markdown-toc-mv-">MV 预测</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">帧间预测函数分析</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于<code>x264_macroblock_analyse</code>函数的分析，该函数主要完成 2 个任务：对于帧内宏块，分析帧内预测模式；对于帧间宏块，进行运动估计、分析帧间预测模式。 <br />
<!--more--></p>

<h2 id="section">宏块分析概述</h2>

<p>首先看一下<code>x264_macroblock_analyse</code>函数实现过程的大体过程：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void x264_macroblock_analyse(x264_t *)
</span><span class="line">{
</span><span class="line">    h-&gt;mb.i_qp = x264_ratecontrol_mb_qp(h); //get QP of the MB
</span><span class="line">    ...
</span><span class="line">    x264_mb_analyse_init(h, &amp;analysis, h-&gt;mb.i_qp);
</span><span class="line">
</span><span class="line">    if(h-&gt;sh.i_type == SLICE_TYPE_I)
</span><span class="line">    {
</span><span class="line">        x264_mb_analyse_intra(h, &amp;analysis, CONST_MAX);
</span><span class="line">    }
</span><span class="line">    else if(h-&gt;sh.i_type == SLICE_TYPE_P)
</span><span class="line">    {
</span><span class="line">        x264_macroblock_probe_pskip(h);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p16x16(h, &amp;analysis);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p8x8(h, &amp;analysis);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p4x4(h, &amp;analysis, i);
</span><span class="line">        
</span><span class="line">        x264_mb_analyse_inter_p8x4(h, &amp;analysis, i);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p4x8(h, &amp;analysis, i);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p16x8(h, &amp;analysis, i_cost);
</span><span class="line">
</span><span class="line">        x264_mb_analyse_inter_p8x16(h, &amp;analysis, i_cost);
</span><span class="line">
</span><span class="line">        x264_me_refine_qpel(h, &amp;analysis.xxxx);
</span><span class="line">    }
</span><span class="line">    else if(h-&gt;sh.i_type == SLICE_TYPE_B)
</span><span class="line">    {
</span><span class="line">        x264_mb_analyse_inter_b16x16(h, &amp;analysis);
</span><span class="line">        x264_mb_analyse_inter_b8x8( h, &amp;analysis );
</span><span class="line">        x264_mb_analyse_inter_b16x8( h, &amp;analysis );
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>上面只是给出了该函数中调用的函数，并没有给出实际编码中的逻辑判断。它的实现如下：</p>

<ol>
  <li>如果当前是I Slice, 调用<code>x264_mb_analyse_intra()</code>进行Intra宏块的帧内预测模式分析。</li>
  <li>如果当前是P Slice, 则进行下面流程的分析：</li>
</ol>

<blockquote>
  <p>a.调用<code>x264_macroblock_probe_pskip()</code>分析是否为skip宏块，如果是skip宏块，则不再进行下面分析。<br />
b.调用<code>x264_mb_analyse_inter_p16x16()</code>分析P16x16帧间预测的代价。<br />
c.调用<code>x264_mb_analyse_inter_p8x8</code>分析P8x8帧间预测的代价。<br />
d.如果 P8x8 代价值小于 P16x16，则依次对 4 个 8x8 的子宏块分割进行判断： <br />
 * 调用<code>x264_mb_analyse_inter_p4x4()</code>分析 P4x4 帧间预测的代价。<br />
 * 如果P4x4代价值小于P8x8，则调用<code>x264_mb_analyse_inter_p8x4()</code>和<code>x264_mb_analyse_inter_p4x8()</code>分析P8x4和P4x8帧间预测的代价。<br />
e.如果P8x8代价值小于P16x16,调用<code>x264_mb_analyse_inter_p16x8()</code>和<code>x264_mb_analyse_inter_p8x16()</code>分析P16x8和P8x16帧间预测的代价。<br />
f.此外，还要调用<code>x264_mb_analyse_intra()</code>，检查当前宏块作为 Intra 宏块编码的代价是否小于作为 P 宏块编码的代价。</p>
</blockquote>

<ol>
  <li>如果当前是B Slice，则进行和 P Slice 类似的处理。</li>
</ol>

<h2 id="section-1">帧内预测</h2>

<p>帧内预测模式种，预测块 P 是基于已编码重建块和当前块形成的，对亮度像素来说，P 块用于 4x4 子块或者 16x16 宏块的相关操作。其中 4x4 宏块，有 9 种可选预测模式，适用于
带有大量细节的图像编码；16x16 宏块适用于比较平坦的图像，该宏块有 4 种预测模式，预测整个 16x16 亮度块。色度块也有 4 种预测模式，与 16x16 亮度块预测模式类似。编码器
通常会选择使 P 块和编码块之间差异最小的预测模式。</p>

<p>除此之外，还有一种帧内预测模式称为 I_PCM 编码模式。该模式下，编码器直接传输图像像素值，而不经过预测和变换。在一些特殊的情况下，特别是
图像内容不规则或者量化参数非常低时该模式比常规操作(帧内预测-变换-量化-熵编码)效率更高。I_PCM 模式用于以下目的：</p>

<ol>
  <li>允许编码器精确的表示像素值</li>
  <li>提供表示不规则图像内容的准确值，而不引起重大的数据量增加</li>
  <li>严格限制宏块解码比特数，但不损害编码效率</li>
</ol>

<p>关于帧内预测的原理介绍部分，参考<a href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/">X264 源码解析之帧内预测</a>。</p>

<p><code>x264_mb_analyse_intra</code>中关于帧内预测模式的选择判断，整体思路是，遍历所有可能的预测模式，包括 4 种 16x16 的预测模式、9 种 4x4 的预测模式，具体流程如下：</p>

<h3 id="intra16x16-">Intra16x16 预测模式分析</h3>
<p>对于非<code>AVC-Intra Compat</code>，首先根据当前宏块左边、上边宏块的可参考情况，判断该宏块可能存在的预测模式。
对于每个宏块，根据重建宏块和预测模式，调用<code>predict_16x16[]</code>做帧内预测;调用<code>x264_pixel_function_t</code>中的<code>mbcmp[]</code>计算编码代价。
选择最小的编码代价，记录编码代价的值，并记录编码模式。核心代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="p">...</span>
</span><span class="line"><span class="k">for</span><span class="p">(;</span> <span class="o">*</span><span class="n">predict_mode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">predict_mode</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i_satd</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i_mode</span> <span class="o">=</span> <span class="o">*</span><span class="n">predict_mode</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">b_lossless</span><span class="p">)</span>
</span><span class="line">        <span class="n">x264_predict_lossless_16x16</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i_mode</span><span class="p">);</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">predict_16x16</span><span class="p">[</span><span class="n">i_mode</span><span class="p">](</span><span class="n">p_dst</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">i_satd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">pixf</span><span class="p">.</span><span class="n">mbcmp</span><span class="p">[</span><span class="n">PIXEL_16x16</span><span class="p">](</span><span class="n">p_dst</span><span class="p">,</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">psr</span><span class="p">,</span> <span class="n">FENC_STRIDE</span><span class="p">)</span> <span class="o">+</span>
</span><span class="line">        <span class="n">lambda</span> <span class="o">*</span> <span class="n">bs_size_ue</span><span class="p">(</span><span class="n">x264_mb_pred_mode16x16_fix</span><span class="p">[</span><span class="n">i_mode</span><span class="p">]);</span>
</span><span class="line">    <span class="n">COPY2_IF_LT</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">i_satd_i16x16</span><span class="p">,</span> <span class="n">i_satd</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">i_predict16x16</span><span class="p">,</span> <span class="n">i_mode</span><span class="p">);</span>
</span><span class="line">    <span class="n">a</span><span class="o">-&gt;</span><span class="n">i_satd_i16x16_dir</span><span class="p">[</span><span class="n">i_mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_satd</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="intra4x4-">Intra4x4 预测模式分析</h3>

<p>循环处理 16 个 4x4 的块：首先调用<code>x264_mb_predict_intra4x4_mode()</code>函数根据周围宏块情况判断该宏块可用的预测模式。之后循环计算 9 种 Intra4x4 的帧内预测模式，调用<code>predict_4x4[]</code>函数根据重建帧宏块进行帧内预测，调用<code>x264_pixel_funtion_t</code>中的<code>mbcmp[]</code>计算编码代码。
获取最小代缴的 Intra4x4 模式。将 16 个 4x4 宏块的最小代价相加，得到总代价。核心代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="p">...</span>
</span><span class="line"><span class="k">const</span> <span class="kt">int8_t</span> <span class="o">*</span><span class="n">predict_mode</span> <span class="o">=</span> <span class="n">predict_4x4_mode_available</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">b_avoid_topright</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_neighbour4</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">idx</span><span class="p">);</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">predict_mode</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">predict_mode</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i_satd</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i_mode</span> <span class="o">=</span> <span class="o">*</span><span class="n">predict_mode</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">b_lossless</span> <span class="p">)</span>
</span><span class="line">        <span class="n">x264_predict_lossless_4x4</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">p_dst_by</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i_mode</span> <span class="p">);</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">predict_4x4</span><span class="p">[</span><span class="n">i_mode</span><span class="p">](</span> <span class="n">p_dst_by</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">i_satd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">pixf</span><span class="p">.</span><span class="n">mbcmp</span><span class="p">[</span><span class="n">PIXEL_4x4</span><span class="p">](</span> <span class="n">p_dst_by</span><span class="p">,</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">p_src_by</span><span class="p">,</span> <span class="n">FENC_STRIDE</span> <span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">i_pred_mode</span> <span class="o">==</span> <span class="n">x264_mb_pred_mode4x4_fix</span><span class="p">(</span><span class="n">i_mode</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">i_satd</span> <span class="o">-=</span> <span class="n">lambda</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">i_satd</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">i_best</span> <span class="o">=</span> <span class="n">i_satd</span><span class="p">;</span>
</span><span class="line">            <span class="n">a</span><span class="o">-&gt;</span><span class="n">i_predict4x4</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_mode</span><span class="p">;</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">COPY2_IF_LT</span><span class="p">(</span> <span class="n">i_best</span><span class="p">,</span> <span class="n">i_satd</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">i_predict4x4</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">i_mode</span> <span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-2">帧间预测</h2>

<p>帧间预测时指利用视频时间域相关性，使用临近已编码图像像素预测当前图像的像素，以达到有效去除视频时域冗余的目的。
由于视频序列通常包括较强的时域相关性，因此预测残差值接近于0，将残差信号作为后续模块的输入进行变换、量化、扫描、熵编码，可实现对视频信号的高效压缩。</p>

<p>接下来主要介绍基于<code>Baseline Profile</code>支持的 P 帧预测模式工具以及<code>Main Profile</code>和<code>Extended Profile</code>支持的 B 帧和加权预测等帧间预测工具。</p>

<h3 id="section-3">运动补偿块</h3>

<p>每个宏块(16x16 像素)可分割为 4 种方式：一个 16x16,两个 16x8, 两个 8x16,四个 8x8。其运动补偿也有相应的四种。8x8 模式的每个子宏块还
可以继续分割，分割方式为：一个 8x8，两个 4x8，两个 8x4，四个 4x4。</p>

<p>每个分割或子宏块都有一个独立的运动补偿。每个 MV 必须被编码、传输，分割的选择也需要编码到压缩码流中。对于大的尺寸而言，MV 选择和分割
类型只需少量的比特，但运动补偿残差在多细节区域能量将非常高。小尺寸分割运动补偿残差能量低，但需要较多的比特表示 MV 和分割选择。分割
尺寸的选择影响了压缩性能。整体而言，大的分割尺寸适合平坦的区域，而小尺寸适合多细节区域。</p>

<p>宏块的色度成分(Cr 和 Cb)则为相应亮度的一半(水平和垂直各一半)。色度块采用和亮度块同样的分割模式，只是尺寸减半(水平和垂直方向都减半)。
例如，8x16 的亮度块相应色度块尺寸为 4x8，8x4 亮度块相应色度块尺寸为 4x2 等等。色度块的 MV 也是通过相应亮度 MV 水平和垂直分量减半而得。</p>

<h3 id="section-4">运动矢量</h3>

<p>帧间编码宏块的每个分割或子宏块都是从参考图像某一相同尺寸区域预测而得。两者之间的差异(MV)对亮度成分采用 1/4 像素精度，色度 1/8 像素精度。
亚像素位置的亮度和色度像素并不存在于参考图像中，需利用临近已编码点进行内插而得。如果 MV 的垂直和水平分量为正数，则参考块相应像素实际存在，
如果其中一个或两个为分数，则预测像素要通过参考帧中相应像素内插获得。</p>

<h3 id="mv-">MV 预测</h3>

<p>每个分割 MV 的编码需要相当数目的比特，特别是使用小分割尺寸时。为了减少传输比特数，可利用邻近分割的 MV 较强的相关性，MV 可由邻近已编码分割
的 MV 预测而得。预测矢量 MVp 基于已计算 MV 和 MVD（预测与当前的差异）并被编码和传送。MVp 则取决于运动补偿尺寸和邻近 MV 的有无。</p>

<p>示例如下：</p>

<p><img src="http://lazybing.github.io/images/macroblock_analyse/mv_prediction_macroblock.png" /></p>

<p>E 为当前宏块或宏块分割子宏块。A、B、C 分别为 E 的左、上、右上方的三个相对应块。如果 E 的左边不止一个分割，取其中最上的一个为 A；上方
不止一个分割时，取最左边一个为 B。</p>

<p>1)  传输分割不包括 16x8 和 8x16 时，MVP 为 A、B、C 分割 MV 的中值；<br />
2） 16x8 分割，上面部分 MVp 由 B 预测，下面部分 MVp 由 A 预测；<br />
3） 8x16 分割，左面部分 MVp 由 A 预测，右面部分 MVp 由 B 预测；<br />
4） skipped MB 类型同 1 。</p>

<h3 id="section-5">帧间预测函数分析</h3>

<p>帧间预测的帧类型大多是 P 帧或 B 帧。对于 P 帧，它的宏块分析流程为：</p>

<ol>
  <li>调用<code>x264_macroblock_probe_pskip()</code>分析是否为 Skip 宏块，如果是则不进行后面的分析。</li>
  <li>调用<code>x264_mb_analyse_inter_p16x16()</code>分析 P16x16 帧间预测的代价。</li>
  <li>调用<code>x264_mb_analyse_inter_p8x8()</code>分析 P8x8 帧间预测的代价。</li>
  <li>如果 P8x8 代价小于 P16x16, 则依次对 4 个 8x8 的子宏块分割进行判断：<br />
 i. 调用<code>x264_mb_analyse_inter_p4x4()</code>分析 P4x4 的帧间预测代价。<br />
 ii. 如果 P4x4 代价值小于 P8x8，则调用<code>x264_mb_analyse_inter_p8x4()</code>和<code>x264_mb_analyse_inter_p4x8()</code>分析 P8x4 和 P4x8 帧间预测的代价。</li>
  <li>如果 P8x8 代价值小于 P16x8，调用<code>x264_mb_analyse_inter_p16x8()</code>和<code>x264_mb_analyse_inter_p8x16()</code>分析 P16x8 和 P8x16 帧间预测的代价。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264源码解析之x264_bitstream_init函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/11/12/bitstream-init/"/>
    <updated>2017-11-12T06:48:31-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/11/12/bitstream-init</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#h264-spec-annex-b" id="markdown-toc-h264-spec-annex-b">H264 SPEC Annex B</a></li>
  <li><a href="#jm--annexb-" id="markdown-toc-jm--annexb-">JM 中关于 AnnexB 的源码分析</a></li>
  <li><a href="#x264--bitstream-" id="markdown-toc-x264--bitstream-">X264 中 Bitstream 的源码分析</a></li>
</ul>

<p>本文主要记录 X264 中对于 bitstream 的处理方法，它主要实现 SPEC 中<code>Annex B:Byte stream format</code>中的规定。
<!--more--></p>

<h2 id="h264-spec-annex-b">H264 SPEC Annex B</h2>

<p>首先看一下，H264 的 SPEC 中关于 Bitstream 中的规定。</p>

<figure class="code"><figcaption><span>AnndexB </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">byte_stream_nal_unit</span><span class="p">(</span><span class="n">NumBytesInNALunit</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">next_bits</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x000001</span> <span class="o">&amp;&amp;</span>
</span><span class="line">          <span class="n">next_bits</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x00000001</span><span class="p">)</span>
</span><span class="line">        <span class="n">leading_zero_8bits</span> <span class="c1">//equal to 0x00 f(8)</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">next_bits</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x000001</span><span class="p">)</span>
</span><span class="line">        <span class="n">zero_byte</span>  <span class="c1">//equal to 0x00 f(8)</span>
</span><span class="line">
</span><span class="line">    <span class="n">start_code_prefix_one_3bytes</span> <span class="c1">//equal to 0x000001 f(24)</span>
</span><span class="line">
</span><span class="line">    <span class="n">nal_unit</span><span class="p">(</span><span class="n">NumBytesInNALunit</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">more_data_in_byte_stream</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span><span class="line">          <span class="n">next_bits</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x000001</span> <span class="o">&amp;&amp;</span>
</span><span class="line">          <span class="n">next_bits</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x00000001</span><span class="p">)</span>
</span><span class="line">        <span class="n">trailing_zero_8bits</span> <span class="c1">//equal to 0x00 f(8)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>SPEC 中定义的解码的部分，因为我们根据上面的描述，可以理出 H264 的大致解析过程：</p>

<ol>
  <li>解码过程开始时，解码器把其当前的位置初始化为字节流的起始位置。然后提取，并丢弃每一个<code>leading_zero_8bits</code>语法元素(如果存在的话)，移动当前位置至某一时刻的字节处，直到比特流的当前位置紧接的四个字节为四字节序列<code>0x00000001</code>。</li>
  <li>当字节流里的紧接的四个字节构成四字节序列<code>0x00000001</code>，对比特流中下一个字节(为 zero_byte 语法元素)进行提取并丢弃时，字节流的当前位置设为紧接被丢弃的字节的字节位置。</li>
  <li>提取与丢弃比特流中下一个三字节序列(为 start_code_prefix_one_3bytes)，且比特流当前位置设为此紧接被丢弃的 3 字节序列的字节的位置。</li>
  <li>NumBytesInNALunit 设为自当前字节位置起至下述条件前的位置的最后一个字节，且包括最后一个字节的编号。
a. 一个三字节序列的排列等于<code>0x000000</code>，或
b. 字一个三字节序列的排列等于<code>0x000001</code>，或 
c. 字节流的结束，由未规定的方式判决。</li>
  <li>NumBytesInNALunit 字节从比特流中移除，字节流的当前位置前移 NumBytesInNALunit 字节。这个字节序列为 <code>nal_unit(NumBytesInNALunit)</code>,并用 NAL 单元解码过程进行解码。</li>
  <li>当字节流中的当前位置不为字节流的结尾(由未规定的方式判决)，且字节流中的下一个字节不是等于<code>0x000001</code>开始的三字节序列，也不是等于<code>0x00000001</code>开始的四字节序列。解码器提取并丢弃每一个<code>trailing_zero_8bits</code>语法元素，移动字节流中的当前位置到某一时刻的一个字节处，直到字节流里的当前位置接下来的四个字节构成四字节的序列<code>0x00000001</code>或已至字节流的结尾(由未规定的当时判决)。</li>
</ol>

<h2 id="jm--annexb-">JM 中关于 AnnexB 的源码分析</h2>

<p>在看<code>X264</code>源码之前，让我们先看一下 JM 中关于 AnnexB 的解码的源码实现部分。</p>

<p><code>JM</code>中关于 AnnexB 部分的描述在<code>jm\decod\src\annexb.c</code>中,首先看一下其中最重要的一个函数<code>int GetAnnexbNALU(NALU_t *nalu)</code>,该函数的声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/*
</span><span class="line"> * Brief: Returns the size of the NALU( bits between start codes in case of
</span><span class="line"> *        Annex B, nalu-&gt;buf and nalu-&gt;len are filled. Other field in
</span><span class="line"> *        nalu-&gt;remain uninitialized( will be taken care of by NALUtoRBSP.
</span><span class="line"> * Return: 0 if there is nothing any more to read(EOF)
</span><span class="line"> *         -1 in case of any error
</span><span class="line"> * note Side-effect: Returns length of start-code in bytes.
</span><span class="line"> * 
</span><span class="line"> * Note: GetAnnexbNALU expects start codes at byte aligned positions in the file
</span><span class="line"> */
</span><span class="line">int GetAnnexbNALU(NALU_t *nalu);</span></code></pre></td></tr></table></div></figure>

<p><code>GetAnnexbNALU</code>的定义如下：</p>

<figure class="code"><figcaption><span>GetAnnexbNALU </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">GetAnnexbNALU</span><span class="p">(</span><span class="n">NALU_t</span> <span class="o">*</span><span class="n">nalu</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">info2</span><span class="p">,</span> <span class="n">info3</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">StartCodeFound</span><span class="p">,</span> <span class="n">rewind</span><span class="p">;</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">Buf</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">LeadingZero8BitsCount</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">TrailingZero8Bits</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span> <span class="p">((</span><span class="n">Buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">max_size</span> <span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">no_mem_exit</span><span class="p">(</span><span class="s">&quot;GetAnnexbNALU: Buf&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="c1">//如果start_code前还有数据，丢弃start_code前leading_zero_8bits</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">fgetc</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">feof</span><span class="p">(</span><span class="n">bits</span><span class="p">))</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;GetAnnexbNALU can&#39;t read start code</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">      <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;GetAnnexbNALU: no Start Code at the begin of the NALU, return -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;GetAnnexbNALU: no Start Code at the begin of the NALU, return -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="n">LeadingZero8BitsCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">else</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">LeadingZero8BitsCount</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">    <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="c1">//the 1st byte stream NAL unit can has leading_zero_8bits, but subsequent ones are not</span>
</span><span class="line">  <span class="c1">//allowed to contain it since these zeros(if any) are considered trailing_zero_8bits</span>
</span><span class="line">  <span class="c1">//of the previous byte stream NAL unit.</span>
</span><span class="line">  <span class="c1">//字节流数据的第一个 NAL 单元才会有leading_zero_8bits;后面的 NALU 不会包含 leading_zero_8bits,</span>
</span><span class="line">  <span class="c1">//因为这些 leading_zero_8bits 会被看做前一个 NAL 单元后面的 trailing_zero_8bits</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">IsFirstByteStreamNALU</span> <span class="o">&amp;&amp;</span> <span class="n">LeadingZero8BitsCount</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;GetAnnexbNALU: The leading_zero_8bits syntax can only be present in the first byte stream NAL unit, return -1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">IsFirstByteStreamNALU</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="n">StartCodeFound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="n">info2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="n">info3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">StartCodeFound</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">feof</span> <span class="p">(</span><span class="n">bits</span><span class="p">))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="c1">//Count the trailing_zero_8bits</span>
</span><span class="line">      <span class="k">while</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">TrailingZero8Bits</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="n">TrailingZero8Bits</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">      <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span><span class="o">-</span><span class="n">LeadingZero8BitsCount</span><span class="o">-</span><span class="n">TrailingZero8Bits</span><span class="p">;</span>
</span><span class="line">      <span class="n">memcpy</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="n">LeadingZero8BitsCount</span><span class="o">+</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span><span class="p">],</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
</span><span class="line">      <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">forbidden_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">      <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_reference_idc</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">      <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_unit_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// printf (&quot;GetAnnexbNALU, eof case: pos %d nalu-&gt;len %d, nalu-&gt;reference_idc %d, nal_unit_type %d \n&quot;, pos, nalu-&gt;len, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);</span>
</span><span class="line">
</span><span class="line"><span class="cp">#if TRACE</span>
</span><span class="line">  <span class="n">fprintf</span> <span class="p">(</span><span class="n">p_trace</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">Last NALU in File</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="n">fprintf</span> <span class="p">(</span><span class="n">p_trace</span><span class="p">,</span> <span class="s">&quot;Annex B NALU w/ %s startcode, len %d, forbidden_bit %d, nal_reference_idc %d, nal_unit_type %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span> <span class="o">==</span> <span class="mi">4</span><span class="o">?</span><span class="s">&quot;long&quot;</span><span class="o">:</span><span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">forbidden_bit</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_reference_idc</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_unit_type</span><span class="p">);</span>
</span><span class="line">  <span class="n">fflush</span> <span class="p">(</span><span class="n">p_trace</span><span class="p">);</span>
</span><span class="line"><span class="cp">#endif</span>
</span><span class="line">      <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">      <span class="k">return</span> <span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//找 start_code，先找0x00000001,后找0x000001</span>
</span><span class="line">    <span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">fgetc</span> <span class="p">(</span><span class="n">bits</span><span class="p">);</span>
</span><span class="line">    <span class="n">info3</span> <span class="o">=</span> <span class="n">FindStartCode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">info3</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">      <span class="n">info2</span> <span class="o">=</span> <span class="n">FindStartCode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">    <span class="n">StartCodeFound</span> <span class="o">=</span> <span class="p">(</span><span class="n">info2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">info3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="c1">//Count the trailing_zero_8bits</span>
</span><span class="line">  <span class="c1">//计算 trailing_zero_8bits,如果start_code为0x000001,trailing_zero_8bits 肯定不存在</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">info3</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">//if the detected start code is 00 00 01, trailing_zero_8bits is sure not to be present</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">5</span><span class="o">-</span><span class="n">TrailingZero8Bits</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">      <span class="n">TrailingZero8Bits</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">// Here, we have found another start code (and read length of startcode bytes more than we should</span>
</span><span class="line">  <span class="c1">// have.  Hence, go back in the file</span>
</span><span class="line">  <span class="n">rewind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">info3</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="n">rewind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">info2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="n">rewind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
</span><span class="line">  <span class="k">else</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Panic: Error in next start code search </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">fseek</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">rewind</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">))</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">snprintf</span> <span class="p">(</span><span class="n">errortext</span><span class="p">,</span> <span class="n">ET_SIZE</span><span class="p">,</span> <span class="s">&quot;GetAnnexbNALU: Cannot fseek %d in the bit stream file&quot;</span><span class="p">,</span> <span class="n">rewind</span><span class="p">);</span>
</span><span class="line">    <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">    <span class="n">error</span><span class="p">(</span><span class="n">errortext</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">
</span><span class="line">  <span class="c1">// Here the leading zeros(if any), Start code, the complete NALU, trailing zeros(if any)</span>
</span><span class="line">  <span class="c1">// and the next start code is in the Buf.</span>
</span><span class="line">  <span class="c1">// The size of Buf is pos, pos+rewind are the number of bytes excluding the next</span>
</span><span class="line">  <span class="c1">// start code, and (pos+rewind)-startcodeprefix_len-LeadingZero8BitsCount-TrailingZero8Bits</span>
</span><span class="line">  <span class="c1">// is the size of the NALU.</span>
</span><span class="line">
</span><span class="line">  <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">rewind</span><span class="p">)</span><span class="o">-</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span><span class="o">-</span><span class="n">LeadingZero8BitsCount</span><span class="o">-</span><span class="n">TrailingZero8Bits</span><span class="p">;</span>
</span><span class="line">  <span class="n">memcpy</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Buf</span><span class="p">[</span><span class="n">LeadingZero8BitsCount</span><span class="o">+</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span><span class="p">],</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
</span><span class="line">  <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">forbidden_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_reference_idc</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">  <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_unit_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">nalu</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="c1">//printf (&quot;GetAnnexbNALU, regular case: pos %d nalu-&gt;len %d, nalu-&gt;reference_idc %d, nal_unit_type %d \n&quot;, pos, nalu-&gt;len, nalu-&gt;nal_reference_idc, nalu-&gt;nal_unit_type);</span>
</span><span class="line"><span class="cp">#if TRACE</span>
</span><span class="line">  <span class="n">fprintf</span> <span class="p">(</span><span class="n">p_trace</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">Annex B NALU w/ %s startcode, len %d, forbidden_bit %d, nal_reference_idc %d, nal_unit_type %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">startcodeprefix_len</span> <span class="o">==</span> <span class="mi">4</span><span class="o">?</span><span class="s">&quot;long&quot;</span><span class="o">:</span><span class="s">&quot;short&quot;</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">forbidden_bit</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_reference_idc</span><span class="p">,</span> <span class="n">nalu</span><span class="o">-&gt;</span><span class="n">nal_unit_type</span><span class="p">);</span>
</span><span class="line">  <span class="n">fflush</span> <span class="p">(</span><span class="n">p_trace</span><span class="p">);</span>
</span><span class="line"><span class="cp">#endif</span>
</span><span class="line">
</span><span class="line">  <span class="n">free</span><span class="p">(</span><span class="n">Buf</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="k">return</span> <span class="p">(</span><span class="n">pos</span><span class="o">+</span><span class="n">rewind</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>找<code>start_code</code>的定义如下,该函数的参数<code>zeros_in_startcode</code>可能为 3 或 4,寻找<code>0x000001</code>或<code>0x00000001</code>。</p>

<figure class="code"><figcaption><span>FindStartCode </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/*!</span>
</span><span class="line"><span class="cm"> ************************************************************************</span>
</span><span class="line"><span class="cm"> * \brief</span>
</span><span class="line"><span class="cm"> *    returns if new start code is found at byte aligned position buf.</span>
</span><span class="line"><span class="cm"> *    new-startcode is of form N 0x00 bytes, followed by a 0x01 byte.</span>
</span><span class="line"><span class="cm"> *</span>
</span><span class="line"><span class="cm"> *  \return</span>
</span><span class="line"><span class="cm"> *     1 if start-code is found or                      \n</span>
</span><span class="line"><span class="cm"> *     0, indicating that there is no start code</span>
</span><span class="line"><span class="cm"> *</span>
</span><span class="line"><span class="cm"> *  \param Buf</span>
</span><span class="line"><span class="cm"> *     pointer to byte-stream</span>
</span><span class="line"><span class="cm"> *  \param zeros_in_startcode</span>
</span><span class="line"><span class="cm"> *     indicates number of 0x00 bytes in start-code.</span>
</span><span class="line"><span class="cm"> ************************************************************************</span>
</span><span class="line"><span class="cm"> */</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="nf">FindStartCode</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zeros_in_startcode</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">info</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="n">info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">zeros_in_startcode</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">      <span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">Buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">    <span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="n">info</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="x264--bitstream-">X264 中 Bitstream 的源码分析</h2>

<p><code>X264</code>中关于<code>AnnexB</code>部分的描述主要是在<code>common/bitstream.c</code>中的<code>void x264_bitstream_init(int cpu, x264_bitstream_function_t *pf)</code>完成。
其中的<code>x264_bitstream_function_t</code>结构体定义如下：</p>

<figure class="code"><figcaption><span>x264_bitstream_function_t </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">typedef</span> <span class="k">struct</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">nal_escape</span><span class="p">)</span> <span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">end</span> <span class="p">);</span>
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cabac_block_residual_internal</span><span class="p">)(</span> <span class="n">dctcoef</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b_interlaced</span><span class="p">,</span>
</span><span class="line">                                           <span class="kt">intptr_t</span> <span class="n">ctx_block_cat</span><span class="p">,</span> <span class="kt">x264_cabac_t</span> <span class="o">*</span><span class="n">cb</span> <span class="p">);</span>
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cabac_block_residual_rd_internal</span><span class="p">)(</span> <span class="n">dctcoef</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b_interlaced</span><span class="p">,</span>
</span><span class="line">                                              <span class="kt">intptr_t</span> <span class="n">ctx_block_cat</span><span class="p">,</span> <span class="kt">x264_cabac_t</span> <span class="o">*</span><span class="n">cb</span> <span class="p">);</span>
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cabac_block_residual_8x8_rd_internal</span><span class="p">)(</span> <span class="n">dctcoef</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b_interlaced</span><span class="p">,</span>
</span><span class="line">                                                  <span class="kt">intptr_t</span> <span class="n">ctx_block_cat</span><span class="p">,</span> <span class="kt">x264_cabac_t</span> <span class="o">*</span><span class="n">cb</span> <span class="p">);</span>
</span><span class="line"><span class="p">}</span> <span class="kt">x264_bitstream_function_t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中<code>x264_bitstream_init</code>的定义如下：</p>

<figure class="code"><figcaption><span>X264_bitstream_init </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">X264_bitstream_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">x264_bitstream_function_t</span> <span class="o">*</span><span class="n">pf</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">memset</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">));</span>
</span><span class="line">    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">nal_escape</span> <span class="o">=</span> <span class="n">x264_nal_escape_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">cabac_block_residual_internal</span> <span class="o">=</span> <span class="n">x264_cabac_block_residual_internal_sse2</span><span class="p">;</span>
</span><span class="line">    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">cabac_block_residual_rd_internal</span> <span class="o">=</span> <span class="n">x264_cabac_block_residual_rd_internal_sse2</span><span class="p">;</span>
</span><span class="line">    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">cabac_block_residual_8x8_rd_internal</span> <span class="o">=</span> <span class="n">x264_cabac_block_residual_8x8_rd_internal_sse2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中的<code>x264_nal_escape_c</code>定义如下：</p>

<figure class="code"><figcaption><span>x264_nal_escape_c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="nf">x264_nal_escape_c</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">end</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">)</span> <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">)</span> <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">0x03</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dst</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">            <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x03</span><span class="p">;</span>
</span><span class="line">        <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>最后，给出 X264 中关于每个 NALU 的编码的实现：</p>

<figure class="code"><figcaption><span>x264_nal_encode </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/****************************************************************************</span>
</span><span class="line"><span class="cm"> * x264_nal_encode:</span>
</span><span class="line"><span class="cm"> ****************************************************************************/</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">x264_nal_encode</span><span class="p">(</span> <span class="kt">x264_t</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">x264_nal_t</span> <span class="o">*</span><span class="n">nal</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">p_payload</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">p_payload</span> <span class="o">+</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">i_payload</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">orig_dst</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">b_annexb</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">b_long_startcode</span> <span class="p">)</span>
</span><span class="line">            <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span><span class="line">        <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span><span class="line">        <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
</span><span class="line">        <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span> <span class="cm">/* save room for size later */</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* nal header */</span>
</span><span class="line">    <span class="o">*</span><span class="n">dst</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span> <span class="mh">0x00</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span> <span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">i_ref_idc</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="p">)</span> <span class="o">|</span> <span class="n">nal</span><span class="o">-&gt;</span><span class="n">i_type</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">dst</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">bsf</span><span class="p">.</span><span class="n">nal_escape</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span> <span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">dst</span> <span class="o">-</span> <span class="n">orig_dst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* Write the size header for mp4/etc */</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">b_annexb</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="cm">/* Size doesn&#39;t include the size of the header we&#39;re writing now. */</span>
</span><span class="line">        <span class="n">orig_dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">;</span>
</span><span class="line">        <span class="n">orig_dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">;</span>
</span><span class="line">        <span class="n">orig_dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">        <span class="n">orig_dst</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">nal</span><span class="o">-&gt;</span><span class="n">i_payload</span> <span class="o">=</span> <span class="n">size</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">    <span class="n">nal</span><span class="o">-&gt;</span><span class="n">p_payload</span> <span class="o">=</span> <span class="n">orig_dst</span><span class="p">;</span>
</span><span class="line">    <span class="n">x264_emms</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之参考帧]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/19/reference-frame/"/>
    <updated>2017-10-19T07:53:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/19/reference-frame</id>
    <content type="html"><![CDATA[
<p>本篇博客主要记录<code>X264</code>中关于参考帧管理。</p>

<!--more-->

<p><code>X264</code>中的帧可以大致分为以下几类：参考帧(ference frame)、当前编码帧(current frame)、未使用帧(unused frame)等。对帧的管理操作
的基本操作由两种：从队列中获取帧(<code>x264_frame_pop</code>)、向队列中添加帧(<code>x264_frame_push_unused</code>)。</p>

<p>关于帧队列的管理是通过数组来的，下面先介绍最基本的帧队列的一些基本操作。</p>

<p>首先将<code>frame</code>帧插入到<code>list</code>队列中，实现代码如下：</p>

<figure class="code"><figcaption><span>x264_frame_push </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_frame_push</span><span class="p">(</span><span class="kt">x264_frame_t</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="kt">x264_frame_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>从<code>list</code>队列中获取<code>frame</code>帧，实现代码如下：</p>

<figure class="code"><figcaption><span>x264_frame_pop </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">x264_frame_t</span> <span class="o">*</span><span class="nf">x264_frame_pop</span><span class="p">(</span> <span class="kt">x264_frame_t</span> <span class="o">**</span><span class="n">list</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">x264_frame_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span> <span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">frame</span> <span class="o">=</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">frame</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>当编码帧类型为<code>IDR</code>帧时，需要重置整个参考帧队列，<code>X264</code>中重置参考队列是通过<code>x264_reference_reset</code>函数完成，实现过程即为将<code>reference</code>队列
所有的参考帧设置为<code>unused</code>队列中的<code>unused</code>帧；实现代码如下：</p>

<figure class="code"><figcaption><span>x264_reference_reset </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x264_reference_reset</span><span class="p">(</span> <span class="kt">x264_t</span> <span class="o">*</span><span class="n">h</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">.</span><span class="n">reference</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">        <span class="n">x264_frame_push_unused</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">x264_frame_pop</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">.</span><span class="n">reference</span> <span class="p">)</span> <span class="p">);</span>
</span><span class="line">    <span class="n">h</span><span class="o">-&gt;</span><span class="n">fdec</span><span class="o">-&gt;</span><span class="n">i_poc</span> <span class="o">=</span>
</span><span class="line">    <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">i_poc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之判断帧类型]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/11/x264-slicetype-decide/"/>
    <updated>2017-10-11T08:59:17-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/11/x264-slicetype-decide</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统内存检测工具Valgrind入门]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/05/how-to-use-valgrind/"/>
    <updated>2017-10-05T19:07:13-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/05/how-to-use-valgrind</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#valgrind-" id="markdown-toc-valgrind-">Valgrind 工具简介</a></li>
  <li><a href="#valgrind--1" id="markdown-toc-valgrind--1">Valgrind 前期准备</a></li>
  <li><a href="#valgrind--2" id="markdown-toc-valgrind--2">Valgrind 执行程序</a></li>
  <li><a href="#valgrind--3" id="markdown-toc-valgrind--3">Valgrind 使用示例</a></li>
  <li><a href="#valgrind--4" id="markdown-toc-valgrind--4">Valgrind 内存错误类型</a></li>
  <li><a href="#valgrind--5" id="markdown-toc-valgrind--5">Valgrind 学习参考</a></li>
</ul>

<p><code>Valgrind</code>是一个很好地内存检测工具，本文记录如何开始<code>Valgrind</code>的使用。</p>

<!--more-->

<h2 id="valgrind-">Valgrind 工具简介</h2>

<p><code>Valgrind</code>工具提供了很多<code>Debugging</code>和<code>Profiling</code>工具，来帮助开发者开发出更好快更正确的程序。其中最常用的工具是<code>内存检测</code>。它可以
检测到<code>C/C++</code>中内存相关的错误，这些错误可能会导致系统崩溃<code>Crashes</code>或者其他莫名其妙的行为。</p>

<h2 id="valgrind--1">Valgrind 前期准备</h2>

<p>编译程序时，使用<code>-g</code>选项，用来包含<code>Debugging</code>信息，使得<code>Memcheck</code>工具在检测错误时，给出更具体的信息。如果可以容忍性能的降低，也可以添加<code>-O0</code>编译选择。</p>

<h2 id="valgrind--2">Valgrind 执行程序</h2>

<p>假设执行程序时，使用如下命令：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">myprog arg1 arg2</span></code></pre></td></tr></table></div></figure>

<p>使用<code>Valgrind</code>命令行如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">valgrind --lead-check=yes myprog arg1 arg2</span></code></pre></td></tr></table></div></figure>

<p><code>Memcheck</code>是默认的工具，所以<code>--leak-check</code>选项可以省略。使用<code>Valgrind</code>会使得程序变慢，并使用更多的内存，<code>Memcheck</code>
会检测到内存错误、内存泄漏。</p>

<h2 id="valgrind--3">Valgrind 使用示例</h2>

<p>下面是一段<code>C 示例</code>，该段代码内有内存错误和内存泄漏。</p>

<figure class="code"><figcaption><span>mem_file.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">    <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">//problem 1: heap block overrun</span>
</span><span class="line">                        <span class="c1">//problem 2: memory leak -- x not freed</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">f</span><span class="p">();</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译该程序</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -g -o mem_file mem_file.c</span></code></pre></td></tr></table></div></figure>

<p>使用<code>valgrind</code>运行该程序:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">valgrind --leak-check=full ./mem_file</span></code></pre></td></tr></table></div></figure>

<p>运行<code>valgring</code>后，输出的<code>Debug</code>信息如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bing@ubuntu:~/work$ valgrind --leak-check=full ./mem_file   
</span><span class="line">==10566== Memcheck, a memory error detector    
</span><span class="line">==10566== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.  
</span><span class="line">==10566== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info  
</span><span class="line">==10566== Command: ./mem_file  
</span><span class="line">==10566==   
</span><span class="line">==10566== Invalid write of size 4  
</span><span class="line">==10566==    at 0x400544: f (mem_file.c:6)  
</span><span class="line">==10566==    by 0x400555: main (mem_file.c:12)  
</span><span class="line">==10566==  Address 0x5204068 is 0 bytes after a block of size 40 alloc'd  
</span><span class="line">==10566==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)  
</span><span class="line">==10566==    by 0x400537: f (mem_file.c:5)  
</span><span class="line">==10566==    by 0x400555: main (mem_file.c:12)  
</span><span class="line">==10566==   
</span><span class="line">==10566==   
</span><span class="line">==10566== HEAP SUMMARY:  
</span><span class="line">==10566==     in use at exit: 40 bytes in 1 blocks  
</span><span class="line">==10566==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated  
</span><span class="line">==10566==   
</span><span class="line">==10566== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1  
</span><span class="line">==10566==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)  
</span><span class="line">==10566==    by 0x400537: f (mem_file.c:5)  
</span><span class="line">==10566==    by 0x400555: main (mem_file.c:12)  
</span><span class="line">==10566==   
</span><span class="line">==10566== LEAK SUMMARY:  
</span><span class="line">==10566==    definitely lost: 40 bytes in 1 blocks  
</span><span class="line">==10566==    indirectly lost: 0 bytes in 0 blocks  
</span><span class="line">==10566==      possibly lost: 0 bytes in 0 blocks  
</span><span class="line">==10566==    still reachable: 0 bytes in 0 blocks  
</span><span class="line">==10566==         suppressed: 0 bytes in 0 blocks  
</span><span class="line">==10566==   
</span><span class="line">==10566== For counts of detected and suppressed errors, rerun with: -v  
</span><span class="line">==10566== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)  
</span><span class="line">   </span></code></pre></td></tr></table></div></figure>

<p>大多数<code>valgrind</code>的输出格式就是这样的。</p>

<ul>
  <li><code>10566</code>是进城ID，命令行下，该值不是特别重要。</li>
  <li><code>Invalid write of size 4</code>这一行指示错误类型。</li>
  <li>错误类型后紧跟着的是调用栈，告诉开发者问题出在某个函数的某一行。</li>
  <li><code>0x400544</code>地址，通常不是很重要，但它也会指示问题地址，帮助开发者追踪问题。</li>
  <li>一些错误还会有更多的信息描述内存地址。上面的例子展示了写入内存超出了分配内存块，该内存块是在<code>example.c</code>中的第 5 行分配的。</li>
</ul>

<p>内存泄漏格式如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">
</span><span class="line">==10566==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)    
</span><span class="line">==10566==    by 0x400537: f (mem_file.c:5)    
</span><span class="line">==10566==    by 0x400555: main (mem_file.c:12) 
</span><span class="line">   </span></code></pre></td></tr></table></div></figure>

<p>该调用信息告知开发者泄漏的内存的分配位置。<code>Memcheck</code>不会告知开发者为什么出现内存泄漏。内存的泄漏可以分配两类：</p>

<ul>
  <li><code>definitely lost</code>:程序出现内存泄漏，必须修复。</li>
  <li><code>probably lost</code>:程序出现内存泄漏，只有在开发者使用指针做一些事情时才会发生。</li>
</ul>

<p><code>Memcheck</code>对未初始化变量，同样会有错误提示，通常提示信息为<code>Conditional jump or move depends on uninitialised value(s)</code>。这类错误的<code>roo cause</code>比较难发现，使用<code>--track-origins=yes</code>来获取更多信息。
该选项虽会使<code>Memcheck</code>运行更慢但额外信息会使开发者更容易的找到未初始化变量的位置。</p>

<h2 id="valgrind--4">Valgrind 内存错误类型</h2>

<ul>
  <li>Illegal read/Illegal write errors</li>
  <li>Use of Uninitialised values</li>
  <li>Use of uninitialised or unaddressable values in system calls</li>
  <li>Illegal frees</li>
  <li>When a heap block is freed with an inappropriate deallocation function</li>
  <li>Overlapping source and destination blocks</li>
  <li>Fishy argument values</li>
  <li>Memory leak detection</li>
</ul>

<h2 id="valgrind--5">Valgrind 学习参考</h2>

<p><a href="http://valgrind.org/docs/manual/valgrind_manual.pdf">Valgrind_mannual</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux常用命令之sed]]></title>
    <link href="http://lazybing.github.io/blog/2017/10/01/how-to-use-sed/"/>
    <updated>2017-10-01T08:35:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/10/01/how-to-use-sed</id>
    <content type="html"><![CDATA[
<p><code>sed</code>是<code>stream editor</code>的简称，它是一种在线编辑器，用于处理一行一行的数据。处理时，首先把待处理的文件内容送到临时缓冲区中，
称为”模式空间”，接着用<code>sed</code>命令处理缓冲区中的内容，处理完成后，把缓冲区中的内容送往屏幕，接着处理下一行，不断重复，直至文件末尾。</p>

<!--more-->

<p>假设有文本文件<code>text</code>，内容如下：</p>

<blockquote><p>10 tiny toes<br />this is that<br />5 funny 0<br />one two three<br />tree twice<br />new newer<br />NEW<br />newer new<br />NEW new old</p></blockquote>

<p>一. 基本用法：</p>

<ul>
  <li>将<code>text</code>文本中每行第一个小写字母<code>t</code>替换为大写字母<code>T</code>.</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$cat text | sed 's/t/T/'
</span><span class="line">$sed 's/t/T/' text</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>将<code>text</code>文本中每行所有的小写字母<code>t</code>替换为大写字母<code>T</code>.</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$sed 's/t/T/g' text
</span><span class="line">$sed 's/t/T/g' text &gt; new.txt
</span><span class="line">$sed -i 's/t/T/g' text</span></code></pre></td></tr></table></div></figure>

<p>二、与正则表达式结合</p>

<ul>
  <li>如果一行中第一个字符是<code>t</code>，就将它替换为<code>T</code>，其他字符不变。</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/^t/T/g' text</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>如果一行中最后一个字符是<code>t</code>，就将它替换为<code>T</code>，其他字符不变。</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/t$/T/g' text</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>将所有的数字/小写字母、大写字母、所有的字母替换为<code>*</code>。</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/[0-9]/*/g' text
</span><span class="line">sed 's/[a-z]/*/g' text
</span><span class="line">sed 's/[A-Z]/*/g' text
</span><span class="line">sed 's/[a-zA-Z]/*/g' text</span></code></pre></td></tr></table></div></figure>

<p>三、同时替换多个字符串</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/Twice/None/g' text | sed 's/Three/Two/g'
</span><span class="line">sed 's/Twice/None/g;s/Three/Two/g' text
</span><span class="line">sed 's/Twice/None/g;s/Three/Two/g;s/funny/tummy/g' text</span></code></pre></td></tr></table></div></figure>

<p>四、删除最后一个字符串</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed ‘s/\w*//’ text
</span><span class="line">sed ‘s/\w*.//’ text
</span><span class="line">sed ‘s/\w*$//’ text
</span><span class="line">sed ‘s/\w*$/bob/’ text</span></code></pre></td></tr></table></div></figure>

<p>五、只显示匹配行的结果</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/T/t/g' text
</span><span class="line">sed -n 's/T/t/g' text
</span><span class="line">sed -n 's/T/t/pg' text</span></code></pre></td></tr></table></div></figure>

<p>六、忽略大小写的替换</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/that/bob/g' text
</span><span class="line">sed 's/that/bob/Ig' text</span></code></pre></td></tr></table></div></figure>

<p>七、使用脚本文件,</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed -f mysedscript text</span></code></pre></td></tr></table></div></figure>

<p>其中的<code>mysedscript</code>内容是：</p>
<blockquote><p>s/T/t/g<br />s/e/E/g<br />s/\w*.//</p></blockquote>

<p>八、只替换完整的一个单词，使用边界符</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed 's/\bnew\b/old/g' text</span></code></pre></td></tr></table></div></figure>

<p>九、删除匹配行</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed '/new$/D' text
</span><span class="line">sed '/^new$/D' text
</span><span class="line">sed '/\bnew\b/D' text</span></code></pre></td></tr></table></div></figure>

<p>十、 替换文件夹内所有文件内容</p>

<p>如果想要替换某个文件夹下所有文件中的某个字符串，该如何操作呢，此时可以使用<code>sed</code>命令。例如，
替换<code>example_folder</code>文件夹下所有文件中的字符串<code>orig_str</code>，替换为<code>dst_str</code>，此时可以使用<code>sed</code>命令：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sed -i "s/orig_str/dst_str/g" `grep "orig_str" -rl /example_folder`</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
