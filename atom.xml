<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2021-11-14T01:15:27-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OverView of HEVC Standard]]></title>
    <link href="http://lazybing.github.io/blog/2021/10/16/overview-of-hevc-stand/"/>
    <updated>2021-10-16T06:48:21-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/10/16/overview-of-hevc-stand</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#hevc-" id="markdown-toc-hevc-">HEVC 编码设计和功能亮点</a>    <ul>
      <li><a href="#a-" id="markdown-toc-a-">A. 视频编码层</a>        <ul>
          <li><a href="#coding-tree-units-and-coding-tree-blockctb-structure" id="markdown-toc-coding-tree-units-and-coding-tree-blockctb-structure">1) Coding tree units and coding tree block(CTB) structure</a></li>
          <li><a href="#coding-unitscus-and-coding-blockscbs" id="markdown-toc-coding-unitscus-and-coding-blockscbs">2）Coding units(CUs) and coding blocks(CBs)</a></li>
          <li><a href="#prediction-units-and-prediction-blockspbs" id="markdown-toc-prediction-units-and-prediction-blockspbs">3）Prediction units and prediction blocks(PBs)</a></li>
          <li><a href="#tus-and-transform-blocks" id="markdown-toc-tus-and-transform-blocks">4）TUs and transform blocks</a></li>
          <li><a href="#motion-vector-signaling" id="markdown-toc-motion-vector-signaling">5）Motion vector signaling</a></li>
          <li><a href="#motion-compensation" id="markdown-toc-motion-compensation">6）Motion compensation</a></li>
          <li><a href="#intrapicture-prediction" id="markdown-toc-intrapicture-prediction">7) Intrapicture prediction</a></li>
          <li><a href="#quantization-control" id="markdown-toc-quantization-control">8) Quantization control</a></li>
          <li><a href="#entropy-coding" id="markdown-toc-entropy-coding">9）Entropy coding</a></li>
          <li><a href="#in-loop-deblocking-filtering" id="markdown-toc-in-loop-deblocking-filtering">10）In-loop deblocking filtering</a></li>
          <li><a href="#sample-adaptive-offsetsao" id="markdown-toc-sample-adaptive-offsetsao">11）Sample adaptive offset(SAO)</a></li>
        </ul>
      </li>
      <li><a href="#b-" id="markdown-toc-b-">B. 高级语法体系结构</a>        <ul>
          <li><a href="#parameter-set-structure" id="markdown-toc-parameter-set-structure">1）Parameter set structure</a></li>
          <li><a href="#nal-unit-syntax-structure" id="markdown-toc-nal-unit-syntax-structure">2）NAL unit syntax structure</a></li>
          <li><a href="#slices" id="markdown-toc-slices">3）Slices</a></li>
          <li><a href="#sei--vui" id="markdown-toc-sei--vui">4）SEI 和 VUI</a></li>
        </ul>
      </li>
      <li><a href="#c--slice-" id="markdown-toc-c--slice-">C. 并行解码语法与改进的 slice 结构</a>        <ul>
          <li><a href="#tiles" id="markdown-toc-tiles">1） Tiles</a></li>
          <li><a href="#wavefront-parallel-processingwpp" id="markdown-toc-wavefront-parallel-processingwpp">2）Wavefront parallel processing(WPP)</a></li>
          <li><a href="#dependent-slice-segments" id="markdown-toc-dependent-slice-segments">3）Dependent slice segments</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">高级语法</a>    <ul>
      <li><a href="#a-random-access-and-bitstream-splicing-features" id="markdown-toc-a-random-access-and-bitstream-splicing-features">A) Random Access and Bitstream Splicing Features</a></li>
      <li><a href="#b-temporal-sublayering-support" id="markdown-toc-b-temporal-sublayering-support">B) Temporal Sublayering Support</a></li>
      <li><a href="#c-additional-parameter-sets" id="markdown-toc-c-additional-parameter-sets">C) Additional Parameter Sets</a></li>
      <li><a href="#d-reference-picture-sets-and-reference-picture-lists" id="markdown-toc-d-reference-picture-sets-and-reference-picture-lists">D) Reference Picture Sets and Reference Picture Lists</a></li>
    </ul>
  </li>
  <li><a href="#hevc--1" id="markdown-toc-hevc--1">HEVC 视频编码技术</a>    <ul>
      <li><a href="#a-sampled-representation-of-pictures" id="markdown-toc-a-sampled-representation-of-pictures">A) Sampled Representation of Pictures</a></li>
      <li><a href="#b-division-of-the-picture-into-coding-tree-unit" id="markdown-toc-b-division-of-the-picture-into-coding-tree-unit">B) Division of the Picture into Coding Tree Unit</a></li>
      <li><a href="#c-division-of-the-ctb-into-cbs" id="markdown-toc-c-division-of-the-ctb-into-cbs">C) Division of the CTB into CBs</a></li>
      <li><a href="#d-pbs-and-pus" id="markdown-toc-d-pbs-and-pus">D) PBs and PUs</a></li>
      <li><a href="#e-tree-structured-partitioning-into-transform-blocks-and-units" id="markdown-toc-e-tree-structured-partitioning-into-transform-blocks-and-units">E) Tree-Structured Partitioning Into Transform Blocks and Units</a></li>
      <li><a href="#f-slices-and-tiles" id="markdown-toc-f-slices-and-tiles">F) Slices and Tiles</a></li>
      <li><a href="#g-intrapicture-prediction" id="markdown-toc-g-intrapicture-prediction">G) Intrapicture Prediction</a></li>
      <li><a href="#h-interpicture-prediction" id="markdown-toc-h-interpicture-prediction">H) Interpicture Prediction</a></li>
      <li><a href="#i-transform-scaling-and-quantization" id="markdown-toc-i-transform-scaling-and-quantization">I) Transform, Scaling, and Quantization</a></li>
      <li><a href="#j-entropy-coding" id="markdown-toc-j-entropy-coding">J) Entropy Coding</a></li>
      <li><a href="#k-in-loop-filters" id="markdown-toc-k-in-loop-filters">K) In-Loop Filters</a></li>
      <li><a href="#l-special-coding-modes" id="markdown-toc-l-special-coding-modes">L) Special Coding Modes</a></li>
    </ul>
  </li>
  <li><a href="#profiles-tiers-and-levels" id="markdown-toc-profiles-tiers-and-levels">Profiles, Tiers And Levels</a>    <ul>
      <li><a href="#a-profile-level-and-tier-concepts" id="markdown-toc-a-profile-level-and-tier-concepts">A) Profile, Level, and Tier Concepts</a></li>
      <li><a href="#b-the-hevc-profile-and-level-definitions" id="markdown-toc-b-the-hevc-profile-and-level-definitions">B) The HEVC Profile and Level Definitions</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">历史与标准化进程</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">结论</a></li>
</ul>

<p>HEVC 是 ITU-T 视频编码专家组和 ISO/IEC 运动图像专家组的最新视频编码标准。HEVC 标准化工作的主要目标是相对于现有标准，在 50% 的比特率降低范围内显著提高压缩性能，以获得相同的感知视频质量。本文概述了 HEVC 标准的技术特性和特点。</p>

<!--more-->

<h2 id="section">介绍</h2>

<p>HEVC 标准是 ITU-T 视频编码专家组(VCEG)和 ISO/IEC 运动图像专家组(MPEG)标准化组织的最新联合视频项目，它们在一个称为视频编码联合协助小组(JCT-VC)的伙伴组织关系中共同工作。HEVC 标准的第一版预计将于 2013 年 1 月定稿，最终形成一份由 ITU-T 和 ISO/IEC 共同发布的统一文本。后续会有更多工作，以扩展该标准，从而支持多个其他应用场景，包括具有增强精度和颜色格式支持的扩展范围使用、可伸缩视频编码和三维/立体/多视图视频编码。在 ISO/IEC 中，HEVC标准将成为 MPEG-H 第 2 部分(ISO/IEC 23008-2)，在 ITU-T 中，它很可能成为 ITU-T 建议 H.265。</p>

<p>视频编码标准主要通过注明的 ITU-T 和 ISO/IEC 标准的发展而起来的。ITU-T 生产了 H.261 和 H.263，ISO/IEC 生产了 MPEG-1 和 MPEG-4视频，这两个组织联合生产了 H.262/MPEG-2视频和 H.264/MPEG-4 AVC 标准。这两项联合制定的标准产生了特别强烈的影响，并已被广泛应用于我们日常生活中日益流行的各种产品中。在这一演变过程中，不断努力最大限度地提高压缩能力，并改进其他特性，如数据丢失鲁棒性，同时考虑到在预期部署每个标准时，产品中实际使用的计算资源。</p>

<p>HEVC 之前的主要视频编码标准是 H.264/MPEG-4 AVC，它最初是在 1999 年至 2003 年期间开发的，然后在 2003 年至 2009 年期间以几种重要方式进行了扩展。H.264/MPEG-4 AVC 是数字视频的一种使能技术，几乎涵盖了 H.262/MPEG-2 视频之前未涵盖的所有领域，并在其现有应用领域中基本上取代了旧标准。它广泛应用于许多应用，包括通过卫星、有线和地面传输系统广播高清(HD)电视信号、视频内容采集和编辑系统、摄像机、安全应用、互联网和移动网络视频、蓝光光盘以及视频聊天等实时对话应用，视频会议和远程呈现系统。</p>

<p>然而，服务的日益多样化、高清视频的日益普及以及超高清格式(如4kx2k 或 8kx4k分辨率)的出现，对编码效率的需求甚至超出了 H.264/MPEG-4 AVC 的能力。当更高的分辨率伴随立体声或多视图捕获和显示时，这种需求更强烈了。此外，针对移动设备和平板电脑的视频应用程序所带来的流量，以及视频点播服务的传输需求，正在给当今的网络带来严峻挑战。在移动应用程序中，对更高质量和分辨率的需求也越来越强烈。</p>

<p>HEVC 旨在解决 H.264/AVC 的所有现有应用，并特别关注两个特别问题：提高视频分辨率，增加并行处理框架的使用。HEVC 的语法是通用的，通常也适用于上面没有特别提到的其他应用程序。</p>

<p>与过去所有的 ITU-T 和 ISO/IEC 视频编码标准一样，在 HEVC 中，只有比特流结构和语法是标准化的，并且对生产解码图片的比特流及其映射的约束也是标准化的。通过定义语法元素的语义和解码过程来给出映射，使得当给定符合标准约束的比特流时，符合标准的每个解码器将产生相同的输出。标准范围的这种限制允许以适合特定应用的方式(平衡压缩质量、实现成本、上市时间和其他考虑因素)最大限度地优化实现。然而，它并不能保证端到端的复制质量，因为它甚至允许有损失的编码技术被认为是合格的。</p>

<p>为了帮助行业社区学习如何使用标准，标准化工作不仅包括开发文本规范文档，还包括参考软件源代码，作为如何编码和解码 HEVC 视频的示例。在标准设计期间，参考软件草案已被用作委员会内部工作的研究工具，也可作为通用研究工具和产品基础，还正在开发标准测试数据套件，以测试是否符合该标准。</p>

<p>本文的组织结构如下：第二部分重点介绍 HEVC 编码设计的一些关键特性。第三部分解释了 HEVC 编码数据的高级语法和总体结构。第四部分将更详细地描述 HEVC 编码技术。第五部分解释了 HEVC 的 profile、tier 和 level 设计。由于编写像  HEVC 这样实质性的技术概述需要大量的总结，如有遗漏，请向读者咨询。第六部分讨论了 HEVC 标准化工作的历史。</p>

<h2 id="hevc-">HEVC 编码设计和功能亮点</h2>

<p>HEVC 标准旨在实现多个目标，包括编码效率、易于传输系统集成和数据丢失恢复能力，以及使用并行处理架构的可实现性。下面小节简要描述了实现这些目标的设计关键要素，以及生成有效比特流的典型编码器操作。第三节和第四节提供了有关不同元素的相关语法和解码过程的更多细节。</p>

<h3 id="a-">A. 视频编码层</h3>

<p>HEVC 的视频编码层采用自 H.261 以来所有视频压缩标准中使用的相同的混合编码方法(图像间/图像内预测和二维变换编码)。图 1 描述了可创建符合 HEVC 标准的比特流的混合视频编码器的框图。</p>

<p>产生符合 HEVC 的比特流的编码算法通常如下进行：每个图片被分割成块形区域，精确的块分割被传送到解码器。视频序列的第一幅图片(以及每个随机接入点处的第一幅图片到视频序列中)仅使用图片内预测进行编码(该预测使用同一图片内从区域到区域的空间数据预测，但不依赖于其他图片)。对于序列或随机接入点间的所有剩余图片，通常对大多数块使用图像间时间预测编码模式。用于画面间预测的编码处理包括：选择包含所选参考画面和运动矢量(MV)的运动数据，以应用于预测每个块的样本。编码器和解码器通过使用 MV 和模式决策数据应用运动补偿(MC)来生成相同的图像间预测信号，这些数据作为边信息传输。</p>

<p>帧内或帧间预测的残余信号(即原始块与其预测之间的差值)，通过线性空间变换进行变换。然后对变换系数进行缩放、量化、熵编码，并与预测信心一起传输。</p>

<p>编码器复制解码器处理循环(参见图1中的灰色阴影框)，以便两者将为后续数据生成相同的预测。因此，量化变换系数通过逆缩放构造，然后逆变换以复制剩余信号的解码近似。然后将残差添加到预测中，并且该添加的结果随后可被反馈到一个或两个环路滤波器中以平滑由分块处理和量化引起的伪影。最终图片表示(即解码器输出的副本)存储在解码图片缓冲器中，以用于后续图片的预测。一般来说，图片的编码或解码处理顺序通常不同于它们从源到达的顺序，需要区分解码器的解码顺序(即比特流顺序)和输出顺序(即显示顺序)。</p>

<p>要由 HEVC 编码的视频材料通常应作为逐行扫描图像输入(由于源视频以该格式产生，或由编码前去交错)。HEVC 设计中不存在明确的编码特征，以支持隔行扫描的使用，因为隔行扫描不再用于显示，并且在分发中变得越来越步常见。然而，在 HEVC 中提供了元数据语法，以允许编码器通过将隔行扫描视频的每个字段(即，每个视频帧的偶数或奇数行)编码以单独图片来指示隔行扫描视频已被发送，或这其已通过将每个隔行扫描帧编码为 HEVC 编码图片来发送。这提供了一种对隔行视频进行编码的有效方法，而无需使解码器负担对其支持特殊解码过程的负担。</p>

<p>在下文中，使用 HEVC 的混合视频编码所涉及的各种特性如下所示。</p>

<h4 id="coding-tree-units-and-coding-tree-blockctb-structure">1) Coding tree units and coding tree block(CTB) structure</h4>

<p>在以前的标准中，编码层的核心是宏块，它包含 luma 采样的 16x16 宏块，在通常的 4:2:0 颜色采样情况下，chroma 采样有对应的 8x8 色度块；而 HEVC 中的类似结构是编码树单元(CTU)，其大小由编码器选择，可以大于传统宏块。CTU 由 luma CTB 和对应的色度 CTB 以及语法元素组成。luma CTB 的大小可以选择为 L=16、32或64个样本，较大的大小通常能够实现更好的压缩。HEVC 支持使用树结构和类似四叉树的信令将 CTB 划分为更小的块。</p>

<h4 id="coding-unitscus-and-coding-blockscbs">2）Coding units(CUs) and coding blocks(CBs)</h4>

<p>CTU 的四叉树语法指定其亮度和色度 CBs 的大小和位置。四叉树的根与 CTU 关联。因此，luma CTB 的大小是 luma CB 支持的最大大小。CTU 分为 luma 和 chroma CBs 是联合发出的信号。一个 luma CB 和两个 sample CB，连同相关的语法，构成一个编码单元(CU)。一个 CTB 可以只包含一个 CU，或者可以分割成多个 CU，并且每个 CU 都有一个相关的分区为预测单元(PU)和变换单元树(TU)。</p>

<h4 id="prediction-units-and-prediction-blockspbs">3）Prediction units and prediction blocks(PBs)</h4>

<p>在 CU 级别决定是使用图像间预测还是图像内预测对图片区域进行编码。PU 分区结构的根位于 CU 级别。取决于基本预测类型决策，luma 和 chroma CBs 随后可以在大小上进一步分割并从 luma 和 chroma 预测块(PBs)预测。HEVC 支持从 64x64 到 4x4 样本的可变 PB 大小。</p>

<h4 id="tus-and-transform-blocks">4）TUs and transform blocks</h4>

<p>使用块变换对预测残差进行编码。TU 树结构的根位于 CU 级别。luma CB 残差可以与 luma 变换块(TB)相同，或者可以进一步分割成更小的 luma TB。这同样适用于 chroma TBs。对于 4x4、8x8、16x16 和 32x32 的正方形 TB，定义了与DCT 类似的整数基函数。对于 luma 图像内预测残差的 4x4 变换，可选指定从 DST 形式导出的整数变换。</p>

<h4 id="motion-vector-signaling">5）Motion vector signaling</h4>

<p>使用AMVP(Advanced motion vector prediction)，包括基于来自相邻 PBs 和参考图片的数据导出几个最可能的候选。还使用 MV 编码的合并模式，允许 MV 从时间上或空间上相邻的 PBs 继承。此外，与 H.264/AVC 相比，还指定了改进的 skipped 和 直接运动推断。</p>

<h4 id="motion-compensation">6）Motion compensation</h4>

<p>MVs 使用四分之一采样精度，分数采样位置的插值使用 7 抽头或 8 抽头滤波器(相比之下，H.264/AVC 中，半采样位置的六抽头滤波后，四分之一采样位置的线性插值)。与 H.264/AVC 类似，使用了多个参考图片。对于每个 PB，传输一个或两个运动矢量，分别表示单预测或双预测编码。如在 H.264/AVC 中一样，可以称为加权预测的方式对预测信号应用缩放和偏移操作。</p>

<h4 id="intrapicture-prediction">7) Intrapicture prediction</h4>

<p>相邻块的间边界样本，用作未执行帧间预测的区域中的空间预测的参考数据。图像内预测支持 33 种方向模式(与 H.264/AVC 中的 8 种模式相比)，以及plus plannr 和 DC 预测模式。通过基于先前解码的相邻 PBs 的模式导出最可能模式(例如，预测方向)来编码所选择的画面内预测模式。</p>

<h4 id="quantization-control">8) Quantization control</h4>

<p>与 H.264/AVC 中一样，HEVC 中使用均匀重建量化(URQ)，量化缩放矩阵支持各种变换块大小。</p>

<h4 id="entropy-coding">9）Entropy coding</h4>

<p>CABAC 用于熵编码。这类似于 H.264/AVC 中的 CABAC 方案，单经过几次改进以提高其吞吐量速度(特别是对于并行处理架构)和压缩性能，并降低其上下文内存需求。</p>

<h4 id="in-loop-deblocking-filtering">10）In-loop deblocking filtering</h4>

<p>与 H.264/AVC 中使用的去块滤波器类似去块滤波器，在图像间预测循环中操作。然而，该设计在决策和过滤过程方面得到了简化，并且对并行处理更加友好。</p>

<h4 id="sample-adaptive-offsetsao">11）Sample adaptive offset(SAO)</h4>

<p>在去块滤波器之后，在图像间预测环路中引入非线性振幅映射。它的目标是通过使用查找表更好地重建原始信号振幅，该查找表由几个附加参数描述，这些参数可以通过编码器端的直方图分析确定。</p>

<h3 id="b-">B. 高级语法体系结构</h3>

<p>HEVC 标准新增的许多设计方面，提高了在各种应用程序和网络环境下操作的灵活性，并提高了数据丢失的鲁棒性。然而，H.264/AVC 标准中使用的高级语法体系结构通常被保留，包括以下特征。</p>

<h4 id="parameter-set-structure">1）Parameter set structure</h4>

<p>参数集包含可共享的信息，用于解码解码视频的多个区域。参数集结构提供了用于传输解码过程所必需的数据的健壮机制。通过一种新的 VPS 结构，对 H.264/AVC 中的序列和图片参数集的概念进行了扩充。</p>

<h4 id="nal-unit-syntax-structure">2）NAL unit syntax structure</h4>

<p>每个语法结构都被放入 NAL 单元的逻辑数据包中。使用两个字节 NAL 单元报头的内容，可以容易地识别相关有效负载数据的用途。</p>

<h4 id="slices">3）Slices</h4>

<p>slice 是一种数据结构，在熵编码、信号预测和残差信号重建方面，可以独立于同一图片的其他 slice 进行解码。slice 可以是整个图片，也可以是图片中的一个区域。slice 的主要用途之一是在数据丢失时重新同步。在分组传输的情况下， slice 内有效负载比特的最大数量通常受到限制，并且 slice 中 CTU 的数量经常变化以最小化分组开销，同时将每个分组的大小保持在此范围内。</p>

<h4 id="sei--vui">4）SEI 和 VUI</h4>

<p>该语法元素支持各种类型元数据，比如 SEI 和 VUI。这些数据提供关于视频图片的定时、视频信号中使用的颜色空间的正确解释、三维立体帧打包信息、其他显示提示信息等的信息。</p>

<h3 id="c--slice-">C. 并行解码语法与改进的 slice 结构</h3>

<p>最后，HEVC 标准中引入了四个新的特性，以增强并行处理能力或修改 slice 数据的结构以实现打包。它们中的每一个在特定的应用环境中都可能有好处，并且通常由编码器或解码器的实现者来确定是否以及如何利用这些特性。</p>

<h4 id="tiles">1） Tiles</h4>

<p>Tiles 作为标准的可选项，它将图片分割为矩形区域。Tiles 的主要目的是增加并行处理能力，而不是提供错误恢复能力。Tiles 是图片的独立可解码区域，它使用一些共享头信息进行编码。Tiles 还可用于视频图片局部区域的空间随机访问。图片的典型 tile 配置将图片分割为矩形区域，每个 tiles 中的 CTU 数量大致相等。Tiles 提供了并行性的更粗粒度级别，并且线程的使用不需要复杂的同步。</p>

<h4 id="wavefront-parallel-processingwpp">2）Wavefront parallel processing(WPP)</h4>

<p>当启动波前并行处理(WPP)时，一个 slice 被划分为若干行 CTU。第一行以普通方式处理，第二行可以在第一行仅处理两个 CTU 后开始处理，第三行可以在第二行仅处理两个 CTU 后开始处理，以此类推。每一行中熵编码器的上下文模型是根据前一行中具有两个 CTU 处理延迟的上下文模型推到出来的。WPP 在相当精细的粒度级别上提供了一种处理并行性的形式，即在一个 slice 内。WPP 通常可以提供比 Tiles 更好的压缩性能(并避免使用 Tiles 可能导致的一些视觉瑕疵)。</p>

<h4 id="dependent-slice-segments">3）Dependent slice segments</h4>

<p>一种称为 Dependent Slice Segment 的结构，允许在单独的 NAL 单元中携带与特定波前入口点或 Tiles 相关的数据，因此，与将数据全部编码在一个 slice 中相比，该结构有可能使该数据以更低的延迟提供给分片打包系统。波前入口点的 Dependent Slice Segments 只能在另一 slice 的解码过程的至少一部分已经执行之后进行解码。相关 slice 主要用于低延迟编码，其他并行工具可能会影响压缩性能。</p>

<p>接下来的两个部分中，将对主要功能进行更详细的描述。</p>

<h2 id="section-1">高级语法</h2>

<p>HEVC 的高级语法包含许多继承自 H.264/AVC NAL 的元素。NAL 提供将表示图片内容的视频编码层(VCL)数据映射到各种传输层(包括RTP/IP，ISO MP4 和 H.222.0/MPEG-2系统)的能力，并提供分组丢失恢复的框架。有关 NAL 设计的一般概念，如 NAL 单元、参数集、访问单元、字节流格式和分组格式，请参考[9]-[11]。</p>

<p>根据是否包含编码图片或其他相关数据，NAL 单元分为 VCL 和 非 VCL NAL 单元。HEVC 标准中，包括几种用于识别用于解码器初始化和随机访问目的的图片类型的 VCL NAL 单元类型。表 I 列出了 HEVC 标准中的 NAL 单元类型及其相关含义和类型类别。</p>

<p>以下小节介绍了高级语法支持的新功能。</p>

<h3 id="a-random-access-and-bitstream-splicing-features">A) Random Access and Bitstream Splicing Features</h3>

<p>HEVC 新设计支持特殊功能以实现随机访问和比特流拼接。在 H.264/AVC 中，比特流必须始终以 IDR 访问单元开始。IDR 访问单元包含独立编码的图片，即，可以在不解码 NAL 单元流中的任何先前图片的情况下解码的编码图片。IDR 访问单元的存在指示，比特流中的后续图片将不需要参考其包含的图片之前的图片以便被解码。IDR 图片在称为闭合 GOP(其中 GOP 代表图片组)的编码结构内使用。</p>

<p>新的 CRA(Clean Random Access) 图片语法指定在 RAP(Random Access Point)的位置处使用独立编码的图片。即，在比特流中解码器可以开始成功解码图片的位置处，而无需解码比特流中先前出现的任何图片，它支持一种称为开放 GOP 操作的高效时间编码顺序。对 RAP 的良好支持，对于启用通道切换、搜索操作和动态流媒体服务至关重要。按照解码顺序在 CRA 图像之后，按显示顺序在 CRA 图像之前的图片，可能包含对解码器处不可用的图片的帧间预测参考。因此，在 CRA 点开始解码过程的解码器，必须丢弃这些不可解码的图像。为此，此类不可解码图片被标识为 RASL（Random Access Skipped Leading）图片。来自不同编码比特流的拼接点位置可通过 BLA(Broken Link Access)图片指导。比特流拼接操作可以通过简单地将一个比特流中 CRA 图片的 NAL 单元类型更改为指示 BLA 图片的值，并将新比特流连接到另一个比特流中 RAP 图片的位置来执行。RAP 图像可能是 IDR、CRA 或 BLA 图像，并且 CRA 和 BLA 图像之后可以是比特流中的 RASL 图片(取决于用于 BLA 图片的 NAL 单元类型的特定值)。解码器必须始终丢弃与 BLA 图片相关联的任何 RASL 图片，因为它们可能包含对由于拼接操作而实际不存在于比特流中的图片的参考。另一种可以以解码顺序跟随 RAP 图片之后，并在以输出顺序在 RAP 之前的图片类型，是RADL(Random Access Decodable Leading)图片，其不能包含对以解码顺序在 RAP 图片之前的任何图片的参考。RASL 和 RADL 图片统称为 Leading Pictures.以解码顺序和输出顺序跟随在 RAP 图片之后的图像(称为 Trailing Picture)不能包含对用于图片间预测的 Leading Picture 的参考。</p>

<h3 id="b-temporal-sublayering-support">B) Temporal Sublayering Support</h3>

<p>与 H.264/AVC 可伸缩视频编码(SVC)扩展中的时间可伸缩性特征类似，HEVC 在 NAL 单元报头中指定了时间标识符，其指示分层时间预测结构中的级别。这是为了实现时间可伸缩性，而无需解析除 NAL 单元以外的比特流部分。</p>

<p>在某些情况下，在一个编码视频序列的解码过程中，解码时间子层的数量是可以调整的。比特流中的点(此点位置是发生子层切换，可以开始解码一些更高级时间层的点)可以通过TSA(Temporal Sublayer Access)图片和STSA(StepWise TSA)图片的存在来指示。在 TSA 图像的位置，可以从解码较低的时间子层切换到解码任何较高时间子层；在 STSA 图像位置，可以从解码较低时间子层切换到仅解码一个特定较高时间子层(但不包括上面的其他层，除非它们还包含 STSA 或 TSA 图像)；</p>

<h3 id="c-additional-parameter-sets">C) Additional Parameter Sets</h3>

<p>VPS 已添加为元数据，已描述编码视频序列的总体特征，包括时间子层之间的依赖关系。其主要目的是实现标准在系统层的信令方面的兼容扩展性，例如，当未来扩展的可伸缩或多视图比特流的基本层需要由传统解码器解码时。但是，对于这种情况，只与高级解码器相关的关于比特流结构的附加信息将被忽略。</p>

<h3 id="d-reference-picture-sets-and-reference-picture-lists">D) Reference Picture Sets and Reference Picture Lists</h3>

<p>对于多参考图片管理，解码图片缓冲区(DPB)中需要存在一组特定的先前解码图片，用于解码比特流中的其余图片。为了标识这些图片，在每个片头中传输图片顺序计算(POC)标识符的列表。保留的参考图片集称为 RPS。图2示出了用于示例性时间预测结构的 POC 值、解码顺序和 RPS。</p>

<p>与 H.264/AVC 中一样，有两个列表被构造为 DPB 中的图片列表，它们被称为参考图片列表 0 和 列表 1。称为参考图片索引的索引用于识别这些列表之一中的特定图片。对于单预测，可以从这些列表中选择图片。对于双向预测，将从每个列表中选择两张图片。当列表仅包含一个图片时，参考图片索引隐士地具有值 0，并且不需要在比特流中传输。</p>

<p>与先前的 H.264/AVC 设计相比，用于识别 RPS 和建立用于画面间预测的参考图片列表的高级语法对数据丢失更为鲁棒，并且更适于诸如随机访问和技巧模式操作之类的操作(例如，快进、平滑倒带、搜索和自适应比特流切换)。这些改进的一个关键方面是语法更加明确，而不是依赖于解码过程中存储的内部状态的推断，因为它逐帧解码比特流。此外，设计的这些方面的相关语法实际上比 H.264/AVC 更简单。</p>

<h2 id="hevc--1">HEVC 视频编码技术</h2>

<p>与 H.261 以来所有先前的 ITU-T 和 ISO/IEC JTC 1 视频编码标准一样，HEVC 设计遵循经典的基于块的混合视频编码方法(如图1所示)。基于信源编码算法是利用时间统计相关性的帧间预测、利用空间统计相关性的帧内预测和利用空间统计相关性的预测残差信号的变换编码的混合。与先前的视频编码标准相比，HEVC 设计中没有一个编码元素能够显著提高压缩效率。更确切地说，是多个较小的改进增加了显著的收益。</p>

<h3 id="a-sampled-representation-of-pictures">A) Sampled Representation of Pictures</h3>

<p>为了表示彩色视频信号，HEVC 通常使用具有4:2:0 采样的 YCbCr 颜色空间(尽管扩展到其他采样格式很简单，计划在后续版本中定义)。这将颜色表示为三个组件，分别称为Y、Cb 和 Cr。Y 组件也称为亮度，表示亮度。两个色度分量Cb 和 Cr 分别表示颜色从灰色向蓝色和红色的偏离程度。由于人类视觉系统对亮度比色度更敏感，因此通常使用4：2：0采样结构，其中每个色度分量具有亮度分量样本数的四分之一(水平和垂直维度样本数的一半)。每二个组件的每个样本通常以 8 或 10 bit的精度表示，8 bit的情况更为典型。在本文的其余部分中，我们将重点放在典型用途上:YCbCr 组件具有4：2：0采样和 8bit 每个采样，用于表示编码输入和解码输出视频信号。</p>

<p>视频图像通常以矩形图片大小WxH逐步采样，其中 W 是宽度，H 是 luma 样本中图片的高度。采用4：2：0采样的每个色度分量阵列为W/2xH/2。给定这样的视频信号，HEVC 语法进一步划分图片，如下所述。</p>

<h3 id="b-division-of-the-picture-into-coding-tree-unit">B) Division of the Picture into Coding Tree Unit</h3>

<p>图片被划分成编码树单元(CTU)，每个单元包含亮度 CTB 和色度 CTB。亮度 CTB 覆盖亮度分量的 LxL 样本的矩形图像区域，相应的色度 CTB 覆盖两个色度分量中每个分量的 L/2xL/2 样本。L 的值可以是 16、32、64，由 SPS 中指定的编码语法元素确定。与传统宏块相比，HEVC 支持根据编码器在内存和计算需求方面的需求，选择可变大小的 CTB。而从 H.261 以来所有先前的 ITU-T 和 ISO/IEC JTC 视频编码标准中，宏块使用固定阵列大小的 16x16 luma 样本。在编码高分辨率视频内容时，支持以前的标准更大的 CTB 尤其有益。luma  CTB 和两个色度 CTB 以及相关的语法构成了CTU。CTU 是标准中用于指定解码过程的基本处理单元。</p>

<h3 id="c-division-of-the-ctb-into-cbs">C) Division of the CTB into CBs</h3>

<p>指定为 luma 和 chroma CTB 的块可以直接用作 CB，或者可以进一步划分为多个 CB，划分是使用树形结构实现的。HEVC 中的树划分通常同时应用于亮度和色度，但当色度达到某些最小值时例外。</p>

<p>CTU 包含四叉树语法，该语法允许根据 CTB 覆盖区域的信号特征，将 CBs 划分为选定的合适大小。四叉树划分过程可以迭代，直到 luma CB 的大小达到所允许的最小luma CB 大小。该最小 luma CB 大小是编码器使用 SPS 中的语法元素指定选择的，它始终为 8x8 或更大(以 luma 样本为单位)。</p>

<p>图片的边界以允许的最小 luma CB 大小为单位定义。因此，在图片的右边缘和下边缘，一些 CTU 可能会覆盖部分位于图片边界之外的区域。解码器检测到这种情况，并根据需要隐士分割 CTU 四叉树，以将 CB 大小减小到整个 CB 将适合图片的位置。</p>

<h3 id="d-pbs-and-pus">D) PBs and PUs</h3>

<p>根据 CU 使用的是画面内预测还是画面间预测，CU 的预测模式用信号表示为帧内预测或帧间预测。</p>

<p>当预测模式是帧内模式时，PU 大小（即建立图像内预测模式时的块大小）与所有块大小的 CB 大小相同。但比特流中允许的最小 CB 大小除外。对于后一种情况，存在一个标志，指示 CB 是否被分成四个 PB 象限，每个象限都有自己的帧内预测模式。允许这种分割的原因是为大小 4x4 的块启用不同的帧内预测模式选择。当亮度帧内预测使用 4x4 块进行操作时，色度帧内预测也使用 4x4 块(每个块覆盖与四个 4x4 亮度块相同的图片区域)。帧内预测操作时的实际区域大小(与建立帧内预测模式时的 PB 大小不同)取决于如下所述的剩余编码分区。</p>

<p>当预测模式是帧间时，指定亮度和色度 CBs 是否被分割成一个、两个或四个 PBs。仅当 CB 尺寸等于允许的最小 CB 尺寸时，才允许将 CB 分为四个 PBs，使用等效类型的拆分，否则可在设计的 CB 级而不是 PB 级执行拆分。当 CB 被划分为四个 PBs 时，每个 PB 覆盖 CB 的一个角；当 CB 被划分为两个 PBs 时，可能会出现六种不同的划分。图 3 描述了帧间预测的 CBs 的划分可能性。图中的上半部分说明了划分大小为 MxM 的 CB，将 CB 划分为大小为 MxM/2 或 M/2xM 的两个 PBs，将其划分为大小为 M/2xM/2 的四个 PBs 的情况。图 3 中下半部分的四种划分类型被称为非对称运动分区(AMP)，并且仅在 luma 的 M 为 16 或更大时才允许。不对称划分的一个 PB 的高度或宽度分别为 M/4 和 M，另一个 PB 的高度或宽度分别为 3M/4 和 M，填充 CB 的其余部分。每个帧间预测 PB 被分配一个或两个运动矢量和参考图片索引。为了最小化最坏情况下的内存带宽，不允许使用 luma 大小为 4x4 的 PBs 进行帧间预测，并且 luma 大小为 4x8 和 8x4 的 PBs 仅限于单预测编码。下面进一步描述帧间预测处理。</p>

<p>luma 和 chroma PBs，以及相关的预测语法构成 PU。</p>

<h3 id="e-tree-structured-partitioning-into-transform-blocks-and-units">E) Tree-Structured Partitioning Into Transform Blocks and Units</h3>

<p>对于残差编码，CB 可以递归地划分为 TBs(Transform Blocks)。划分由残差四叉树表示。</p>

<p>如图 4 所示，仅指定方形 CB 和 TB 分区，其中块可以递归地分割为四象限。对于给定大小的 MxM 的 luma CB，一个标志表示它是否被划分为大小为 M/2xM/2 的四个块。如果可以更进一步划分(SPS 中指示的残差四叉树的最大深度所示)，则为每个划分分配一个标志，指示是否将其继续拆分为四叉树。由残差四叉树产生的叶子节点，是通过变换编码进一步处理的变换块。编码器指示它将使用的最大和最小 luma  TB 大小。当 CB 大小大于最大 TB 大小时，划分是隐士的。当划分会导致 luma TB 大小小于指定的最小值时，不再划分也是隐含的。chroma TB 大小是 luma TB 大小的一半，除非 luma TB 为 4x4，在这种情况下，单个 4x4 chroma TB 用于四个 4x4 luma TB 覆盖的区域。在帧内预测 CUs 情况下，最近相邻 TBs（在CB之内或之外）的解码样本被用作帧内预测的参考数据。</p>

<p>与之前标准不同，HEVC 设计允许一个 TB 跨越多个 PBs 用于帧间预测 CU，以最大限度地发挥四叉树结构 TB 分区的潜在编码效率优势。</p>

<h3 id="f-slices-and-tiles">F) Slices and Tiles</h3>

<p>Slice 是按照光栅扫描顺序处理 CTU 序列的。如图5(a)所示，可以将图片分割成一个或多个 slices，使得图片是一个或多个 slice 集合。在给定SPS 和 PPS 参数集的情况下，slice 是自包含的，可以从比特流中解析它们的语法元素，并且可以正确解码 slice 表示的图片区域中的样本值(除了 slice 边缘附近的循环过程效果)，不使用来自同以图片中其他 slice 的任何数据。这意味着帧内预测(例如，帧内图片空间信号预测或运动向量预测)不会跨 slice 边界执行。然而，可能需要来其他 slice 的一些信息，跨 slice 的应用在 Loop Filter 中。每个 slice 可以使用不同的编码类型进行编码，如下所示。</p>

<p>1) I Slice: Slice 内的所有 CUs 单元只使用帧内预测编码。<br />
2）P Slice: 除了 I Slice 的编码类型外，P Slice 中的一些 CUs 还可以使用 每个 PB 最多一个运动补偿预测信号的帧间预测来编码(即，单预测)。P Slice 仅使用 RPS List0。<br />
3）B Slice: 除了 P Slice 中可用的编码类型外，B Slice 中的一些 CUs 还可以使用每个 PB 最多两个运动补偿预测信号的帧间预测编码(即，双预测)。B Slice 可以同时使用 RPS List0 和 List1。</p>

<p>引入 slice 的目的是，在数据丢失后重新同步。此外，Slice 经常被限制使用最大位数，例如，用于分组传输。因此，根据视频场景中的不同，不同的 Slice 可能包含不同数量 CTU。除了 Slice 之外，HEVC 还定义了 Tiles，Tile 是图片中自包含且独立可解码的矩形区域。Tiles 的主要目的是支持使用并行处理架构进行编码和解码。多个 Tiles 可以在同一个 Slice内，共享头信息。对应的，同一个 Tile 也可以包含多个 Slices。如图 5(b) 所示，Tile 由一组矩形排列的 CTU 组成（通常，但不一定，所有 CTU 都包含大约相同数量的 CTU）。</p>

<p>为了辅助数据打包的粒度，还额外定义了相关 Slices。最后，使用 WPP，Slice 被划分为 CTU 行。在一行 CTU 中，只要做出了熵编码器的预测和自适应所需的一些决策，就可以开始同一行的解码。这样就可以在编解码中使用多线程，同时并行处理 CTU 行。图 5(c) 给出了示例。为了简化设计，不允许将 WPP 与 Tiles 结合使用(尽管原则上，这些功能可以在一起正常使用)。</p>

<h3 id="g-intrapicture-prediction">G) Intrapicture Prediction</h3>

<h3 id="h-interpicture-prediction">H) Interpicture Prediction</h3>

<h3 id="i-transform-scaling-and-quantization">I) Transform, Scaling, and Quantization</h3>

<h3 id="j-entropy-coding">J) Entropy Coding</h3>

<h3 id="k-in-loop-filters">K) In-Loop Filters</h3>

<h3 id="l-special-coding-modes">L) Special Coding Modes</h3>

<h2 id="profiles-tiers-and-levels">Profiles, Tiers And Levels</h2>

<h3 id="a-profile-level-and-tier-concepts">A) Profile, Level, and Tier Concepts</h3>

<p>Profiles，Tiers 和 Levels 指定了一致性点，使得具有类似功能需求的各种应用程序以可互操作的方式实施标准。Profile 定义了一组可用于生成一致性比特流的编码工具或算法；Level 对比特流的某些关键参数施加约束，它对应于解码器处理负载和内存的能力。根据 DPB 的最大采样率、最大图片大小、最大比特率、最小压缩比和容量以及在解码之前保存压缩数据以用于数据流管理的编码图片缓冲器(CPB)来建立 Level 限制。在 HEVC 的设计中，一些应用程序，其要求仅在最大比特率和 CPB 容量方面存在差异。为了解决此问题，为某些 Level 指定了两个 Tiers—Main Tier 用于大多数应用程序，High Tier 用于要求更苛刻的应用程序。</p>

<p>符合特定 Tier 和 Level 的解码器需要能够符合解码所有符合同一 Level 或 Tier 或其下任何级别的比特流。符合特定 Profile 文件的解码器必须支持该 Profile 文件中的所有功能。与解码器不同，编码器并不需要使用 Profile 中支持的任何特定特征集，单需要生成一致性比特流，即符合规定约束的比特流，这些约束使一致性解码器能够对其进行解码。</p>

<h3 id="b-the-hevc-profile-and-level-definitions">B) The HEVC Profile and Level Definitions</h3>

<p>预计到 2013 年 1 月，有三个针对不同应用要求的 Profiles(Main, Main10, Main Still Picture)将最终确定。最小化 Profile 文件的数量提供了设备之间最大程度的互操作性，并通过以下应用进一步证明了这一点：传统上独立的服务(如广播、移动、流媒体)正在汇聚到一个点，即大多数设备应可用于支持所有这些服务。这三个profile包括本文前面几节中描述的编码工具和高层语法，同时施加以下限制。</p>

<h2 id="section-2">历史与标准化进程</h2>

<p>在 H.264/AVC High Profile 于 2004 年年中最终确认之后，ITU-T VCEG 和 ISO/IEC MPEG 一致在努力确定编码效率的下一个重大进步何时可以实现标准化。VCEG 于 2004 年开始研究潜在的进展，于 2005 年初开始确定某些关键技术领域进行研究，并为本文开发了一个通用的 KTA 软件代码库。使用 KTA 软件代码库提出并验证了各种技术，该代码是从 H.264/AVC 参考软件 JM 开发的。</p>

<h2 id="section-3">结论</h2>

<p>新兴的 HEVC标准由ITU-T VCEG 和 ISO/IEC MPEG 组织共同开发和标准化。HEVC 代表了视频编码技术的一系列进步。其视频编码层设计基于传统的基于块的运动补偿混合视频编码概念，但与先前的标准有一些重要区别。</p>

<p>如果能将各种特性很好的结合使用，新设计的功能将节省大约 50% 的码率，同时获得先前标准(尤其是高分辨率视频)相比的同等视觉质量。有关压缩性能的更多详细信息，请参阅[Comparison of the coding efficiency of video coding standards–Including High Efficiency Video Coding]。实现的复杂性分析超出了本文的范围，然而，使用现代处理技术，HEVC 整体的编码器实现复杂度不是主要负担(例如，相对于H.264/AVC)，并且编码器复杂度也是可管理的。有关实现复杂性的更多详细信息，请参阅[HEVC Complexity and implementation analysis]。</p>

<p>JCT-VC 文件管理系统中提供了有关该项目的更多信息和文件<a href="https://phenix.int-evry.fr/jct/">JCT-VC Document Management System</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264/AVC 视频编码：工具、性能和复杂性]]></title>
    <link href="http://lazybing.github.io/blog/2021/07/26/video-coding-with-h264-tools-performance-and-complexity/"/>
    <updated>2021-07-26T01:59:05-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/07/26/video-coding-with-h264-tools-performance-and-complexity</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">摘要</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">1. 引言</a></li>
</ul>

<h1 id="section">摘要</h1>

<p>H.264/AVC 是 ISO/IEC 运动图像专家组与 ITU-T 视频编码专家组合作的产物，是最新的视频编码标准。这项标准化工作的目标是提高压缩效率、交互式(视频电话)和非交互式应用（广播、流媒体、存储、视频点播）的网络友好视频表示。与以前的标准相比，H.264/AVC 在较宽的比特率和视频分辨率范围内提供高达 50% 的压缩效率增益。与以前的标准相比，解码器的复杂度是 MPEG-2 的 4 倍，是 MPEG-4 的 2 倍。本文概述了 H.264/AVC 的新工具、特性和复杂性。</p>

<!--more-->

<h1 id="section-1">1. 引言</h1>

<p>ITU-T 的新视频编码标准建议，H.264/AVC，是视频编码标准序列中的最新标准。这些先前的标准反映了视频压缩的技术进步以及视频编码对不同应用和网络的适应性。应用范围从可视电话(H.261)到消费者 CD 视频（MPEG-1）以及标准清晰度或高清晰度电视（MPEG-2）的广播。用于视频通信的网络包括诸如 PSTN（H.263、MPEG-4）或 ISDN（H.261）之类的交换网络和诸如 ATM（MPEG-2、MPEG-4）、因特网（H.263、MPEG-4）或移动网络（H.263、MPEG-4）之类的分组网络。有线调制解调器、XDSL 和 UMTS 等新网络技术的重要性，对新的视频编码标准 H.264/AVC 产生了需求，针对交互式应用（如要求低延迟系统的视频电话）和非交互式应用（如存储、广播，标准清晰度电视的流媒体，其重点是高编码效率）时，必须特别考虑性能。将H.264/AVC 视频编码工具（如多参考帧、1/4 像素运动补偿、去块滤波或整数变换等）与以前的视频编码标准相比，H.264/AVC 在标准话视频编码的发展过程中带来了最多的算法不连续性。同时，H.264/AVC 在编码性能上实现了五年前还没有预见到的飞跃。2001 年 12 月，ITU-T 和 MPEG 的视频专家成立了联合视频团队（JVT）来开发这个 H.264/AVC 视频编码标准，这使得这一进展成为可能。H.264/AVC 于 2003 年 3月定稿，并于 2003 年 5 月获得 ITU-T 的批准。</p>

<p>现代视频通信使用的数字视频（从相机捕捉或使用适当的工具(如动画软件)合成)。在可选的预处理步骤(图1)中，发送者可以选择使用格式转换或增强技术对视频进行预处理。然后编码器对视频进行编码，并将视频表示为位流。在通过通信网络传输比特流之后，解码器解码视频,视频在可选的后处理步骤之后显示，后处理步骤可以包括格式转换、滤波以一致编码伪影、错误隐藏或视频增强。</p>

<p>该标准定义了位流的语法和语义，以及解码器在将位流解码为视频时需要执行的处理。因此，视频解码器制造商只能在成本和硬件要求等领域展开竞争。可选的解码视频的后处理是不同制造商将提供竞争工具以创建针对目标应用优化的解码前视频流的另一个领域。该标准没有定义如何进行编码或其他视频预处理，从而使制造商能够在成本、编码效率、错误恢复能力或硬件要求等领域与编码器竞争。同时，位流和解码器的标准化保留了任何通信标准互操作性的基本要求。</p>

<p>为了在不同的环境中进行高效的传输，不仅需要提高编码效率，而且还需要将编码后的视频无缝、方便地集成到所有当前和未来的协议和网络体系结构中。这包括尽最大努力交付的公共互联网，以及预计将成为新视频编码标准主要应用的无线网络。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[x264码率控制之VBV详解]]></title>
    <link href="http://lazybing.github.io/blog/2021/07/21/x264-rate-control-vbv-algorithm/"/>
    <updated>2021-07-21T05:43:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/07/21/x264-rate-control-vbv-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#vbv-buffer" id="markdown-toc-vbv-buffer">为什么需要 VBV Buffer</a></li>
  <li><a href="#section" id="markdown-toc-section">基本参数</a></li>
</ul>

<p>VBV 作为 H264 中码率控制的重要模块，它的作用是确保码率不会超过某个最大值。</p>

<!--more-->

<p>先来看一下，VBV 的作用，如图所示。分别设置<code>vbv-maxrate 2000</code>/<code>vbv-maxrate 1500</code>/<code>vbv-bufsize 2000</code>/<code>vbv-bufsize 1500</code>。</p>

<p><img src="http://lazybing.github.io/images/h264_vbv/ratecontrol_vbv.PNG" title="'VBV'" /></p>

<h2 id="vbv-buffer">为什么需要 VBV Buffer</h2>

<p>假设我们的编码是面向存储的，那么就无需这个 buffer，编码出来的码率随便你怎么波动，我只存在本地就 OK。现在问题是我们是面向传输的，要考虑到网络的带宽问题，以及网络的抖动，如果我们编码出来的码率变化非常大，那么很不利于传输，比如为了帧的质量，突然编出来一个很大的帧，需要传输很久，那么解码端就会需要等很久，体现在播放时上是长时间卡住。因此需要这个 buffer 来平滑码率，它通过码率控制模块来进行反馈，当码率控制模块检测 buffer 时发现 buffer 很满了，就通过调节 QP 的方法，使编码的码率降下来。另外关于时延的问题，必须说明的是，引入 vbv buffer 模型并不是为了降低时延，相反它反而会引入时延，但它可以有效防止时延抖动，让你看视频不卡（只要防止下溢就行），通过把初始充盈度调大一点就能做的很好。引自<a href="https://blog.csdn.net/ccc_cccd/article/details/114042493">假想参考解码器 vbv HRD</a></p>

<h2 id="section">基本参数</h2>

<ul>
  <li>vbv-bufsize <integer> Set size of the VBV buffer (kbit)</integer></li>
  <li>vbv-maxrate <integer> Max local bitrate &lt;kbit/s&gt;</integer></li>
  <li>vbv-init    <float>   Initial VBV buffer occupancy</float></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264 Rate Control Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm/"/>
    <updated>2021-06-22T06:49:35-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/22/h264-rate-control-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基础知识</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">模糊复杂度估计</a></li>
  <li><a href="#vbv-algorithm" id="markdown-toc-vbv-algorithm">VBV Algorithm</a>    <ul>
      <li><a href="#lookahead-vbv-" id="markdown-toc-lookahead-vbv-">Lookahead vbv 调整</a></li>
      <li><a href="#vbv-" id="markdown-toc-vbv-">实时 VBV 调整</a></li>
      <li><a href="#mingop-vbv-" id="markdown-toc-mingop-vbv-">minGOP vbv 调整</a></li>
    </ul>
  </li>
  <li><a href="#mb-tree-algorithm" id="markdown-toc-mb-tree-algorithm">MB-Tree Algorithm</a>    <ul>
      <li><a href="#macroblock-tree-" id="markdown-toc-macroblock-tree-">Macroblock-Tree 的高层概述</a></li>
      <li><a href="#x264-lookahead" id="markdown-toc-x264-lookahead">x264 lookahead</a></li>
      <li><a href="#macroblock-tree-algorithm-mb-tree-" id="markdown-toc-macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</a></li>
    </ul>
  </li>
  <li><a href="#adaptive-quantization-algorithm" id="markdown-toc-adaptive-quantization-algorithm">Adaptive Quantization Algorithm</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">优化方法</a>    <ul>
      <li><a href="#vbr-" id="markdown-toc-vbr-">VBR 情况下的码率优化</a></li>
    </ul>
  </li>
</ul>

<p>码率控制是 H.264 编码器中非常重要的一个模块。码率控制主要包括两部分：码率分配(Bit Allocation)、量化参数调整(Quantitative Parameter Adjustment)。X264 的码率控制算法大致分为帧级码率控制、宏块级码率控制。帧级码率控制算法比如：VBV 调整。宏块级别码率控制比如：MBTree 算法、VAQ 感知量化算法。</p>

<!--more-->

<h1 id="section">基础知识</h1>

<p>码率控制的主要过程是：</p>

<ol>
  <li>根据前面已经编好的帧计算 SATD 值来预测当前帧的复杂度(第一帧 I 帧除外)；</li>
  <li>计算好复杂度后，根据复杂度和线性量化控制参数(qcomp)来计算 qpscale。qpscale 会影响最终编码时所用的 qp。</li>
  <li>根据目标码率和之前编码所用的比特数可以确定一个 rate_factor，若之前编码的比特数多与目标实际产生，则 rate_factor 减小。这个 rate_factor 是调整 qpscale 用的，还有 overflow 来对qpscale 来做溢出补偿处理来控制文件大小。</li>
  <li>最后根据计算公式得到 qp。</li>
</ol>

<p>参考文档：</p>

<p><a href="https://pianshen.com/article/4198342118">x264 码率控制算法原理</a></p>

<p>编码所需的 bits 与实际编码的复杂度和量化参数有关，复杂度越复杂，量化参数越小，所需 bits 越少。复杂度用运动补偿后残差的 SATD 表示。</p>

<p>qscale = 0.85 * 2^((qp - 12)/6.0)   (1) <br />
qp = 12 + 6 * log2(qscale / 0.85)   (2)</p>

<p>x264 中的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">qp2scale</span><span class="p">(</span><span class="kt">float</span> <span class="n">qp</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">powf</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span> <span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">))</span> <span class="o">/</span> <span class="mf">6.0f</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">qscale2qp</span><span class="p">(</span><span class="kt">float</span> <span class="n">qscale</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="mf">12.0f</span> <span class="o">+</span> <span class="n">QP_BD_OFFSET</span><span class="p">)</span> <span class="o">+</span> <span class="mf">6.0f</span> <span class="o">*</span> <span class="n">log2f</span><span class="p">(</span><span class="n">qscale</span> <span class="o">/</span> <span class="mf">0.85f</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="section-1">模糊复杂度估计</h1>

<p>One Pass 编码中，由经过运动补偿后残差的 SATD 代表一帧的复杂度，SATD 是将残差做  Hadrmard 变换后再取绝对值的总和，它作为一种简单的时频交换，能在一定程度上衡量生产码流的大小。</p>

<p>模糊复杂度是基于已编码帧的复杂度加权得到的。使用复杂度加权，相对于使用单独一帧的复杂度，能避免 QP 的波动：</p>

<p>blurred_complexity = cplxsum/cplxcount  <br />
cplxsum[i]   = cplxsum[i - 1] * 0.5 + satd[i - 1]<br />
cplxcount[i] = cplxcount[i - 1] * 0.5 + 1</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">double</span> <span class="n">wanted_bits</span><span class="p">,</span> <span class="n">overflow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="o">=</span> <span class="n">x264_rc_analyse_slice</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span> <span class="o">*=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLIP_DURATION</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">f_duration</span><span class="p">)</span> <span class="o">/</span> <span class="n">BASE_FRAME_DURATION</span><span class="p">);</span>
</span><span class="line"><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">rce</span><span class="p">.</span><span class="n">text_bits</span> <span class="o">=</span> <span class="n">rc</span><span class="o">-&gt;</span><span class="n">last_satd</span><span class="p">;</span>
</span><span class="line"><span class="n">rce</span><span class="p">.</span><span class="n">blurred_complexity</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxsum</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">short_term_cplxcount</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="vbv-algorithm">VBV Algorithm</h1>

<p>VBV 是一种帧级别的码率控制算法，它是这样一种机制: VBV 相当于一个容器，每编码一帧，都从容器内取走对应 bit 的数据；与此同时，往容器内以固定的速度输入 bit。每编码完一帧，根据容器内的充盈状态(上溢/下溢)，更新接下来编码参数，使得容器的充盈程都总是处于合理的范围内。</p>

<p>视频缓冲检测器(VBV, Video Buffer Verifer)是 MPEG 视频缓冲模型，可以确保码率不会超过某个最大值。VBV Buffer Size 通常设置为 maximum rate 的两倍;如果客户端缓存比较小，设置 bufsize 等于 maxrate;如果想要限制码流的码率，设置 buffersize 为 maximum rate 的一半或更小。</p>

<p>先来看一下，x264 中关于 VBV 的几个变量定义：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="kt">x264_ratecontrol_t</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">b_vbv</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">b_vbv_min_rate</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/*VBV stuff*/</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">buffer_size</span><span class="p">;</span>     <span class="c1">//VBV buffer size, 容器的总容量</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">buffer_fill_final</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">buffer_fill_final_min</span><span class="p">;</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">buffer_fill</span><span class="p">;</span> <span class="c1">//planned buffer, if all in-progress frames hit their bit budget</span>
</span><span class="line">    <span class="n">doublt</span> <span class="n">buffer_rate</span><span class="p">;</span> <span class="c1">//# of bits added to buffer_fill after each frame</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">vbv_max_rate</span><span class="p">;</span><span class="c1">//# of bits added to buffer_fill per second</span>
</span><span class="line">    <span class="kt">predictor_t</span> <span class="o">*</span><span class="n">pred</span><span class="p">;</span>  <span class="c1">//predict frame size from satd</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">single_frame_vbv</span><span class="p">;</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">rate_factor_max_increment</span><span class="p">;</span> <span class="c1">//Don&#39;t allow RF above(CRF + this value)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>X264 中，关于 VBV 的调整在 clip_qscale 中。根据是否有 lookahead，可以分为 lookahead vbv 调整和实时 VBV 调整两种。</p>

<h2 id="lookahead-vbv-">Lookahead vbv 调整</h2>

<p>从 lookahead 模块可以得到未来若干帧的复杂度。vbv 算法的原理是：根据相同的帧类型，使用相同的 qscale 应用到 lookahead 中的帧中，检测会不会有帧使得 VBV 缓存下溢，并且 lookahead 中所有帧编码结束后，缓存填充度在一个合理的范围内(0.5-0.8)，小步调整 qscale 直到满足上述要求。注意，代码中的对于 X264_TYPE_B 和 X264_TYPE_BREF 使用相同的 qscale，这里并步准确，其实可以设置不同的值，只需要使得 BREF 在 B 和 P 之间即可。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">terminate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="cm">/*Avoid an infinite loop*/</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">terminate</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">iterations</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">buffer_fill_cur</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">target_fill</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">total_duration</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">	<span class="kt">double</span> <span class="n">last_duration</span> <span class="o">=</span> <span class="n">fenc_cpb_duration</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">?</span> <span class="n">q</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="nl">f_ip_factor</span> <span class="p">:</span> <span class="n">q</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_pb_factor</span><span class="p">;</span>
</span><span class="line">	<span class="n">frame_q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_ip_factor</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="cm">/* Loop over the planned future frames. */</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer_fill_cur</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_fill_cur</span> <span class="o">&lt;=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">total_duration</span> <span class="o">+=</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class="line">	    <span class="n">buffer_fill_cur</span> <span class="o">+=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="n">last_duration</span><span class="p">;</span>
</span><span class="line">	    <span class="kt">int</span> <span class="n">i_type</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">i_planned_type</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	    <span class="kt">int</span> <span class="n">i_satd</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">i_planned_satd</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	    <span class="k">if</span><span class="p">(</span> <span class="n">i_type</span> <span class="o">==</span> <span class="n">X264_TYPE_AUTO</span> <span class="p">)</span>
</span><span class="line">		<span class="k">break</span><span class="p">;</span>
</span><span class="line">	    <span class="n">i_type</span> <span class="o">=</span> <span class="n">IS_X264_TYPE_I</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_I</span> <span class="p">:</span> <span class="n">IS_X264_TYPE_B</span><span class="p">(</span> <span class="n">i_type</span> <span class="p">)</span> <span class="o">?</span> <span class="nl">SLICE_TYPE_B</span> <span class="p">:</span> <span class="n">SLICE_TYPE_P</span><span class="p">;</span>
</span><span class="line">	    <span class="n">cur_bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">frame_q</span><span class="p">[</span><span class="n">i_type</span><span class="p">],</span> <span class="n">i_satd</span> <span class="p">);</span>
</span><span class="line">	    <span class="n">buffer_fill_cur</span> <span class="o">-=</span> <span class="n">cur_bits</span><span class="p">;</span>
</span><span class="line">	    <span class="n">last_duration</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">fenc</span><span class="o">-&gt;</span><span class="n">f_planned_cpb_duration</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="cm">/* Try to get to get the buffer at least 50% filled, but don&#39;t set an impossible goal. */</span>
</span><span class="line">	<span class="n">target_fill</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">+</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="p">);</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span> <span class="n">buffer_fill_cur</span> <span class="o">&lt;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">q</span> <span class="o">*=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class="line">	    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">	    <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="cm">/* Try to get the buffer no more than 80% filled, but don&#39;t set an impossible goal. */</span>
</span><span class="line">	<span class="n">target_fill</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span> <span class="o">-</span> <span class="n">total_duration</span> <span class="o">*</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">vbv_max_rate</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="p">);</span>
</span><span class="line">	<span class="k">if</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">b_vbv_min_rate</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_fill_cur</span> <span class="o">&gt;</span> <span class="n">target_fill</span> <span class="p">)</span>
</span><span class="line">	<span class="p">{</span>
</span><span class="line">	    <span class="n">q</span> <span class="o">/=</span> <span class="mf">1.01</span><span class="p">;</span>
</span><span class="line">	    <span class="n">terminate</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">	    <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="p">}</span>
</span><span class="line">	<span class="k">break</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="vbv-">实时 VBV 调整</h2>

<p>如果没有 lookahead，未来帧的复杂度未知，只能根据当前帧的复杂度，控制缓存的充盈程度。算法主要流程如下：</p>

<ol>
  <li>对于 P 帧和第一个 I 帧，让当前帧编码完成后，缓存区至少还有一半容量。</li>
  <li>限制每帧大小不能超过当前缓存量的一半。</li>
  <li>限制每帧大小至少是 buffer_rate 的一半。buffer_rate = vbv-maxrate/fps。</li>
  <li>限制 qscale 不能小于输入 qscale。</li>
</ol>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_P</span> <span class="o">||</span>
</span><span class="line">        <span class="p">(</span> <span class="n">pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="o">&amp;&amp;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_non_b_pict_type</span> <span class="o">==</span> <span class="n">SLICE_TYPE_I</span> <span class="p">)</span> <span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class="line">        <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">q</span> <span class="o">/=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* Now a hard threshold to make sure the frame fits in VBV.</span>
</span><span class="line"><span class="cm">     * This one is mostly for I-frames. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span> <span class="p">);</span>
</span><span class="line">    <span class="cm">/* For small VBVs, allow the frame to use up the entire VBV. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">max_fill_factor</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_buffer_size</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_vbv_max_bitrate</span> <span class="o">/</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">fps</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="cm">/* For single-frame VBVs, request that the frame use up the entire VBV. */</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">min_fill_factor</span> <span class="o">=</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">single_frame_vbv</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="n">max_fill_factor</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="o">/</span><span class="p">(</span><span class="n">max_fill_factor</span><span class="o">*</span><span class="n">bits</span><span class="p">),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">        <span class="n">q</span> <span class="o">/=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">        <span class="n">bits</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">bits</span> <span class="o">&lt;</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_rate</span><span class="o">/</span><span class="n">min_fill_factor</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">qf</span> <span class="o">=</span> <span class="n">x264_clip3f</span><span class="p">(</span> <span class="n">bits</span><span class="o">*</span><span class="n">min_fill_factor</span><span class="o">/</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_rate</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
</span><span class="line">        <span class="n">q</span> <span class="o">*=</span> <span class="n">qf</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span> <span class="n">q0</span><span class="p">,</span> <span class="n">q</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="mingop-vbv-">minGOP vbv 调整</h2>

<p>B 帧 QP 不直接被 VBV 调整，它由 P 帧加一个偏移量得到。这一步检查当前 P 帧和（编码顺序）到下一个 P 帧之前的 B 帧的复杂度。适当调低 qscale (调高码率预算)，使得本 minGOPher 过后，缓存区没有上溢。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">double</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">predict_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">pred</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">sh</span><span class="p">.</span><span class="n">i_type</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">rcc</span><span class="o">-&gt;</span><span class="n">last_satd</span><span class="p">);</span>
</span><span class="line"><span class="kt">double</span> <span class="n">frame_size_maximum</span> <span class="o">=</span> <span class="n">X264_MIN</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">frame_size_maximum</span><span class="p">,</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">buffer_fill</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">));</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="n">frame_size_maximum</span><span class="p">)</span>
</span><span class="line">    <span class="n">q</span> <span class="o">*=</span> <span class="n">bits</span> <span class="o">/</span> <span class="n">frame_size_maximum</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcc</span><span class="o">-&gt;</span><span class="n">b_vbv_min_rate</span><span class="p">)</span>
</span><span class="line">    <span class="n">q</span> <span class="o">=</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>参考文档:<br />
<a href="https://codesequoia.wordpress.com/2010/04/19/what-are-cbr-vbv-and-cpb/">What are CBR, VBV and CPB</a>  <br />
<a href="https://www.youtube.com/watch?v=Mn8v1ojV80M">The Hypothetical Reference Decoder(HRD)</a></p>

<h1 id="mb-tree-algorithm">MB-Tree Algorithm</h1>

<h2 id="macroblock-tree-">Macroblock-Tree 的高层概述</h2>

<p>MB-tree 算法的目的是预测信息量，该信息量表示每个宏块对未来帧的贡献。该信息允许MB-tree基于其贡献，加权每个树的质量宏块。为此，MB-tree的工作方向与预测方向相反，将信息从将来的帧传播回要编码的当前帧。</p>

<p>为此，MB-tree 需要知道多种信息，或者至少近似的信息量。首先，它必须知道即将分析的未来帧的帧类型。其次，它必须知道这些帧的运动向量。第三，它必须知道每个步骤要传播多少信息量，这会根据帧内和帧间消耗来计算。接下来描述的lookahead会说明如何获取这些信息。</p>

<h2 id="x264-lookahead">x264 lookahead</h2>

<p>x264 有个复杂的lookahead模块，该模块设计用来，在真正的编码模块分析之前，预测帧的编码消耗。它用这些预测信息来做很多的决定，比如自适应的B帧的位置、显示加权预测、以及缓冲区受阻的码率控制的比特分配。因为性能的原因，它的操作是对一半分辨率进行的，并且仅仅计算SATD残差，并不做量化和重建。</p>

<p>lookahead的核心是<code>x264_slicetype_frame_cost</code>函数，它会被重复的调用来计算p0/p1/b的帧代价。p0是被分析帧的前向预测帧，p1是被分析帧的后向预测帧，b是被分析的帧。如果p1等于b，则分析的帧是P帧。如果p0等于b，则分析的帧是I帧。因为<code>x264_slicetype_frame_cost</code>可能会在算法中被重复调用很多次，每次调用的结果都要保存下来以备未来使用。</p>

<p><code>x264_slicetype_frame_cost</code>针对每个宏块调用<code>x264_slicetype_mb_cost</code>。因为帧只有一半的分辨率，每个宏块是<code>8x8</code>的，而不是<code>16x16</code>的。<code>x264_slicetype_mb_cost</code>对每个参考帧执行向量搜索。向量搜索是典型的六边形运动搜索。</p>

<p>对于B帧，它还会检查一些可能的双向模式：一个模式类似于264的时间方向，零向量；一个模式使用运动矢量结果来自list0和list1运动搜索。<code>x264_slicetype_mb_cost</code>同样计算合适的帧内代价。所有的这些代价被保存下来，用于将来使用。这对于MB-tree非常重要，它需要这些信息用于计算。</p>

<p>这些分析的结果主要用于Viterbi算法中自适应B帧的放置。Viterbi 算法的输出不仅仅在下一帧的类型判断时使用到，而且在后面N帧的类型判断中会用到，其中N是lookahead的大小。该计划实际上是一个队列：it changes over time as frames are pulled from one end and encoded using the specified frame types, frames are added to the other end as new frames enter the encoder, and the plan is recalculated. 该计划的存在对于宏块树非常重要：它意味着很多需要知道未来帧帧类型的算法，有个可信赖的精准预测。即使GOP的结构是变化的。</p>

<p>结果，MB-tree知道未来N帧的帧类型，即近似的运动矢量和模式决策以及帧内/帧间模式代价。这样的计算成本接近于零，因为这些数据在做其他任务时，在编码器内部已经计算完了。即使这样，相对于总的编码时间，lookahead的计算消耗也是成本很低的。</p>

<h2 id="macroblock-tree-algorithm-mb-tree-">MacroBlock-Tree Algorithm (MB-Tree 算法)</h2>

<p>对于每一帧，我们在所有宏块上执行 propagate step，MacroBlock-Tree 操作的 propagate step 如下：</p>

<ol>
  <li>对于当前宏块，读取下面变量的值：
    <ul>
      <li>intra_cost: 该宏块的帧内模式的预测 SATD 代价。</li>
      <li>inter_cost: 该宏块的帧间模式的预测 SATD 代价。如果该值比 intra_cost 大，设置其为 intra_cost。</li>
      <li>propatate_in: 该宏块的 propagate_cost。因为没有任何信息，执行 propagate 的第一帧，它的 propagate_cost 值为 0。</li>
    </ul>
  </li>
  <li>计算要执行 propagate 的当前宏块对其参考帧的宏块的信息的分数，称为 propagate_fraction。计算方法为 1 - intra_cost / inter_cost。例如，如果 inter_cost 是 intra_cost 的 80%，我们说该宏块有 20% 的信息来自于它的参考帧。</li>
  <li>和当前宏块有关的所有信息总和大约为 intra_cost + propagate_cost（自身信息和提供给后续帧的信息），使用这个总和乘以继承率 propagate fraction, 可以得到来继承自参考帧的信息量 propagate amount。</li>
  <li>将 propagate_amount 划分给参考帧中相关的宏块，由于当前宏块在参考帧中运动搜索得到的补偿区域可能涉及多个宏块，即参考帧中的多个宏块都参与了当前宏块的运动补偿，所以我们根据参考帧宏块参与补偿的部分尺寸大小来分配 propagate amount。特别的，对于 B 帧，我们把 propatate amount 先平分给两个参考帧，再进一步分配给参考帧中的宏块。参考帧中的宏块最终被分到的 propagate amount 加起来就是它的 propagate cost。</li>
  <li>从前向预测的最后一帧向前一直计算到当前帧，可以得到当前帧中每个宏块对后续 n 帧的 propagate_cost，最后根据当前帧每个宏块的 propatate_cost，计算相应的偏移系数 qp_offset，所使用的公式如下：</li>
</ol>

<p>MacroblockQP = -strength * log2((intra_cost + propagate_cost) / intra_cost)。</p>

<p>其中强度系数 strength 为常量，对于未被参考的宏块而言，propagate_cost = 0, qp_offset = 0。</p>

<p>X264 源码中实现MB-Tree 的函数为 macroblock_tree，其中调用了如下三个函数来实现上述步骤：</p>

<ol>
  <li>slicetype_frame_cost():计算宏块的帧内代价和帧间代价。</li>
  <li>macroblock_tree_propagate():计算当前宏块的遗传代价。</li>
  <li>macroblock_tree_finish():计算量化参数偏移系数。</li>
</ol>

<p>参考文档：<br />
<a href="https://download.csdn.net/download/To_Be_IT_1/19848868?spm=1001.2014.3001.5501">A novel macroblock-tree algorithm for high-performance optimization of.pdf</a></p>

<h1 id="adaptive-quantization-algorithm">Adaptive Quantization Algorithm</h1>

<p>自适应量化就是根据宏块的复杂度来调整每个宏块量化时的量化参数。自适应量化的基本原理是：根据当前宏块的复杂度 SSD，与当前帧的平均复杂度做对比，若高于平均，则分配更多的码率，即用小于当前帧 QP 值的量化步长；低于平均值则分配更少的码率，即用大于当前帧的 QP 值的量化步长。</p>

<p>自适应量化主要有两个参数：aq-mode（自适应量化模式）、aq-strength（自适应量化强度）。自适应量化强度决定码率偏向于低细节(SSD)部分的强度。</p>

<p>X264 中，自适应量化的实现在<code>x264_adaptive_quant_frame</code>中：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* constants chosen to result in approximately the same overall bitrate as without AQ.</span>
</span><span class="line"><span class="cm"> * FIXME: while they&#39;re written in 5 significant digits, they&#39;re only tuned to 2. */</span>
</span><span class="line"><span class="kt">float</span> <span class="n">strength</span><span class="p">;</span>
</span><span class="line"><span class="kt">float</span> <span class="n">avg_adj</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line"><span class="kt">float</span> <span class="n">bias_strength</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">bit_depth_correction</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">avg_adj_pow2</span> <span class="o">=</span> <span class="mf">0.f</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class="line">            <span class="kt">float</span> <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">powf</span><span class="p">(</span> <span class="n">energy</span> <span class="o">*</span> <span class="n">bit_depth_correction</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.125f</span> <span class="p">);</span>
</span><span class="line">            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">            <span class="n">avg_adj</span> <span class="o">+=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">            <span class="n">avg_adj_pow2</span> <span class="o">+=</span> <span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="n">avg_adj</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class="line">    <span class="n">avg_adj_pow2</span> <span class="o">/=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_count</span><span class="p">;</span>
</span><span class="line">    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class="line">    <span class="n">avg_adj</span> <span class="o">=</span> <span class="n">avg_adj</span> <span class="o">-</span> <span class="mf">0.5f</span> <span class="o">*</span> <span class="p">(</span><span class="n">avg_adj_pow2</span> <span class="o">-</span> <span class="mf">14.f</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_adj</span><span class="p">;</span>
</span><span class="line">    <span class="n">bias_strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">else</span>
</span><span class="line">    <span class="n">strength</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">f_aq_strength</span> <span class="o">*</span> <span class="mf">1.0397f</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_height</span><span class="p">;</span> <span class="n">mb_y</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">mb_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mb_x</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_width</span><span class="p">;</span> <span class="n">mb_x</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">float</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">mb_xy</span> <span class="o">=</span> <span class="n">mb_x</span> <span class="o">+</span> <span class="n">mb_y</span><span class="o">*</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_mb_stride</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE_BIASED</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">)</span> <span class="o">+</span> <span class="n">bias_strength</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.f</span> <span class="o">-</span> <span class="mf">14.f</span> <span class="o">/</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">*</span> <span class="n">qp_adj</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">param</span><span class="p">.</span><span class="n">rc</span><span class="p">.</span><span class="n">i_aq_mode</span> <span class="o">==</span> <span class="n">X264_AQ_AUTOVARIANCE</span> <span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">qp_adj</span> <span class="o">-</span> <span class="n">avg_adj</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="kt">uint32_t</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">ac_energy_mb</span><span class="p">(</span> <span class="n">h</span><span class="p">,</span> <span class="n">mb_x</span><span class="p">,</span> <span class="n">mb_y</span><span class="p">,</span> <span class="n">frame</span> <span class="p">);</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">=</span> <span class="n">strength</span> <span class="o">*</span> <span class="p">(</span><span class="n">x264_log2</span><span class="p">(</span> <span class="n">X264_MAX</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">14.427f</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">BIT_DEPTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">quant_offsets</span> <span class="p">)</span>
</span><span class="line">            <span class="n">qp_adj</span> <span class="o">+=</span> <span class="n">quant_offsets</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">];</span>
</span><span class="line">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span>
</span><span class="line">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">f_qp_offset_aq</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">qp_adj</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">frames</span><span class="p">.</span><span class="n">b_have_lowres</span> <span class="p">)</span>
</span><span class="line">            <span class="n">frame</span><span class="o">-&gt;</span><span class="n">i_inv_qscale_factor</span><span class="p">[</span><span class="n">mb_xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">x264_exp2fix8</span><span class="p">(</span><span class="n">qp_adj</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="section-2">优化方法</h1>

<h2 id="vbr-">VBR 情况下的码率优化</h2>

<p>通常情况下，CRF 的值与 QP 都是严格一对一的，这里其实是并不准确的。比如当前帧画面复杂，人眼对其并不敏感，此时可以选择更大的 QP。基于此，优化思路是：根据当前帧的复杂度，优化 CRF 与 QP 之间的映射关系。这个在纯 CRF 下可以节省 3% 的码率。基本思想就是让更多的码率用于人眼敏感的平坦区域。这就实现了<strong>帧级别的内容自适应</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H.264 Loop Filter Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/06/09/h264-loop-filter/"/>
    <updated>2021-06-09T17:05:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/06/09/h264-loop-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">引入环路滤波的原因</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">环路滤波的介绍</a></li>
</ul>

<p>本文将从去块滤波的引入原因出发，分析去块滤波的原理、强度、决策、实现，并给出一个具体的实例，最后会给出 x264 中关于 Deblock 的代码实现。</p>

<!--more-->

<h2 id="section">引入环路滤波的原因</h2>

<p>在编码过程中，会因如下原因引入块效应：</p>

<ol>
  <li>每个宏块的变换、量化过程都是独立进行的，采用的量化参数不同，这就会引入量化误差，导致相邻块边界步连续。</li>
  <li>在运动补偿中，相邻块的预测值可能来自不同图像的不同位置，导致预测残差信号在边界产生数值不连续。</li>
</ol>

<p>环路滤波的引入，可以调整相邻宏块边缘上的像素值，降低不连续性，使其看起来更平滑。</p>

<h2 id="section-1">环路滤波的介绍</h2>

<p>下面给出两篇论文中，关于环路滤波部分的介绍：首先给出<code>Overview of the H.264/AVC Video Coding Standard</code> 中的<code>K. In-Loop Deblocking Filter</code>的介绍。我把它翻译成长中文如下。</p>

<blockquote>
  <p>基于块的编码的一个特殊特征是偶然产生可见的块结构。块边缘通常以低于内部像素的精度重建，块通常被认为是当前压缩方法中最明显的伪影之一。为此，H.264/AVC 定义了一种自适应的环路去块滤波器，其中滤波的强度由若干语法元素的值控制。有关自适应去块滤波器的详细说明，请参阅<a href="">Adaptive deblocking filter</a>;</p>

  <p>图 16 给出了使用一维边缘的可视化的去块滤波器的原理。样本 p0 和 q0 以及 p1 和 q1 是否被滤波取决于使用的量化参数(QP)和量化阈值α(QP)和β(QP)。因此，仅当满足以下每个条件时，才进行 p0 和 q0 的滤波：<br />
1. |p0 - q0 | &lt; α(QP) <br />
2. |p1 - p0 | &lt; β(QP)<br />
3. |q1 - q0 | &lt; β(QP) <br />
其中 β(QP) 比 α(QP) 小的多。如果满足相应的以下条件，则进行 p1 或 q1 的滤波： |p2 - p0| &lt; β(QP) 或者 |q2 - q0| &lt; β(QP)</p>

  <p>基本思想是，如果测量块边缘附近的样本之间相对较大的绝对差，则很可能是块伪影，因此应减少。然而，如果该差异的幅度太大以致不能用编码中使用的量化的粗糙度来解释，则边缘更可能反映源图片的实际行为，并且不应被平滑。</p>

  <p>块效应降低，而内容的锐化程度基本不变。因此，主观质量显著提高。滤波器通常将比特率降低 5%-10%，同时产生与未滤波视频相同的客观质量。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intra-frame Prediction Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/05/26/intra-frame-algorithm/"/>
    <updated>2021-05-26T07:38:25-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/05/26/intra-frame-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#intra-frame-prediction-elements" id="markdown-toc-intra-frame-prediction-elements">Intra-Frame Prediction Elements</a></li>
  <li><a href="#the-existing-intra-frame-prediction-algorithm-flows-and-questions" id="markdown-toc-the-existing-intra-frame-prediction-algorithm-flows-and-questions">The Existing Intra-Frame Prediction Algorithm Flows And Questions</a></li>
</ul>

<p>本论文详细分析了帧内预测算法的原则和流程，同时提出了一个提升算法，并阐述了优势。通过实现关于H.264/AVC的标准和和应用实验，证明算法具有实用价值和促进作用。</p>

<p>“Intra-frame Prediction Algorithm Based on the H.264/AVC Research and Improvement”</p>

<!--more-->

<h2 id="introduction">Introduction</h2>

<p>在帧内编码的过程中，有很多帧内预测模式已被采用提高效率。通过这种方法，空间图像信息的冗余将被删除。亮度预测被分为四个部分，它们分别是 4x4 帧内预测、16x16 帧内预测、8x8 帧内预测和 I-PCM 模式。</p>

<p>4x4 模式用于小的预测宏块，来处理详细而复杂的图像。在图像编码中，处理平坦区域使用更大的宏块的帧内 16x16 模式。I-PCM 模式是一个特别模式，它在特殊情况下使用，当原始数据直接传输比预测编码传输还要低时使用。帧内 8x8 预测用于高清，这个是在 2005 年提出的预测。拉格朗日 RD 模型，决定在正确的时间选择。</p>

<h2 id="intra-frame-prediction-elements">Intra-Frame Prediction Elements</h2>

<p>帧内预测编码使用图像信息字段的相关性以压缩冗余。它基于在宏块的边界上，主要是指左边宏块、上方宏块和右方宏块来预测当前宏块。之后进行 DCT 和量化，从而达到压缩编码的目的。</p>

<p>在编码过程中，有时需要根据具体的算法和 RDO 模型来选择最终成本最低的预测模式。</p>

<p>16x16 亮度采用垂直预测(模型 0)、水平预测(模型 1)、DC 预测(模型 2)、平面预测(模型 3)。这些预测模式均小于 4x4 亮度。通过 16x16 宏块通常是应用到简单的场景，并且没有很多细节。因此不需要支持多个纹理预测，亮度很可能与预测模式不同，唯一的区别是模型码。</p>

<p>为了减少标准中 4x4 预测模式差异带来的额外信息，采用了一种将帧内预测信息转换为信号模式的方法，从而实现基本信息压缩。</p>

<h2 id="the-existing-intra-frame-prediction-algorithm-flows-and-questions">The Existing Intra-Frame Prediction Algorithm Flows And Questions</h2>

<p>对一对 16x16 亮度和两个 8x8 亮度宏块的 RDO 帧内预测模式的完全搜索如下：</p>

<p>1).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H264 Motion Estimation Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/05/17/h264-motion-estimation-algorithm/"/>
    <updated>2021-05-17T07:54:51-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/05/17/h264-motion-estimation-algorithm</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">整数像素运动估计</a>    <ul>
      <li><a href="#diamond-search-algorithm" id="markdown-toc-diamond-search-algorithm">钻石搜索算法(Diamond Search Algorithm)</a></li>
      <li><a href="#hexagon-search-algorithm" id="markdown-toc-hexagon-search-algorithm">六边形搜索算法(Hexagon Search Algorithm)</a></li>
      <li><a href="#uneven-multi-hexagon-grid-search-algorithm" id="markdown-toc-uneven-multi-hexagon-grid-search-algorithm">非对称交叉多层次六边形网格搜索算法(Uneven Multi-hexagon-grid Search Algorithm)</a>        <ul>
          <li><a href="#umh-the-proposed-algorithm-for-umh" id="markdown-toc-umh-the-proposed-algorithm-for-umh">UMH 优化思路(The Proposed Algorithm For UMH)</a>            <ul>
              <li><a href="#search-range-decision-for-uneven-cross-pattern" id="markdown-toc-search-range-decision-for-uneven-cross-pattern">Search Range Decision for Uneven Cross Pattern</a></li>
              <li><a href="#optimize-for-multi-hexagon-grid-search" id="markdown-toc-optimize-for-multi-hexagon-grid-search">Optimize for Multi-hexagon-grid Search</a></li>
              <li><a href="#optimize-for-iterative-hexagon-search" id="markdown-toc-optimize-for-iterative-hexagon-search">Optimize for Iterative Hexagon Search</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">分数像素运动估计</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">亚像素搜索算法</a></li>
    </ul>
  </li>
</ul>

<p>运动估计是在参考帧中为当前编码的宏块寻找最佳匹配快，找到最佳匹配块后，运动估计会输出是运动矢量。</p>

<!--more-->

<p>运动估计的下一步是运动补偿(Motion Compensation)，即从当前块中减去匹配块得到残差块。在整个编码过程中，运动估计耗时占了整个编码过程的60%-80%不等，因此，对运动估计的优化是实现视频实时应用的关键。</p>

<p>H264 中运动估计的过程分为两步：1. 整数像素精度的估计。2. 分数像素级精度的估计。其中整数像素级的运动估计包括两类算法：全搜索算法、快速搜索算法(DIA/HEX/UMH)。</p>

<p>几个运动估计中用到的缩写：</p>

<ul>
  <li>MV: 运动矢量。被用来表示一个宏块基于该宏块中的另一个图像的位置。</li>
  <li>MVP:预测运动矢量。</li>
  <li>MVD：两个运动矢量的差值。</li>
  <li>SATD(Sum of Absolute Transformed Difference):即 hadamard 变换后再绝对值求和。</li>
  <li>SSD(Sum of Squared Difference) = SSE(Sum of Squared Error) 即差值的平方和。</li>
  <li>MAD(Mean Absolute Difference) = MAE(Mean Absolute Error) 即平均绝对差值。</li>
  <li>MSD(Mean Squared Difference) = MSE(Mean Squared Error) 即平均平方误差。</li>
</ul>

<h1 id="section">整数像素运动估计</h1>

<h2 id="diamond-search-algorithm">钻石搜索算法(Diamond Search Algorithm)</h2>

<p>钻石搜索算法有两种搜索模式： 大钻石搜索算法(LDSP)和小钻石搜索算法(SDSP)。大钻石搜索算法有 9 个搜索点，小钻石搜索算法有 5 个搜索点。</p>

<p>钻石搜索的步骤是：先使用 LDSP 进行搜索，直到最佳匹配点位于大菱形的中心位置；之后使用小菱形搜索，直至最佳匹配点位于小菱形的中心位置。</p>

<ul>
  <li>LDSP:</li>
</ul>

<ol>
  <li>从中心搜索位置开始，设置步长 S = 2</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>使用钻石搜索点图案搜索 8 个位置像素(X, Y), 以使(</td>
          <td>x</td>
          <td>+</td>
          <td>Y</td>
          <td>= S) 围绕位置 (0, 0)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>从搜索到的 9 个地点中选择，其中一个地点的费用最低</li>
  <li>如果在搜索窗口的中心找到了最小重量，请转到 SDSP 步骤</li>
  <li>如果在除中心以为的 8 个位置之一中找到最小重量，则将新的原点设置为此位置</li>
  <li>重复 LDSP</li>
</ol>

<ul>
  <li>SDSP：</li>
</ul>

<ol>
  <li>设置新的搜索原点</li>
  <li>将新步长设置为 S = S / 2</li>
  <li>重复搜索过程以找到重量最轻的位置</li>
  <li>选择权重最小的位置作为运动矢量权重最小的运动矢量位置。</li>
</ol>

<p><img src="http://lazybing.github.io/images/h264_me/diamond_search.png" title="'H264 Motion Estimation Diamond Search'" /></p>

<p>上图可以看出，LDSP 又可分为两种模式，LDSP(1) 中的两个菱形，有 4 个重合点；LDSP(2) 中的两个菱形，有 6 个重合点。不重复计算这些点，可以节省运算复杂度。</p>

<p>SDSP 中, 4 个菱形的角距离中心点距离相等，因此 SDSP(1) 和 SDSP(2) 可以看出是一种模式。两个临近的搜索菱形，有 2 个重合点，不重复计算这些点，同样可以节省运算复杂度。</p>

<p>x264 中只采用了钻石搜索里的小钻石搜索算法, 搜索半径为 1。 具体代码实现如下:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//diamond search, radius 1</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span>
</span><span class="line"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i_me_range</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">do</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">COST_MV_X4_DIR</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">costs</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">    <span class="n">COPY1_IF_LT</span><span class="p">(</span><span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">))</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmx</span> <span class="o">-=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmy</span> <span class="o">-=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">;</span>
</span><span class="line">    <span class="n">bcost</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">15</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&amp;&amp;</span><span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span><span class="p">));</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意：这段代码写的比较 trick，先把 bcost 左移四位，留出的最后四位，每一位都代表一个搜索点，初始化时，默认菱形中心点为最佳匹配点。若菱形周边点 cost 更小，就将该点作为中心点继续进行菱形搜索，直到最佳匹配点确为中心点，跳出循环。</p>

<p>这段代码的速度优化空间，正如上面分析的那样，可以避开两个相邻菱形的搜索重叠搜索点。</p>

<h2 id="hexagon-search-algorithm">六边形搜索算法(Hexagon Search Algorithm)</h2>

<p>所谓的六边形搜索算法，不止包括六边形搜索(搜索半径为 2)，还有小菱形搜索和正方形搜索(搜索半径为 1)两种。</p>

<p><img src="http://lazybing.github.io/images/h264_me/Hexagon_Search_Algorithm.png" title="'H264 Motion Estimation Hexagon Search'" /></p>

<p>六边形搜索算法采用 1 个大模板(六边形模板)和 2 个小模板（小菱形模板和小正方形模板），具体步骤如下：</p>

<ol>
  <li>
    <p>以搜索起点为中心，采用上图中左边的六边形模板进行搜索。计算区域中心及周围 6 个点处的匹配误差并比较，如最小 MBD 点位于模板中心点，则转至步骤 2；否则以上一次的 MBD 点作为中心点，以六边形模板为模板进行反复搜索。</p>
  </li>
  <li>
    <p>以上一次的 MBD 点为中心点，采用小菱形模板搜索和小正方形模板搜索，计算各点的匹配误差，找到 MBD点, 即为最优匹配点。</p>
  </li>
</ol>

<p>从上图中的六边形搜索可以看出，两个临近的六边形，有三个重叠搜索点，因此，可以通过减少重复计算，来提升搜索性能。事实上，x264 中已经采用了这种优化方法。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* equivalent to the above, but eliminates duplicate candidates */</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* hexagon */</span>
</span><span class="line"><span class="n">COST_MV_X3_DIR</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">costs</span>   <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X3_DIR</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">costs</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span> <span class="cm">/* +4 for 16-byte alignment */</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">6</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span> <span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
</span><span class="line">    <span class="n">bmx</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="n">bmy</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* half hexagon, not overlapping the previous iteration */</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span><span class="p">);</span> <span class="n">i</span><span class="o">--</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">COST_MV_X3_DIR</span><span class="p">(</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
</span><span class="line">                    <span class="n">costs</span> <span class="p">);</span>
</span><span class="line">        <span class="n">bcost</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">        <span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="n">dir</span> <span class="o">+=</span> <span class="p">(</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="n">dir</span> <span class="o">=</span> <span class="n">mod6m1</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">bmx</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">        <span class="n">bmy</span> <span class="o">+=</span> <span class="n">hex2</span><span class="p">[</span><span class="n">dir</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* square refine */</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line"><span class="n">COST_MV_X4_DIR</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">costs</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4_DIR</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">costs</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">6</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span> <span class="p">);</span>
</span><span class="line"><span class="n">COPY1_IF_LT</span><span class="p">(</span> <span class="n">bcost</span><span class="p">,</span> <span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span> <span class="p">);</span>
</span><span class="line"><span class="n">bmx</span> <span class="o">+=</span> <span class="n">square1</span><span class="p">[</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line"><span class="n">bmy</span> <span class="o">+=</span> <span class="n">square1</span><span class="p">[</span><span class="n">bcost</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line"><span class="n">bcost</span> <span class="o">&gt;&gt;=</span> <span class="mi">4</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="uneven-multi-hexagon-grid-search-algorithm">非对称交叉多层次六边形网格搜索算法(Uneven Multi-hexagon-grid Search Algorithm)</h2>

<p>运动估计中，起始搜索点和提前终止技术非常重要。</p>

<p>UMH 算法是基于 MV 具有时空相关性，因此可以结合上一帧和上一步中 MV 的方向和角度，来修改多层六边形的形状。</p>

<p>UMH 算法包含四中搜索模式:不均匀交叉搜索、多六边形网格搜索、迭代六边形搜索、菱形搜索。主要流程步骤如下:</p>

<p><img src="http://lazybing.github.io/images/h264_me/umhexagon.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<ol>
  <li>
    <p>选取合适的搜索起点。有以下几种起点的选择。</p>

    <p>①  mvp: 由于还是整像素搜索，所以这里对 MVP 取整，得到的整数的 mv 后采用小菱形搜索以得到比较优秀的 mv。② 原点：即 mv 为0，即当前块的位置。
 ③  上层块 mv。④ 共同位置块 mv，取上一参考图像与当前块相同位置的块为 mv，然后取整。⑤  共同位置参考 mv 通过参考图像距离计算后得到的 mv，然后取整。</p>
  </li>
  <li>
    <p>小菱形搜索和中菱形搜索。</p>

    <p>首先对中值 MV 和(0, 0)点进行小钻石搜索，计算出每个搜索点的 SAD 值，并找出新的 MBD 搜索点。如果新的 MBD 点的 SAD 值比门限1 的值(2000)还要大，就执行 Step4，否则继续。</p>

    <p>对搜索点进行中钻石搜索，来找出新的 MBD 搜索点。若 SAD 值小于门限值2(500)，停止搜索。否则继续。</p>
  </li>
  <li>
    <p>对称交叉搜索和六边形搜索。</p>

    <p>对上一步中找到的新的 MBD 搜索点，执行对称交叉搜索(半径为 7)和六边形搜索(半径为 2),计算这 20 个点的 SAD 值，并且找出本步最新的 MBD 点。</p>

    <p>如果该步找到的 MBD 点与上一步中的 MBD 点吻合，停止搜索。否则继续。</p>
  </li>
  <li>
    <p>非对称交叉搜索。执行非对称的交叉搜索，找到最新的 MBD 点。</p>
  </li>
  <li>
    <p>5x5搜索和多六边形网格搜索。执行 5x5 全搜索和多六边形网格搜索。</p>
  </li>
  <li>
    <p>迭代六边形搜索。设置上步中的 MBD 点作为搜索中心，执行迭代六边形搜索。</p>
  </li>
</ol>

<p>x264 中关于 UMH 算法的代码如下</p>

<figure class="code"><figcaption><span>X264_ME_UMH </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">        <span class="k">case</span> <span class="nl">X264_ME_UMH</span><span class="p">:</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="cm">/* Uneven-cross Multi-Hexagon-grid Search</span>
</span><span class="line"><span class="cm">             * as in JM, except with different early termination */</span>
</span><span class="line">
</span><span class="line">            <span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">pixel_size_shift</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
</span><span class="line">
</span><span class="line">            <span class="kt">int</span> <span class="n">ucost1</span><span class="p">,</span> <span class="n">ucost2</span><span class="p">;</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">cross_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* refine predictors */</span>
</span><span class="line">            <span class="n">ucost1</span> <span class="o">=</span> <span class="n">bcost</span><span class="p">;</span>
</span><span class="line">            <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="n">pmx</span><span class="p">,</span> <span class="n">pmy</span> <span class="p">);</span> <span class="c1">//1. 小菱形搜索算法用于median MV, the small diamond search</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">pmx</span> <span class="o">|</span> <span class="n">pmy</span> <span class="p">)</span>
</span><span class="line">                <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">//1. 小菱形搜索算法用于(0, 0), the small diamond search</span>
</span><span class="line">
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">==</span> <span class="n">PIXEL_4x4</span> <span class="p">)</span>
</span><span class="line">                <span class="k">goto</span> <span class="n">me_hex2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="n">ucost2</span> <span class="o">=</span> <span class="n">bcost</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">bmx</span> <span class="o">|</span> <span class="n">bmy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">bmx</span><span class="o">-</span><span class="n">pmx</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bmy</span><span class="o">-</span><span class="n">pmy</span><span class="p">))</span> <span class="p">)</span>
</span><span class="line">                <span class="n">DIA1_ITER</span><span class="p">(</span> <span class="n">bmx</span><span class="p">,</span> <span class="n">bmy</span> <span class="p">);</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                <span class="n">cross_start</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">            <span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* early termination */</span>
</span><span class="line"><span class="cp">#define SAD_THRESH(v) ( bcost &lt; ( v &gt;&gt; pixel_size_shift[i_pixel] ) )</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="o">&amp;&amp;</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span> <span class="p">);</span> <span class="c1">//2. 中菱形搜索算法，找出新的MBD, the middle diamond search point</span>
</span><span class="line">                <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="mi">2</span> <span class="p">);</span> <span class="c1">//2. 中菱形搜索算法，找出新的MBD, the middle diamond search point</span>
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost1</span> <span class="o">&amp;&amp;</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">                    <span class="k">break</span><span class="p">;</span>
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                    <span class="n">CROSS</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="n">range</span><span class="p">,</span> <span class="n">range</span> <span class="p">);</span> <span class="c1">//3. 对称的交叉搜索, symmetric cross search(radius 7)</span>
</span><span class="line">                    <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <span class="c1">//3. 六边形搜索，octagon search(radius 2)</span>
</span><span class="line">                    <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span> <span class="c1">//3. 六边形搜索，octagon search(radius 2)</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span> <span class="p">)</span>
</span><span class="line">                        <span class="k">break</span><span class="p">;</span>
</span><span class="line">                    <span class="n">cross_start</span> <span class="o">=</span> <span class="n">range</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* adaptive search range */</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">i_mvc</span> <span class="p">)</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="cm">/* range multipliers based on casual inspection of some statistics of</span>
</span><span class="line"><span class="cm">                 * average distance between current predictor and final mv found by ESA.</span>
</span><span class="line"><span class="cm">                 * these have not been tuned much by actual encoding. */</span>
</span><span class="line">                <span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">range_mul</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">},</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">},</span>
</span><span class="line">                <span class="p">};</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">mvd</span><span class="p">;</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">sad_ctx</span><span class="p">,</span> <span class="n">mvd_ctx</span><span class="p">;</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="n">i_mvc</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">==</span> <span class="n">PIXEL_16x16</span> <span class="p">)</span>
</span><span class="line">                        <span class="cm">/* mvc is probably the same as mvp, so the difference isn&#39;t meaningful.</span>
</span><span class="line"><span class="cm">                         * but prediction usually isn&#39;t too bad, so just use medium range */</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
</span><span class="line">                    <span class="k">else</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">                            <span class="o">+</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="cm">/* calculate the degree of agreement between predictors. */</span>
</span><span class="line">                    <span class="cm">/* in 16x16, mvc includes all the neighbors used to make mvp,</span>
</span><span class="line"><span class="cm">                     * so don&#39;t count mvp separately. */</span>
</span><span class="line">                    <span class="n">denom</span> <span class="o">=</span> <span class="n">i_mvc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                    <span class="n">mvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">i_pixel</span> <span class="o">!=</span> <span class="n">PIXEL_16x16</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="n">mvd</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">                            <span class="o">+</span> <span class="n">abs</span><span class="p">(</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">mvp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mvc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">                        <span class="n">denom</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                    <span class="n">mvd</span> <span class="o">+=</span> <span class="n">x264_predictor_difference</span><span class="p">(</span> <span class="n">mvc</span><span class="p">,</span> <span class="n">i_mvc</span> <span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="n">sad_ctx</span> <span class="o">=</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">SAD_THRESH</span><span class="p">(</span><span class="mi">4000</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">                <span class="n">mvd_ctx</span> <span class="o">=</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">0</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">1</span>
</span><span class="line">                        <span class="o">:</span> <span class="n">mvd</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="o">*</span><span class="n">denom</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="n">i_me_range</span> <span class="o">=</span> <span class="n">i_me_range</span> <span class="o">*</span> <span class="n">range_mul</span><span class="p">[</span><span class="n">mvd_ctx</span><span class="p">][</span><span class="n">sad_ctx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* FIXME if the above DIA2/OCT2/CROSS found a new mv, it has not updated omx/omy.</span>
</span><span class="line"><span class="cm">             * we are still centered on the same place as the DIA2. is this desirable? */</span>
</span><span class="line">            <span class="n">CROSS</span><span class="p">(</span> <span class="n">cross_start</span><span class="p">,</span> <span class="n">i_me_range</span><span class="p">,</span> <span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">1</span> <span class="p">);</span> <span class="c1">//4. 非对称交叉搜索, an uneven cross search</span>
</span><span class="line">
</span><span class="line">            <span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="mi">2</span> <span class="p">);</span> <span class="c1">//5. 5x5 search</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/* hexagon grid */</span>
</span><span class="line">            <span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">p_cost_omvx</span> <span class="o">=</span> <span class="n">p_cost_mvx</span> <span class="o">+</span> <span class="n">omx</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">p_cost_omvy</span> <span class="o">=</span> <span class="n">p_cost_mvy</span> <span class="o">+</span> <span class="n">omy</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">            <span class="k">do</span>
</span><span class="line">            <span class="p">{</span>
</span><span class="line">                <span class="k">static</span> <span class="k">const</span> <span class="kt">int8_t</span> <span class="n">hex4</span><span class="p">[</span><span class="mi">16</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">//5. 多六边形网格搜索, multi-hexagon-grid search</span>
</span><span class="line">                    <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
</span><span class="line">                    <span class="p">{</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span><span class="line">                <span class="p">};</span>
</span><span class="line">
</span><span class="line">                <span class="k">if</span><span class="p">(</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">X264_MIN4</span><span class="p">(</span> <span class="n">mv_x_max</span><span class="o">-</span><span class="n">omx</span><span class="p">,</span> <span class="n">omx</span><span class="o">-</span><span class="n">mv_x_min</span><span class="p">,</span>
</span><span class="line">                                     <span class="n">mv_y_max</span><span class="o">-</span><span class="n">omy</span><span class="p">,</span> <span class="n">omy</span><span class="o">-</span><span class="n">mv_y_min</span> <span class="p">)</span> <span class="p">)</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="kt">int</span> <span class="n">mx</span> <span class="o">=</span> <span class="n">omx</span> <span class="o">+</span> <span class="n">hex4</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">                        <span class="kt">int</span> <span class="n">my</span> <span class="o">=</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">hex4</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">                        <span class="k">if</span><span class="p">(</span> <span class="n">CHECK_MVRANGE</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">)</span> <span class="p">)</span>
</span><span class="line">                            <span class="n">COST_MV</span><span class="p">(</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="p">);</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="k">else</span>
</span><span class="line">                <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                    <span class="n">pixel</span> <span class="o">*</span><span class="n">pix_base</span> <span class="o">=</span> <span class="n">p_fref_w</span> <span class="o">+</span> <span class="n">omx</span> <span class="o">+</span> <span class="p">(</span><span class="n">omy</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">stride</span><span class="p">;</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">stride</span><span class="p">;</span>
</span><span class="line"><span class="cp">#define SADS(k,x0,y0,x1,y1,x2,y2,x3,y3)\</span>
</span><span class="line"><span class="cp">                    h-&gt;pixf.fpelcmp_x4[i_pixel]( p_fenc,\</span>
</span><span class="line"><span class="cp">                            pix_base x0*i+(y0-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x1*i+(y1-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x2*i+(y2-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            pix_base x3*i+(y3-2*k+4)*dy,\</span>
</span><span class="line"><span class="cp">                            stride, costs+4*k );\</span>
</span><span class="line"><span class="cp">                    pix_base += 2*dy;</span>
</span><span class="line"><span class="cp">#define ADD_MVCOST(k,x,y) costs[k] += p_cost_omvx[x*4*i] + p_cost_omvy[y*4*i]</span>
</span><span class="line"><span class="cp">#define MIN_MV(k,x,y)     COPY2_IF_LT( bcost, costs[k], dir, x*16+(y&amp;15) )</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">+</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">SADS</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">+</span><span class="mi">4</span><span class="p">,</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="o">+</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">ADD_MVCOST</span><span class="p">(</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line">                    <span class="n">MIN_MV</span><span class="p">(</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class="line"><span class="cp">#undef SADS</span>
</span><span class="line"><span class="cp">#undef ADD_MVCOST</span>
</span><span class="line"><span class="cp">#undef MIN_MV</span>
</span><span class="line">                    <span class="k">if</span><span class="p">(</span> <span class="n">dir</span> <span class="p">)</span>
</span><span class="line">                    <span class="p">{</span>
</span><span class="line">                        <span class="n">bmx</span> <span class="o">=</span> <span class="n">omx</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">dir</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">);</span>
</span><span class="line">                        <span class="n">bmy</span> <span class="o">=</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="p">((</span><span class="n">dir</span><span class="o">&lt;&lt;</span><span class="mi">28</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">28</span><span class="p">);</span>
</span><span class="line">                    <span class="p">}</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">            <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">++</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">i_me_range</span><span class="o">&gt;&gt;</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span> <span class="n">bmy</span> <span class="o">&lt;=</span> <span class="n">mv_y_max</span> <span class="o">&amp;&amp;</span> <span class="n">bmy</span> <span class="o">&gt;=</span> <span class="n">mv_y_min</span> <span class="o">&amp;&amp;</span> <span class="n">bmx</span> <span class="o">&lt;=</span> <span class="n">mv_x_max</span> <span class="o">&amp;&amp;</span> <span class="n">bmx</span> <span class="o">&gt;=</span> <span class="n">mv_x_min</span> <span class="p">)</span>
</span><span class="line">                <span class="k">goto</span> <span class="n">me_hex2</span><span class="p">;</span>   <span class="c1">//6. iterative hexagon search</span>
</span><span class="line">            <span class="k">break</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="umh-the-proposed-algorithm-for-umh">UMH 优化思路(The Proposed Algorithm For UMH)</h3>

<p>由于视频帧间具有时间相关性，大多数视频序列，当前宏块的方向与上一帧中相同位置宏块的方向高度相关。这意味着连续帧间，运动矢量有高度一致性。因此，当前宏块的运动方向可以通过之前帧对应坐标的方向来预测。基于运动方向预测，不同形状的搜索模式应用到 UMH 搜索模式。目标就是提升估计的运行时间，同时获得相同的质量。</p>

<p>方向可以通过运动矢量的角度来度量，可以使用如下公式：arcsin(-y / sqrt(x^2 + y^2)) * 180 / π 。</p>

<p>下面提出的算法使用上一帧中相同坐标块的运动矢量动态设置搜索非对称搜索模式的搜索长度，决定多六边形网格搜索的四分之一模式。同时，它根据上一步的方向来设计迭代六边形搜索模式。</p>

<h4 id="search-range-decision-for-uneven-cross-pattern">Search Range Decision for Uneven Cross Pattern</h4>

<p>在大多数视频序列中，水平方向上的运动要比垂直方向上的运动更加剧烈。正如上面提到的非对称交叉搜索中，水平方向上的长度是垂直方向上的长度的两倍。</p>

<p>在某些特殊的视频序列中，垂直方向上的运动比水平方向上的运动更加剧烈。因此我们可以动态的设置非对称交叉搜索模式的长度，来确保运动估计的质量。</p>

<p>基于连续帧的相关性，我们可以使用上一帧中相同坐标块的 MV（pmv）来预测当前块的的运动矢量，并且设置非对称交叉搜索模式的长度。如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">if (pmv.dx &gt; 2 * pmv.dy)
</span><span class="line">    PATTERN_SEARCH(CROSS1, 21, 1) //an uneven cross search: search length in vertical direction is 15 and in horizontal direction is 7.
</span><span class="line">else if (pmv.dy &gt; 2 * pmv.dx)
</span><span class="line">    PATTERN_SEARCH(CROSS2, 21, 1) //an uneven cross search: search length in vertical direction is 7 and in horizontal direction is 15.
</span><span class="line">else
</span><span class="line">    PATTERN_SEARCH(CROSS3, 21, 1) //an uneven cross search: search length in vertical direction is the same as in horizontal direction.</span></code></pre></td></tr></table></div></figure>

<h4 id="optimize-for-multi-hexagon-grid-search">Optimize for Multi-hexagon-grid Search</h4>

<p>多六边形网格搜索包括两部分：5x5 搜索和多六边形网格搜索。</p>

<p>大多数真实世界的视频序列都有中心偏移运动矢量分布。有超过 80% 的运动矢量在 5x5 区域的预测内，而有 70% 的运动矢量在 3x3 区域的预测内。尽管 5x5 的区域，比 3x3 的区域有更高(10%)的预测概率,但是搜索点的数量是它的 3 倍之多。因此我们选择 3x3 搜索而不是 5x5 搜索。</p>

<p>x264 中已经对 5x5 全搜索做了优化，甚至比上面提到的优化，还要更加彻底，x264 中关于 5x5 的全搜索，仅检查 4 个搜索点。它的代码更新迭代过程如下：</p>

<figure class="code"><figcaption><span>5x5_ESA </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/*5x5 ESA method 1*/</span>
</span><span class="line"><span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">==</span> <span class="n">ucost2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">square2</span><span class="p">[</span><span class="mi">24</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">        <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">    <span class="n">COST_MV</span><span class="p">(</span><span class="n">omx</span> <span class="o">+</span> <span class="n">square2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">omy</span> <span class="o">+</span> <span class="n">square2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line">
</span><span class="line"><span class="cm">/*5x5 ESA method 2*/</span>
</span><span class="line"><span class="n">omx</span> <span class="o">=</span> <span class="n">bmx</span><span class="p">;</span> <span class="n">omy</span> <span class="o">=</span> <span class="n">bmy</span><span class="p">;</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">bcost</span> <span class="o">!=</span> <span class="n">ucost2</span><span class="p">)</span>
</span><span class="line">    <span class="n">COST_MV_X4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line"><span class="n">COST_MV_X4</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="c1">///////////////////////////</span>
</span><span class="line"><span class="cm">/*optimize 5x5 ESA method 3*/</span>
</span><span class="line"><span class="n">COST_MV_x4</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>第二部分是多六边形网格搜索，它有 64 个点需要检查。在此步骤中，我们根据当前宏块的运动方向预测，设计了 4 种模式，它有 20 个搜索点需要检查，这回极大的降低计算复杂度。算法描述如下：</p>

<p><img src="http://lazybing.github.io/images/h264_me/multi_hexagon_grid.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<p>计算 pmv(x, y)的角度α：</p>

<p>a) 如果 α = 0-90，寻找 20 个搜索点，如图3(b),并找到新的 MBD，之后处理第 6 步<br />
b) 如果 α = 90-180，寻找 20 个搜索点，如图3(c),并找到新的 MBD，之后处理第 6 步<br />
c) 如果 α = 180-270，寻找 20 个搜索点，如图3(d),并找到新的 MBD，之后处理第 6 步<br />
d) 如果 α = -90-0，寻找 20 个搜索点，如图3(e),并找到新的 MBD，之后处理第 6 步</p>

<p>x264 中并没有进行此项优化，此处可能有一个搜索优化空间。</p>

<h4 id="optimize-for-iterative-hexagon-search">Optimize for Iterative Hexagon Search</h4>

<p>第六步是迭代六边形搜索模式，设置第五步中的 MBD 点作为搜索中心，最开始有 7 个点需要检查。然后在搜索过程中，六边形搜索不断前进，中心移动到六个端点中的任何一个。每次总是有三个新的点出现，而其他三个点是重复的。该算法根据前一步的方向设计新的六边形图案，避免了重复搜索冗余点。对第 6 步的优化过程如下：</p>

<p><img src="http://lazybing.github.io/images/h264_me/iterative_hexagon.png" title="'H264 Motion Estimation UMHexagonS Search'" /></p>

<p>步骤6-1：</p>

<p>图4(a) 所示的六边形位于步骤 5 的 MBD 点的中心。如果在本步骤中找到的 MBD 点仍然与在上一步中找到的 MBD 点一致，则转至步骤6-3；否则计算上一步方向的角度，进行下一步处理。</p>

<p>a) 如果 α = 0-90,如图4(b)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
b) 如果 α = 90-180,如图4(c)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
a) 如果 α = 180-270,如图4(d)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。<br />
a) 如果 α = -90-0,如图4(e)所示，搜索四个点；并寻找新的 MBD 点并执行步骤 6-2。</p>

<p>步骤6-2：</p>

<p>以上一步搜索的 MBD 点为中心，形成一个新的六边形。检查三个新的候选点，再次确定 MBD 点。如果 MBD 仍然与上一步中发现的 MBD 点重合，则转至步骤6-3；否则，如果 4 所示重复此步骤。</p>

<p>步骤6-3：</p>

<p>将搜索模式从六边形切换到小尺寸的六边形搜索。将检查基于角度评估的两个候选点。先的 MBD 点是运动矢量的最终解。</p>

<p>图 4(f) 显示了该方法的一个例子。</p>

<p>X264 中已经采用了此种优化方法，实现代码就是上一种的 X264_ME_HEX 代码。</p>

<h1 id="section-1">分数像素运动估计</h1>

<h2 id="section-2">亚像素搜索算法</h2>

<p>当整数像素搜索算法优化完毕后，亚像素搜索算法的时间占比就会提升，此时对亚像素搜索算法的优化，就不能忽视了。</p>

<H.264 标准="">中规定，运动估计为1/4像素精度，因此在 H.264 编码和解码的过程中，需要将画面中的像素进行插值——简单地说就是把原先的 1 个像素点拓展成 4x4 一共 16 个点。

下图显示了  H.264 编码和解码过程中像素插值情况。可以看出原先的 G 点的右下方通过插值的方式产生了 a、b、c、d 等一共 16 个点。  

<img src="http://lazybing.github.io/images/h264_me/Interpolation_of_luma_half-pel.PNG" title="'H264 Motion Estimation UMHexagonS Search'" />    

如图所示，1/4 像素内插一般分成两成：1. 半像素内插。这一步通过 6 抽头滤波器获得 5 个半像素点。2. 线性内插。这一步通过简单的线性内插获得剩余的 1/4 像素点。   

<img src="http://lazybing.github.io/images/h264_me/Interpolation_of_luma_quanter-pel.PNG" title="'H264 Motion Estimation UMHexagonS Search'" />   

图中半像素内插点为 b、m、h、s、j五个点。半像素内插方法是对整像素点进行 6 抽头滤波得到，滤波器的权重为(1/32, -5/32, 5/8, 5/8, -5/32, 1/32)。例如 b 的计算公式为： `b = round((E - 5F + 20G + 20H - 5I + J)/32)`。  

剩下几个半像素点的计算关系如下：

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">m: 由 B、D、H、N、S、U计算  
</span><span class="line">h：由A、C、G、M、R、T计算  
</span><span class="line">s：由K、L、M、N、P、Q计算  
</span><span class="line">j：由cc、dd、h、m、ee、ff计算。 
</span><span class="line">需要注意j点的运算量比较大，因为cc、dd、ee、ff都需要通过半像素内插方法进行计算。</span></code></pre></td></tr></table></div></figure>
在获得半像素点之后，就可以通过简单的线性内插获得 1/4 像素内插点了。1/4 像素内插的方式如下图所示。例如图中 a 点的计算公式如下： `A = round((G + b) / 2)`

在这里有一点需要注意： 位于 4 个角的 e、g、p、r 四个点并不是通过j 点计算的，而是通过b、h、s、m四个半像素点计算的。


</H.264>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[H264 Fast Mode Decision Algorithm]]></title>
    <link href="http://lazybing.github.io/blog/2021/04/25/h264-fast-mode-decision-algorithm/"/>
    <updated>2021-04-25T17:04:16-07:00</updated>
    <id>http://lazybing.github.io/blog/2021/04/25/h264-fast-mode-decision-algorithm</id>
    <content type="html"><![CDATA[<p>在编码器中，模式选择是耗时较多的一个模块，因此一个好的快速模式选择算法，是非常有必要的。好的快速模式选择，不仅能够降低编码资源消耗，还能保证编码质量不降低。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacking VMAF With Video Color and Contrast Distortion]]></title>
    <link href="http://lazybing.github.io/blog/2020/06/30/hack-vmaf/"/>
    <updated>2020-06-30T04:57:24-07:00</updated>
    <id>http://lazybing.github.io/blog/2020/06/30/hack-vmaf</id>
    <content type="html"><![CDATA[
<p>视频质量测量在许多应用中占有重要的地位。全参考质量指标(通常被用在视频编解码比较中)将反映视频中的任何变换。在这篇文章中，我们考虑经过不同颜色校正的压缩视频，它会增加全参考度量 VMAF，同时，几乎不减少其他广泛使用的度量 SSIM。所提出的视频对比度增强方法显示了该度量在某些情况下，对视频编解码器比较的适用性，因为它可以通过调整来改进该度量值，从而在比较中作弊。</p>

<p><strong>关键字</strong>：<strong>视频质量</strong>、<strong>质量度量</strong>、<strong>视频编解码压缩</strong>、<strong>质量调节</strong>、<strong>参考特征</strong>、<strong>颜色校正</strong></p>

<!--more-->

<p>未完待续</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序链接(Program Linking)]]></title>
    <link href="http://lazybing.github.io/blog/2020/06/25/program-linking/"/>
    <updated>2020-06-25T15:22:39-07:00</updated>
    <id>http://lazybing.github.io/blog/2020/06/25/program-linking</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">链接示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">静态链接</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">目标文件</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">可重定位目标文件</a>    <ul>
      <li><a href="#section-4" id="markdown-toc-section-4">符号和符号表</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">符号解析</a>        <ul>
          <li><a href="#section-6" id="markdown-toc-section-6">链接器如何解析多重定义的全局符号</a></li>
          <li><a href="#section-7" id="markdown-toc-section-7">与静态库链接</a></li>
          <li><a href="#section-8" id="markdown-toc-section-8">链接器如何使用静态库来解析引用</a></li>
        </ul>
      </li>
      <li><a href="#section-9" id="markdown-toc-section-9">重定位</a>        <ul>
          <li><a href="#section-10" id="markdown-toc-section-10">重定位条目</a></li>
          <li><a href="#section-11" id="markdown-toc-section-11">重定位符号引用</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-12" id="markdown-toc-section-12">可执行目标文件</a></li>
  <li><a href="#section-13" id="markdown-toc-section-13">共享目标文件</a></li>
  <li><a href="#section-14" id="markdown-toc-section-14">处理目标文件的工具</a></li>
</ul>

<p><strong>链接</strong>是将各种代码和数据片段收集并组合成一个单一文件的过程，该文件可以被加载到内存并执行。理解链接的几个好处有：</p>

<!--more-->

<ul>
  <li>理解链接器将帮助你构造大型程序。</li>
  <li>理解链接器将帮助你避免一些危险的编程错误。</li>
  <li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
  <li>理解链接器将帮助你理解其他重要的系统概念。</li>
  <li>理解链接器将使你能够利用共享库</li>
</ul>

<p>下面会介绍静态链接、加载时的共享库的动态链接、运行时的共享库动态链接等方面。</p>

<h2 id="section">链接示例</h2>

<p>通常说的编译程序包括如下四个方面：预处理(cpp)、编译(ccl)、汇编(as)、链接(ld)。比如，有如下 main.c 和 sum.c 两个文件。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int sum(int *a, int n);
</span><span class="line">
</span><span class="line">int array[2] = {1, 2};
</span><span class="line">
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    int val = sum(array, 2);
</span><span class="line">    return val;
</span><span class="line">}
</span><span class="line">
</span><span class="line">int sum(int *a, int n)
</span><span class="line">{
</span><span class="line">    int i, s = 0;
</span><span class="line">    
</span><span class="line">    for (i = 0; i &lt; n; i++) {
</span><span class="line">        s += a[i];
</span><span class="line">    }
</span><span class="line">    
</span><span class="line">    return s;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>编译命令：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc -Og -o prog main.c sum.c 或
</span><span class="line">$gcc -Og -v -o prog main.c sum.c</span></code></pre></td></tr></table></div></figure>

<p>对上面的源文件进行如下操作:</p>

<p>main.c—&gt;预处理(cpp)—&gt;main.i—&gt;编译器(ccl)—&gt;main.s—&gt;汇编器(as)—&gt;main.o<br />
sum.c—-&gt;预处理(cpp)—&gt;sum.i—-&gt;编译器(ccl)—&gt;sum.s—-&gt;汇编器(as)—&gt;sum.o<br />
main.o + sum.o—&gt;链接器(ld)—&gt;prog</p>

<h2 id="section-1">静态链接</h2>

<p>静态链接以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行可执行目标文件作为输出。</p>

<p>为构造可执行文件，链接器主要完成两项任务：</p>

<ul>
  <li><strong>符号解析。</strong> 符号解析的目的是使得目标文件中符号的定义和引用匹配起来。例如引用一个函数名符号时，符号解析的功能就是找到函数的引用和定义，并将其匹配起来。</li>
  <li><strong>重定位。</strong> 由编译器和汇编器生成的 .code 和 .data 节，都是从地址 0 开始的。链接器通过将每个符号定义为一个与内存关联起来，完成重定位，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
</pre></td><td class="code"><pre><code class=""><span class="line">main.o:     file format elf64-x86-64
</span><span class="line">Disassembly of section .text:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;main&gt;:
</span><span class="line">   0:	55                   	push   %rbp
</span><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp
</span><span class="line">   4:	48 83 ec 10          	sub    $0x10,%rsp
</span><span class="line">   8:	be 02 00 00 00       	mov    $0x2,%esi
</span><span class="line">   d:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 14 &lt;main+0x14&gt;
</span><span class="line">  14:	e8 00 00 00 00       	callq  19 &lt;main+0x19&gt;
</span><span class="line">  19:	89 45 fc             	mov    %eax,-0x4(%rbp)
</span><span class="line">  1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
</span><span class="line">  1f:	c9                   	leaveq 
</span><span class="line">  20:	c3                   	retq   
</span><span class="line">  
</span><span class="line">sum.o:     file format elf64-x86-64
</span><span class="line">
</span><span class="line">Disassembly of section .text:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;sum&gt;:
</span><span class="line">   0:	55                   	push   %rbp
</span><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp
</span><span class="line">   4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
</span><span class="line">   8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
</span><span class="line">   b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
</span><span class="line">  12:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
</span><span class="line">  19:	eb 1d                	jmp    38 &lt;sum+0x38&gt;
</span><span class="line">  1b:	8b 45 f8             	mov    -0x8(%rbp),%eax
</span><span class="line">  1e:	48 98                	cltq   
</span><span class="line">  20:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
</span><span class="line">  27:	00 
</span><span class="line">  28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
</span><span class="line">  2c:	48 01 d0             	add    %rdx,%rax
</span><span class="line">  2f:	8b 00                	mov    (%rax),%eax
</span><span class="line">  31:	01 45 fc             	add    %eax,-0x4(%rbp)
</span><span class="line">  34:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
</span><span class="line">  38:	8b 45 f8             	mov    -0x8(%rbp),%eax
</span><span class="line">  3b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
</span><span class="line">  3e:	7c db                	jl     1b &lt;sum+0x1b&gt;
</span><span class="line">  40:	8b 45 fc             	mov    -0x4(%rbp),%eax
</span><span class="line">  43:	5d                   	pop    %rbp
</span><span class="line">  44:	c3                   	retq</span></code></pre></td></tr></table></div></figure>

<p>上面 text section 是 main.o 和 sum.o 反编译出来的，可以看出，main 函数和 sum 函数都是从地址 0 开始的。将 main.o 和 sum.o 链接生成 prog 可执行文件，反编译可执行文件后，部分 section 如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">00000000000005fa &lt;main&gt;:
</span><span class="line"> 5fa:	48 83 ec 08          	sub    $0x8,%rsp
</span><span class="line"> 5fe:	be 02 00 00 00       	mov    $0x2,%esi
</span><span class="line"> 603:	48 8d 3d 06 0a 20 00 	lea    0x200a06(%rip),%rdi        # 201010 &lt;array&gt;
</span><span class="line"> 60a:	e8 05 00 00 00       	callq  614 &lt;sum&gt;
</span><span class="line"> 60f:	48 83 c4 08          	add    $0x8,%rsp
</span><span class="line"> 613:	c3                   	retq   
</span><span class="line">
</span><span class="line">0000000000000614 &lt;sum&gt;:
</span><span class="line"> 614:	b8 00 00 00 00       	mov    $0x0,%eax
</span><span class="line"> 619:	ba 00 00 00 00       	mov    $0x0,%edx
</span><span class="line"> 61e:	eb 09                	jmp    629 &lt;sum+0x15&gt;
</span><span class="line"> 620:	48 63 ca             	movslq %edx,%rcx
</span><span class="line"> 623:	03 04 8f             	add    (%rdi,%rcx,4),%eax
</span><span class="line"> 626:	83 c2 01             	add    $0x1,%edx
</span><span class="line"> 629:	39 f2                	cmp    %esi,%edx
</span><span class="line"> 62b:	7c f3                	jl     620 &lt;sum+0xc&gt;
</span><span class="line"> 62d:	f3 c3                	repz retq 
</span><span class="line"> 62f:	90                   	nop</span></code></pre></td></tr></table></div></figure>

<p>从上面可以看出，可执行文件中的 main 和 sum 的地址已经不再是 0， main 中调用了 sum 的地址为 614,切好就是 sum 的地址。</p>

<h2 id="section-2">目标文件</h2>

<p>目标文件有三种形式：可重定位的目标文件、可执行的目标文件、共享目标文件。</p>

<ul>
  <li><strong>可重定位的目标文件</strong> 是包含二进制代码的数据，其可以在编译时与其他可重定位目标文件结合生成可执行文件。</li>
  <li><strong>可执行目标文件</strong> 包含二进制代码和数据，可直接复制到内存中执行。</li>
  <li><strong>共享目标文件</strong> 特殊的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。</li>
</ul>

<h2 id="section-3">可重定位目标文件</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">ELF 头</th>
      <th style="text-align: center">描述生成该文件的系统的字的大小和字节顺序，以及包含帮助链接器语法分析和解释目标文件的信息</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">.text</td>
      <td style="text-align: center">已编译程序的机器代码</td>
    </tr>
    <tr>
      <td style="text-align: center">.rodata</td>
      <td style="text-align: center">只读数据，比如 printf 中的字符串</td>
    </tr>
    <tr>
      <td style="text-align: center">.data</td>
      <td style="text-align: center">已初始化的全局和静态 C 变量</td>
    </tr>
    <tr>
      <td style="text-align: center">.bss</td>
      <td style="text-align: center">未初始化的全局和静态 C 变量, 以及所有被初始化为 0 的全局或静态变量</td>
    </tr>
    <tr>
      <td style="text-align: center">.symtab</td>
      <td style="text-align: center">一个符号表，它存放在程序中定义和引用的函数和全局变量的信息</td>
    </tr>
    <tr>
      <td style="text-align: center">.rel.text</td>
      <td style="text-align: center">一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置</td>
    </tr>
    <tr>
      <td style="text-align: center">.rel.data</td>
      <td style="text-align: center">被模块引用或定义的所有全局变量的重定位信息</td>
    </tr>
    <tr>
      <td style="text-align: center">.debug</td>
      <td style="text-align: center">调试符号表，与上面的 symtab 不同，它还包含了局部变量和类型定义，以及原始的 C 源文件</td>
    </tr>
    <tr>
      <td style="text-align: center">.line</td>
      <td style="text-align: center">原始 C 源程序中的行号和 .text 节中机器指令之间的映射</td>
    </tr>
    <tr>
      <td style="text-align: center">.strtab</td>
      <td style="text-align: center">一个字符串表，包括 .symtab 和 .debug 节中的符号表</td>
    </tr>
    <tr>
      <td style="text-align: center">节点头部</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>给出一个程序示例 obj.c：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;stdio.h&gt;
</span><span class="line">
</span><span class="line">int AAA = 3;
</span><span class="line">
</span><span class="line">int sum(int a, int b)
</span><span class="line">{
</span><span class="line">    return a + b;
</span><span class="line">}
</span><span class="line">
</span><span class="line">int main(int argc, char **argv)
</span><span class="line">{
</span><span class="line">    int a = 0;
</span><span class="line">    int b = 1;
</span><span class="line">    int c;
</span><span class="line">
</span><span class="line">    static int aa = 0;
</span><span class="line">    static int bb = 1;
</span><span class="line">    static int cc;
</span><span class="line">
</span><span class="line">    printf("a %d aa %d b %d bb %d c %d cc %d AAA %d\n", a, aa, b, bb, c, cc, AAA);
</span><span class="line">    c = sum(AAA, AAA);
</span><span class="line">
</span><span class="line">    return 0;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>编译该文件 obj.c ：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -g -c obj.c
</span><span class="line">$ objdump -D obj.o &gt; obj.txt</span></code></pre></td></tr></table></div></figure>

<p>反编译生成的可重定位目标文件，下面给出几部分</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Disassembly of section .data:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;AAA&gt;:
</span><span class="line">   0:	03 00                	add    (%rax),%eax
</span><span class="line">	...
</span><span class="line">
</span><span class="line">0000000000000004 &lt;bb.2260&gt;:
</span><span class="line">   4:	01 00                	add    %eax,(%rax)
</span><span class="line">	...
</span><span class="line">
</span><span class="line">Disassembly of section .bss:
</span><span class="line">
</span><span class="line">0000000000000000 &lt;cc.2261&gt;:
</span><span class="line">   0:	00 00                	add    %al,(%rax)
</span><span class="line">	...
</span><span class="line">
</span><span class="line">0000000000000004 &lt;aa.2259&gt;:
</span><span class="line">   4:	00 00                	add    %al,(%rax)
</span><span class="line">	...</span></code></pre></td></tr></table></div></figure>

<p>可以看出，<code>.data</code> 包含了已初始化的全局变量 AAA、和静态变量 bb。<code>.bss</code>包含了未初始化的静态变量 cc 和初始化为零的静态变量 aa。但要注意，对于局部的变量 a、b、c并没有出现在上面的几个节中，因为局部变量在运行时被保护在栈中，既不出现在<code>.data</code>节中，也不出现在<code>.bss</code> 中。</p>

<h3 id="section-4">符号和符号表</h3>

<p>对于一个可重定位的模块 m 来说，它包含的定义和引用的符号，包含三种类型：
* 由模块 m 定义并能被其他模块引用的全局符号。
* 由其他模块定义并被模块 m 引用的全局符号。
* 只被模块 m 定义和引用的局部符号。</p>

<p>注意，链接器符号和程序变量是不同的，.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号，非静态程序变量符号在运行时在栈中管理，链接器对此类符号不感兴趣，（但带有static 属性的变量除外）。</p>

<p>下面给出符号表的一个示例 m.o 和 swap.o：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void swap();
</span><span class="line">
</span><span class="line">int buf[2] = {1, 2};
</span><span class="line">
</span><span class="line">int main()
</span><span class="line">{
</span><span class="line">    sawp();
</span><span class="line">    return 0;
</span><span class="line">}
</span><span class="line">
</span><span class="line">
</span><span class="line">extern int buf[];
</span><span class="line">
</span><span class="line">int *bufp0 = &amp;buf[0];
</span><span class="line">int *bufp1;
</span><span class="line">
</span><span class="line">void swap()
</span><span class="line">{
</span><span class="line">    int temp;
</span><span class="line">
</span><span class="line">    bufp1 = &amp;buf[1];
</span><span class="line">    temp  = *bufp0;
</span><span class="line">    *bufp0 = *bufp1;
</span><span class="line">    *bufp1 = temp;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>使用 readelf 工具对 swap.o 查看符号表如下:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Symbol table '.symtab' contains 13 entries:
</span><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
</span><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS swap.c
</span><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
</span><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
</span><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
</span><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
</span><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 
</span><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 
</span><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
</span><span class="line">     9: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    5 bufp0
</span><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND buf
</span><span class="line">    11: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM bufp1
</span><span class="line">    12: 0000000000000000    63 FUNC    GLOBAL DEFAULT    1 swap</span></code></pre></td></tr></table></div></figure>

<p>从上面可以看出几个符号的解析如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">符号</th>
      <th style="text-align: center">.symtab 条目</th>
      <th style="text-align: center">符号类型</th>
      <th style="text-align: center">所属模块</th>
      <th style="text-align: center">节</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">buf</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">extern</td>
      <td style="text-align: center">m.o</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">bufp0</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">bufp1</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.common</td>
    </tr>
    <tr>
      <td style="text-align: center">swap</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">GLOBAL</td>
      <td style="text-align: center">swap.o</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">temp</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
  </tbody>
</table>

<h3 id="section-5">符号解析</h3>

<p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对全局符号的解析，如果多个目标文件中定义相同名字的全局符号，链接器要么给出错误提示，要么以某种方法选出一个定义并抛弃其他定义。</p>

<h4 id="section-6">链接器如何解析多重定义的全局符号</h4>

<p>编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。链接规则如下：
* 不允许有多个同名的强符号。
* 如果有一个强符号和多个弱符号同名，选择强符号。
* 如果有多个弱符号同名，从中任选一个。</p>

<h4 id="section-7">与静态库链接</h4>

<p>静态库，将所有相关的目标文件模块打包成一个单独的文件，该文件可以作为链接器的输入，当链接器构造一个输出的可执行文件时，链接器只会复制该文件中被应用程序引用的目标模块，这样的文件称为静态库。</p>

<h4 id="section-8">链接器如何使用静态库来解析引用</h4>

<p>解析阶段，链接器<strong>从左到右(有序的)</strong>按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。链接器会维护三个集合：可重定位目标文件集合E、未解析的符号集合U、已定义的符号集合D。链接器的解析过程如下:</p>

<ul>
  <li>对命令行上的每个输入文件 f，链接器判断是否为目标文件或静态库，如果是目标文件，将其添加到E，修改U 和 D，继续解析下一个文件。</li>
  <li>如果 f 是静态库，链接器尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。匹配成功，将模块添加到E 中，修改 U 和 D。</li>
  <li>链接器扫描完输入文件后，U 非空，链接器输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，生成可执行文件。</li>
</ul>

<p>从链接器解析静态库的原理可以看出，编译时，静态库存放的位置很重要，同样的目标文件和静态库，位置不同，可能编译结果就不同了。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$gcc -static ./libvector.a main.c
</span><span class="line">$gcc -static main.c ./libvector.a</span></code></pre></td></tr></table></div></figure>

<h3 id="section-9">重定位</h3>

<p>链接器完成符号解析后，就把代码中的每个符号和定义关联起来了。现在链接器就可以重定位了，重定位由两步组成：</p>

<ul>
  <li>重定位节和符号定义。链接器将所有相同类型的 section 合并成一个新的 section。比如，将所有模块的 .data 合并成一个新的 .data。之后将运行时的内存地址赋给新的 section 以及每个模块的定义。</li>
  <li>重定位节中的符号引用。链接器修改 .data 和 .text 中对每个符号的引用，使得它们指向正确的运行时地址。</li>
</ul>

<h4 id="section-10">重定位条目</h4>

<p>汇编器遇到对最终位置未知的目标引用，会生成一个重定位条目，告知链接器在将目标文件合并成可执行文件时如何修改该引用。代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中.</p>

<p>重定位类型有 32 种，最常用的两种是:</p>

<ul>
  <li><strong>R_X86_64_P32</strong>，重定位一个使用 32 位 PC  相对地址的引用。比如调用函数常用的 call 指令</li>
  <li><strong>R_X86_64_32</strong>，重定位一个使用 32 位绝对地址的引用</li>
</ul>

<h4 id="section-11">重定位符号引用</h4>
<p>链接器的重定位算法的伪代码如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">foreach section s {
</span><span class="line">    foreach relocation entry r {
</span><span class="line">        refptr = s + r.offset;  /*ptr to reference to be relocated*/
</span><span class="line">        
</span><span class="line">        /* Relocate a PC-relative reference */
</span><span class="line">        if (r.type == R_X86_64_PC32) {
</span><span class="line">            refaddr = ADDR(s) + r.offset; /* ref's run-time address */
</span><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr);
</span><span class="line">        }
</span><span class="line">        
</span><span class="line">        /* Relocate an absolute reference */
</span><span class="line">        if (r.type == R_X86_64_32) {
</span><span class="line">            *refptr = (unsigned)(ADDR(r.symbol) + r.addend);
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h2 id="section-12">可执行目标文件</h2>

<p>可执行目标文件格式类似于可重定位的目标文件格式，稍有不同的是：可执行目标文件有程序的入口点（程序运行时要执行的第一条指令地址）、<code>.text/.rodata/.data</code>节已经被重定位到它们最终运行时内存地址、可执行文件已经被重定位所以不需要 <code>.rel</code> 节。</p>

<p>加载器会将可执行目标文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的第一条指令或入口点来运行该程序。</p>

<h2 id="section-13">共享目标文件</h2>

<p>静态库需要定期维护和更新，静态库的代码被复制到每个运行进程的文本段中，会极大的浪费内存系统资源。共享库可以解决静态库的问题，共享库是一个目标模块，在运行和加载时，可加载到任意的内存地址，并和内存中的程序连接起来。</p>

<p>动态加载和链接共享库:Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#include &lt;dlfcn.h&gt;
</span><span class="line">void *dlopen(const char *filename, int flag);
</span><span class="line">void *dlsym(void *handle, char *symbol);
</span><span class="line">int dlclose(void *handle);
</span><span class="line">const char *dlerror(void);</span></code></pre></td></tr></table></div></figure>

<p>共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，从而节约宝贵的内存资源。现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用该方法，无限多个进程可以共享一个共享模块的代码段的单一副本。加载而无需重定位的代码称为位置无关吗。</p>

<h2 id="section-14">处理目标文件的工具</h2>
<p>Linux系统中有很多工具可以帮忙处理目标文件。</p>

<ul>
  <li><strong>ar</strong> 创建静态库，插入、删除、列出和提取成员。</li>
  <li><strong>strings</strong> 列出目标文件中所有可打印的字符串。</li>
  <li><strong>strip</strong> 从目标文件中删除符号表信息。</li>
  <li><strong>nm</strong> 列出一个目标文件的符号表中定义的符号。</li>
  <li><strong>size</strong> 列出目标文件中节的名字和大小。</li>
  <li><strong>readelf</strong> 显示目标文件的完整结构。</li>
  <li><strong>objdump</strong> 所有二进制工具之母。能够显示目标文件中所有信息，最大作用是反编译 .text 节中的二进制指令。</li>
  <li><strong>ldd</strong> 列出可执行文件在运行时所需要的共享库。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(八)DAV1D源码优化 Dav1d_optimization]]></title>
    <link href="http://lazybing.github.io/blog/2019/12/22/dav1d-optinization/"/>
    <updated>2019-12-22T09:05:50-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/12/22/dav1d-optinization</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">程序流程</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">算法实现</a>    <ul>
      <li><a href="#looprestoration-" id="markdown-toc-looprestoration-">1. 局部性原理用在 LoopRestoration 中。</a></li>
      <li><a href="#film-grain-" id="markdown-toc-film-grain-">2. 局部性原理用在 Film Grain 优化。</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">编程语言</a></li>
</ul>

<p>DAV1D 作为 AV1 最高效的解码器，仍然有可优化的空间，根据自己的理解，可执行的优化方案大概从三个方面实现：程序流程、算法实现、编程语言三个角度进行优化。</p>

<!--more-->

<h2 id="section">程序流程</h2>

<p>DAV1D  解码器的流程如下图所示：
<img src="http://lazybing.github.io/images/dav1d_opt/dav1d_decoder_flow.png" /></p>

<p>从图中可以看出，DAV1D 解码器本身有三个线程，Main Thread、Frame Thread 和 Tile Thread。</p>

<ul>
  <li>Main Thread 主要控制整个解码流程，包括读取数据、Parse Obu Header（Sequence、Frame、Tile）、Film Grain、将AV1 数据给到另外两条 Thread、写数据。</li>
  <li>Tile Thread 主要完成重建帧部分，包括read_coef_blocks、recon_b_intra/recon_b_inter、itxfm_add。</li>
  <li>Frame Thread 主要完成滤波部分，是在一帧内，所有的Tile 解码完成后，Loop Filter、CDEF Filter、LoopRestoration Filter。</li>
</ul>

<p>分析上面的流程可以看出 Film Grain 部分，属于后处理部分，不会影响到其他帧的解码，因此，可以将 Film Grain 部分单独创建一个 Thread 来实现。这条优化肯定是可以实现的，只是代码库中还没有实现。</p>

<p>另外，Frame Thread 主要包括三种滤波：Loop Filter 、CDEF Filter、LoopRestoration Filter 三种，而且是顺序执行，因此可以考虑将这三种滤波，用不同的 Thread 实现。</p>

<h2 id="section-1">算法实现</h2>

<h3 id="looprestoration-">1. 局部性原理用在 LoopRestoration 中。</h3>

<p>LoopRestoration_tmpl.c 中，维纳滤波的实现有如下一段代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int j = 0; j &lt; w; j++) {
</span><span class="line">    for (int i = 0; i &lt; h; i++) {
</span><span class="line">        int sum = (hor[(j + 3) * REST_UNIT_STRIDE + i] &lt;&lt; 7) - round_offset;
</span><span class="line">
</span><span class="line">        for (int k = 0; k &lt; 7; k++) {
</span><span class="line">            sum += hor[(j + k) * REST_UNIT_STRIDE + i] * filterv[k];
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        p[j * PXSTRIDE(p_stride) + i] = 
</span><span class="line">            iclip_pixel((sum + rounding_off_v) &gt;&gt; round_bits_v);
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>上面的实现是按照列实现完成的，其实硬件的存储结构导致，行实现完成效率更高。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int j = 0; j &lt; h; j++) {
</span><span class="line">    for (int i = 0; i &lt; w; i++) {
</span><span class="line">        int sum = (hor[(j + 3) * REST_UNIT_STRIDE + i] &lt;&lt; 7) - round_offset;
</span><span class="line">
</span><span class="line">        for (int k = 0; k &lt; 7; k++) {
</span><span class="line">            sum += hor[(j + k) * REST_UNIT_STRIDE + i] * filterv[k];
</span><span class="line">        }
</span><span class="line">
</span><span class="line">        p[j * PXSTRIDE(p_stride) + i] = 
</span><span class="line">            iclip_pixel((sum + rounding_off_v) &gt;&gt; round_bits_v);
</span><span class="line">    }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h3 id="film-grain-">2. 局部性原理用在 Film Grain 优化。</h3>

<p>Film Grain 的流程主要包括两部分：1. 从 Grain_lut 中获取 grain值。2. 通过获取的 grain 值，执行 add_noise_y。</p>

<p>因为获取 grain 值时，访问的内存是不连续的。此时可以考虑，先将获取的grain 值存起来，放到一块连续的buffer中，之后在执行 add_noise_y 的操作。
实现完上述步骤后，可以利用这种方式继续执行，继续使用 NEON 优化。</p>

<p>测试下来发现，960x540 分辨率，解码模块耗时 8ms，利用局部性原理优化完成后，该模块耗时 7ms，使用NEON优化后，该模块耗时5ms。</p>

<p>这还只是优化了 Y 方向的计算，如果后续优化完成 UV 方向的计算后，效果会更加明显。</p>

<h2 id="section-2">编程语言</h2>

<p>SIMD 指令优化，在编解码中一直起着非常非常重要的作用，这也解释了为什么所有的编解码器，都有 SIMD 指令的优化，可以说，SIMD 指令优化是仅次于线程优化的方案了。
在 DAV1D 最初的版本中，还不支持持 10 bit汇编的情况下，自己手动实现了 LoopFilter、CDEF Filter、LoopRestoration Filter、Film Grain Filter、MC 等模块后，解码效率提升了150%-200%。这还是在没实现 IDXT 模块的前提下。如果将所有能够使用SIMD指令优化的结果，都实现了，预估应该能做到 200%-250% 的解码效率。</p>

<p>绝大多数的 NEON 汇编优化，核心代码都可以简化为如下模式：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for (int i = 0; i &lt; height; i++)
</span><span class="line">    for (int j = 0; j &lt; width; j++)
</span><span class="line">        dst[i * stride + j] = iclip((src1[i][j] * weight1 + src2[i][j] * weight2 + offset) &lt;&lt; shift, min, max);</span></code></pre></td></tr></table></div></figure>
<p>使用 NEON 汇编优化上面的代码实现，假设 src1 的地址在寄存器 x0 中，src2 的地址在寄存器 x2 中。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ld1 {v0.8b, v1.8b}, [x1]
</span><span class="line">ld1 {v2.8b, v2.8b}, [x2]
</span><span class="line">movi v9.8h, #offset
</span><span class="line">movi v12.8h, #shift
</span><span class="line">movi v3.8b, #255
</span><span class="line">movi v4.8b, #128
</span><span class="line">smul v5.8h, v0.8b, v3.8b
</span><span class="line">smul v6.8h, v1.8b, v3.8b
</span><span class="line">smul v7.8h, v2.8b, v4.8b
</span><span class="line">smul v8.8h, v3.8b, v5.8b
</span><span class="line">add  v5.8h, v5.8h, v7.8h
</span><span class="line">add  v6.8h, v6.8h, v8.8h
</span><span class="line">add  v5.8h, v5.8h, v9.8h
</span><span class="line">add  v6.8h, v6.8h, v9.8h
</span><span class="line">ushl v5.8h, v5.8h, v12.8h
</span><span class="line">ushl v6.8h, v6.8h, v12.8h
</span><span class="line">smax v5.8h, v5.8h, v10.8h
</span><span class="line">smax v6.8h, v6.8h, v10.8h
</span><span class="line">smin v5.8h, v5.8h, v11.8h
</span><span class="line">smin v6.8h, v6.8h, v11.8h</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(七)之帧间编码 Inter Predicton]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/20/inter-prediction/"/>
    <updated>2019-11-20T08:04:43-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/20/inter-prediction</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#obmc-" id="markdown-toc-obmc-">OBMC 概述</a></li>
  <li><a href="#warped-motion-" id="markdown-toc-warped-motion-">Warped Motion 概述</a></li>
</ul>

<p>Motion Compensation 在视频编解码中是非常重要的模块。(未完待续)</p>

<!--more-->

<h2 id="obmc-">OBMC 概述</h2>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<p>本文通过学习文献<code>Variable Block-Size Overlapped Block Motion Compensation In The Next Generation Open-Source Video Codec</code>学习 OBMC 算法在 AV1 中的应用，并对应到 DAV1D 源码中的应用。</p>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<p>运动补偿技术通过高效的降低时间冗余，对现代视频压缩工具的成功，有非常大的贡献。主流的视频编解码标准中（AV1/VP9/HEVC/H264），它主要是基于块匹配上。</p>

<h2 id="warped-motion-">Warped Motion 概述</h2>

<p>Warped motion 模型在 AV1 中是通过两个仿射预测模型完成的，全局和局部的 warped 运动补偿。在真实世界中，物体除了简单的平移运动外，还有淡入、淡出、旋转、视角运动、不规则运动等，对于这种运动，使用放射预测能很好地提高编码性能。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(六)之帧内编码 Intra Prediction]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/12/intra-prediction/"/>
    <updated>2019-11-12T14:00:19-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/12/intra-prediction</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#spec-recursive-filtering-" id="markdown-toc-spec-recursive-filtering-">1. SPEC Recursive Filtering 概述</a>    <ul>
      <li><a href="#dav1d--recursive-filtering-" id="markdown-toc-dav1d--recursive-filtering-">DAV1D 中 Recursive Filtering 代码</a></li>
    </ul>
  </li>
  <li><a href="#smooth-intra-prediction-" id="markdown-toc-smooth-intra-prediction-">2. Smooth Intra Prediction 概述</a>    <ul>
      <li><a href="#dav1d--smooth-intra-prediction-" id="markdown-toc-dav1d--smooth-intra-prediction-">DAV1D 中 Smooth Intra Prediction 代码</a></li>
    </ul>
  </li>
  <li><a href="#intra-block-copy-" id="markdown-toc-intra-block-copy-">3. Intra Block Copy 概述</a>    <ul>
      <li><a href="#intrabc-" id="markdown-toc-intrabc-">IntraBC 几个概念</a></li>
    </ul>
  </li>
  <li><a href="#section" id="markdown-toc-section">4. 调色板模式概述</a>    <ul>
      <li><a href="#color-palette" id="markdown-toc-color-palette">Color Palette</a></li>
    </ul>
  </li>
  <li><a href="#chroma-from-luma-" id="markdown-toc-chroma-from-luma-">5. Chroma From Luma 概述</a>    <ul>
      <li><a href="#dav1d--cfl-" id="markdown-toc-dav1d--cfl-">DAV1D 中 CFL 代码</a></li>
      <li><a href="#cfl-" id="markdown-toc-cfl-">CFL 结论</a></li>
    </ul>
  </li>
</ul>

<p>VP9 支持 10 种 帧内预测模式，包括 8 个方向的模式，对应到 45-207 的角度，以及 2 个非方向的预测模式（DC 和 True Motion 模式）。AV1 中，帧内编码器从多个角度进行了扩展：角度预测的粒度进行了升级、利用亮度和色度信号的相干性等等。</p>

<!--more-->

<p>AV1 中的帧内预测器，有一种称之为基于递归滤波的帧内预测器。该帧内预测器利用滤波的方式递归地对每个像素值进行预测，在编码方面复杂度会有所提升。</p>

<h2 id="spec-recursive-filtering-">1. SPEC Recursive Filtering 概述</h2>

<p>下面给出 SPEC 中对该预测模式的概述：</p>

<blockquote>
  <p>The inputs to this process are:<br />
1. a variable w specifying the width of the region to be predicted.<br />
2. a variable h specifying the height of the region to be predicted.<br />
The output of this process is a 2D array named pred containing the intra predicted samples.<br />
For each block of 4x2 samples, this process first prepares an array p of 7 neighboring samples, and then produces the output block by filtering this array.<br />
The variable w4 is set equal to w » 2.<br />
The variable h2 is set equal to h » 1.<br />
The following steps apply of i2 = 0…h2 - 1, for j4 = 0…w4 - 1:<br />
The array p is derived as follows for i = 0…6:<br />
  1. If i is less than 5, p[i] is derived as follows:<br />
      1. If i2 is equal to 0, p[i] is set equal to AboveRow[(j4 « 2) + i -1].<br />
      2. Otherwise, if j4 is equal to 0 and i is equal to 0, p[i] is set equal to LeftCol[(i2 « 1) - 1].<br />
      3. Otherwise, p[i] is set equal to pred[(i2 « 1) - 1][(j4 « 2) + i - 1].<br />
  2. Otherwise (i is greater than or equal to 5), p[i] is derived as follows:<br />
      1. If j4 is equal to 0, p[i] is set equal to LeftCol[(i2 « 1) + i - 5].<br />
      2. Otherwise(j4 is not equal to 0), p[i] is set equal to pred[(i2 « 1) + i - 5][(j4 « 2) - 1]<br />
The following steps apply for i1 = 0..1, j1 = 0..3:<br />
  1. The variable pr is set equal to 0.<br />
  2. The variable pr is incremented by Intra_Filter_Taps[filter_intra_mode][(i1 « 2) + j1][i] * p[i] for i = 0…6<br />
  3. pred[(i2 « 1) + i1][(j4 « 2) + j1] is set equal to Clip1(Round2Signed(pr, INTRA_FILTER_SCALE_BITS)).</p>

  <p>The output of the process is the array pred.</p>
</blockquote>

<p>对于每个 4x2 采样点的块，该预测模式首先准备包含 7 个相邻样本的数组,之后通过对该数组进行滤波产生输出块。</p>

<h3 id="dav1d--recursive-filtering-">DAV1D 中 Recursive Filtering 代码</h3>

<p>Dav1d 中关于此预测模式的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cm">/* Up to 32x32 only */</span>
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_filter_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft_in</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filt_idx</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                           <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">filt_idx</span> <span class="o">&amp;=</span> <span class="mi">511</span><span class="p">;</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">filt_idx</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">const</span> <span class="kt">int8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">dav1d_filter_intra_taps</span><span class="p">[</span><span class="n">filt_idx</span><span class="p">];</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line">    <span class="kt">ptrdiff_t</span> <span class="n">left_stride</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">topleft</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">top</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">topleft_in</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">topleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">topleft_in</span><span class="p">[</span><span class="o">-</span><span class="n">y</span><span class="p">];</span>
</span><span class="line">        <span class="n">left</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">left_strie</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p0</span> <span class="o">=</span> <span class="o">*</span><span class="n">topleft</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">left_stride</span><span class="p">],</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">left_stride</span><span class="p">];</span>
</span><span class="line">            <span class="n">pixel</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int8_t</span> <span class="o">*</span><span class="n">flt_ptr</span> <span class="o">=</span> <span class="n">filter</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">yy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">yy</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">yy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">,</span> <span class="n">flt_ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                    <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">flt_ptr</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">*</span> <span class="n">p4</span> <span class="o">+</span> <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">*</span> <span class="n">p5</span> <span class="o">+</span>
</span><span class="line">                              <span class="n">flt_ptr</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">*</span> <span class="n">p6</span><span class="p">;</span>
</span><span class="line">                    <span class="n">ptr</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="n">iclip_pixel</span><span class="p">((</span><span class="n">acc</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">                <span class="n">ptr</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">left</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="n">left_stride</span> <span class="o">=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">            <span class="n">top</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="n">topleft</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">top</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">top</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">bitfn</span><span class="p">(</span><span class="n">dav1d_intra_pred_dsp_init</span><span class="p">)(</span><span class="n">Dav1dIntaPredDSPContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">intra_pred</span><span class="p">[</span><span class="n">FILTER_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_filter_c</span><span class="p">;</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="smooth-intra-prediction-">2. Smooth Intra Prediction 概述</h2>

<p>帧内预测种，除了方向预测模式外，AV1 还支持非定向帧内预测模式，它有 4 种不同的方法对当前值进行预测，其中包括 3 种平滑预测模式 SMOOTH_V、SMOOTH_H、SMOOTH 以及 PAETH 预测器。</p>

<h3 id="dav1d--smooth-intra-prediction-">DAV1D 中 Smooth Intra Prediction 代码</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_paeth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">tl_ptr</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                          <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">topleft</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">cont</span> <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">top</span> <span class="o">-</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">ldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tdiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">topleft</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tdiff</span> <span class="o">&amp;&amp;</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">left</span> <span class="p">:</span>
</span><span class="line">                    <span class="n">tdiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">top</span> <span class="p">:</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>3 种平滑预测的方法如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_startup/smooth_intra_predictors.png" /></p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_v_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span><span class="p">,</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_ver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span><span class="line">                        <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="o">*</span> <span class="n">bottom</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_h_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_hor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span>
</span><span class="line">                        <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                           <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_hor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_ver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">width</span><span class="p">],</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="o">*</span> <span class="n">bottom</span> <span class="o">+</span>
</span><span class="line">                                <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="intra-block-copy-">3. Intra Block Copy 概述</h2>
<p>AV1 允许它的帧内编码器在预测当前块时，反向搜索当前帧中之前已经重建的部分，该方式在某种程度上与帧间编码搜索之前的帧是类似的。
该方法对于屏幕内容的视频压缩非常有效，因为屏幕内容的视频通常会在同一帧中包含相同的文本、字符等内容。</p>

<p>帧内块拷贝(Intra Block Copy，简称 IntraBC)，除了传统的帧内和帧间预测模式外，IBC 模式采用当前帧中已重建帧作为预测块，可以认为 IntraBC 是当前编码图像内的运动补偿。</p>

<h3 id="intrabc-">IntraBC 几个概念</h3>

<p>AV1 SPEC 中关于 IntraBC 的几点。</p>

<blockquote>
  <p><strong>allow_intrabc</strong> equal to 1 indicates that intra block copy may be used in this frame. allow_intrabc equal to 0 indicates that intra block copy is not allowed in this frame.<br />
<strong>Note:</strong> intra block copy is only allowed in intra frames, and disables all loop filtering. force_integer_mv will be equal to 1 for intra frames, so only integer offsets are allowed in block copy mode.<br />
<strong>force_integer_mv</strong> equal to 1 specifies that motion vectors will always be integers. force_integer_mv equal to 0 specifies that motion vectors can contain fractional bits.</p>
</blockquote>

<p>allow_intrabc 为1，表示该帧中可能存在 intra block copy，否则不存在。同时，intra block copy 仅仅在帧内编码图像中允许，使用了 intra block copy 的块，禁止任何的滤波。</p>

<blockquote>
  <p><strong>use_intrabc</strong> equal to 1 specifies that intra block copy should be used for this block. use_intrabc equal to 0 specifies that intra block copy should not be used.</p>
</blockquote>

<p>use_intrabc 为 1，表示该宏块使用 intra_block_copy ，否则不使用该方法。</p>

<h2 id="section">4. 调色板模式概述</h2>

<p>调色板模式，对于屏幕内容图像，很多编码块内部的颜色数是有限的，调色板模式枚举这些颜色生成颜色表，然后为每个样本传递一个索引以指示它属于颜色表中的哪种颜色。和基于预测-变换的传统编码方法相比，对于颜色数相对集中的屏幕内容图像，调色板模式往往更加有效。</p>

<p>调色板模式将块内的元素当做几种离散的颜色，不同于直接传输像素本身的参数值，而是通过传输色块的颜色编号实现压缩的目的。
AV1 支持从 8x8 到 64x64 的块，支持调色板模式，编码器会自动根据视频内容选择是否使用调色板模式。调色板模式对于当前块
有单一色调的场景十分有用，一般这种场景出现在屏幕内容的压缩当中。</p>

<h3 id="color-palette">Color Palette</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">pal_pred_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">pal</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">pal</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">x</span><span class="p">]];</span>
</span><span class="line">        <span class="n">idx</span> <span class="o">+=</span> <span class="n">w</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="chroma-from-luma-">5. Chroma From Luma 概述</h2>
<p>AV1 在帧编码中使用了Chroma_From_Luma 的工具，它是利用视觉图像中亮度值和色度值具有高度相似性的特点，通过选择适当的参数结合重建亮度值来预测色度值，该工具在游戏视频中具有很好地压缩效果。</p>

<p>Chrom_From_Luma(CFL) 的整个流程可以由下图表示。</p>

<p>当 chroma 分量通过下采样得到时，为使得像素分量一致，重建的 luma 分量需要对应的下采样。之后相应的重建 luma 像素减去平均值，得到 AC 分量。 scale 因子和符号，是通过码流中解码获得。CFL 预测值通过将重建 luma 像素的 AC 分量和 scale 因子相乘，并将结果与帧内的 DC 预测相加得到。如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_cfl/chroma_from_luma.png" /></p>

<p>该流程分为三步：</p>

<ol>
  <li>Compute Luma AC Contribution。</li>
  <li>Scale Chroma Plane</li>
  <li>Add Chroma DC_PRED</li>
</ol>

<h3 id="dav1d--cfl-">DAV1D 中 CFL 代码</h3>

<p>DAV1D 中关于 CFL 的部分，主要由下面两类函数完成，其中一类就是求 AC Contribution。第二类就是 alpha * AC + DC_PRED。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">dav1d_inta_ped_dsp_init</span><span class="p">(</span><span class="n">Dav1dIntraPredDSPContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I420</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_420_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I422</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_422_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I444</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_444_c</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_128_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_128_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">TOP_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_top_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">LEFT_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_left_c</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>关于求 AC Contribution 的函数如下，它根据 YUV 三个分量的组成比例，会有不同的参数传递，但整体思路是一样的.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cfl_ac_c</span><span class="p">(</span><span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">ypx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">w_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_hor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_ver</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">ac_orig</span> <span class="o">=</span> <span class="n">ac</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">w_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">);</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">h_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">h_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">h_pad</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">w_pad</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">ac_sum</span> <span class="o">=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">ss_hor</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_ver</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">ss_hor</span><span class="p">)</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac_sum</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_ver</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_hor</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">ypx</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ss_ver</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">memcpy</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">[</span><span class="o">-</span><span class="n">width</span><span class="p">],</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ac</span><span class="p">));</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">log2sz</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">log2sz</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">sum</span> <span class="o">&gt;&gt;=</span> <span class="n">log2s</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//subtract DC</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sum</span><span class="p">;</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define cfl_ac_fn(fmt, ss_hor, ss_ver)  \</span>
</span><span class="line"><span class="cp">    static void cfl_ac_##fmt##_c(int16_t *const ac, const pixel *const ypx, \</span>
</span><span class="line"><span class="cp">                                 const ptrdiff_t stide, const int w_pad, \</span>
</span><span class="line"><span class="cp">                                 const int h_pad, const int cw, const int ch) \</span>
</span><span class="line"><span class="cp">{   \</span>
</span><span class="line"><span class="cp">    cfl_ac_c(ac, ypx, stride, w_pad, h_pad, cw, ch, ss_hor, ss_ver);    \</span>
</span><span class="line"><span class="cp">}</span>
</span><span class="line">
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">422</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">444</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来是求解 DC PRED 的值以及最终的 Chroma 值。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">    <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">!=</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">*=</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">MULTIPLIER_1x4</span> <span class="p">:</span>
</span><span class="line">                                                            <span class="n">MULTIPLIER_1x2</span><span class="p">;</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">BASE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span>
</span><span class="line"><span class="nf">cfl_pred</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">iclip_pixel</span><span class="p">(</span><span class="n">dc</span> <span class="o">+</span> <span class="n">apply_sign</span><span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">,</span> <span class="n">diff</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_128_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="cp">#if BITDEPTH == 16</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitdepth_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="cp">#else</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
</span><span class="line"><span class="cp">#endif</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span> <span class="n">stride</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_left</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">++</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">)];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_top</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_left_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen_left</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_top_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">widht</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc_gen_top</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="cfl-">CFL 结论</h3>

<p>AV1 中采用的 Chroma_From_Luma 预测工具，该工具不仅降低了解码器复杂度，同时降低了预测错误率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(五)之DEBLOCK FILTER]]></title>
    <link href="http://lazybing.github.io/blog/2019/07/10/deblock-filter/"/>
    <updated>2019-07-10T07:07:33-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/07/10/deblock-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析及优化</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">参考资料</a></li>
</ul>

<p>AV1 使用了非常多的环路滤波器工具应用于解码帧。环路滤波的第一个阶段是去块滤波器(Deblocking Filter)。</p>

<!--more-->

<p>AV1 的去块滤波器与 VP9 中使用的滤波器基本相同，只是做了很小的改动————最长滤波从 VP9 的 15 抽头降成了 13 抽头。除了去块滤波器，AV1 还采用了CDEF 滤波器、Loop Restoration 滤波器、Film Grain 滤波器。</p>

<p>去块滤波器(Deblocking Filter, DBF)又称去块效应滤波器，是一种减少在区块边界产生视觉上瑕疵的滤波器。这种视觉瑕疵称为区块效应，这种效应主要构成原因是以区块为基础的编解码器所造成的人造边界，以区块为基底的编解码器（AVC/HEVC/AV1）都会在解码过程中利用去块滤波器将区块效应的影响降低以改善视频影像的质量。</p>

<h3 id="section">介绍</h3>

<p>以区块为基础的编解码器在预测(Prediction)或转换(Transform)编码时，都会将影像分成区块再做编码。因此影像重建时会造成在区块间边缘处不连续的现象，该现象称为去块效应，而这些区块边缘间视觉上的不连续称为人造边界。人造边界的主要成因有两个：</p>

<ul>
  <li>预测时出现不准的地方称为残量(Residual)，残量会利用离散余弦变换做量化，由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。</li>
  <li>运动补偿，同一个画面内部相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此会造成不连续的现象。同样的，画面内预测的方式也可能造成影像不连续。</li>
</ul>

<p>去区块滤波器主要有三个工作，分别是边界强度计算(Boundary Strength Computation)、边界分析(Boundary Analysis)以及滤波器应用(Filter Implementation)。</p>

<ol>
  <li>边界强度计算：主要是去计算边界强度(Boundary Strength, Bs)这个参数，边界强度呈现出相邻区块边界不连续的程序，而这个参数会跟量化的方式、区块类型、移动向量以及边界取样的梯度有关。</li>
  <li>边界分析：因为区块边缘不连续的现象可能真的是对象边缘所产生，并非所谓的人造边界，这个工作主要是判断是否为人造边界。</li>
  <li>滤波器的应用：做完前面两个工作可以决定边界强度以及判断是否真的为人造边界，这个工作主要对人造边界对应的边界强度选择该应用的滤波器。</li>
</ol>

<h3 id="section-1">源码分析及优化</h3>

<p>首先看 DAV1D 中，关于去块滤波的 C 实现函数：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_filter_h_sb128y_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">vmast</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">ptrdiff_t</span> <span class="n">b4_stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="n">AvFilterLUT</span> <span class="o">*</span><span class="n">lut</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">vm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">         <span class="n">y</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="n">l</span> <span class="o">+=</span> <span class="n">b4_stride</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">vm</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">H</span> <span class="o">=</span> <span class="n">L</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">E</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">I</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">[</span><span class="n">L</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="o">!!</span><span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">loop_filter</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面只是给出 Y 分量上的 水平滤波函数，从上面给出的 C 实现看，要实现 NEON 优化，并不简单，但如果再看它的汇编优化，简直太聪明了，在 DAV1D 发布0.3版本时，官方就称，仅仅去块滤波这一个模块，解码 8bit 流时，解码效率提升7%~34%之高。
后来我自己实现 10bit NEON 优化时，因为寄存器个数的限制（10bit，一个128位寄存器只能存放8个像素;而8bit，一个128位寄存器可存放16个像素），简码效率也有至少5%的提升。当时仿照 8bit 实现时，感慨汇编的技巧使用，惊为天人！</p>

<h3 id="section-2">参考资料</h3>

<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%8E%BB%E5%8D%80%E5%A1%8A%E6%BF%BE%E6%B3%A2%E5%99%A8">去块滤波器</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之性能分析工具perf]]></title>
    <link href="http://lazybing.github.io/blog/2019/05/17/perf/"/>
    <updated>2019-05-17T08:43:15-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/05/17/perf</id>
    <content type="html"><![CDATA[<p>本文主要记录性能优化工具 perf 的方法技巧。</p>

<!--more-->

<p><strong>perf</strong>有些子命令：</p>

<ul>
  <li>stat: 测试单个程序的事件总数。</li>
  <li>top:类似top命令，动态显示最耗时的函数。</li>
  <li>record:测试并保存单个程序的抽样数据。</li>
  <li>report:分析由 perf record 命令生成的文件，可以生成 flat 或 graph profile   文件。</li>
  <li>annotate:annotate源文件或汇编。</li>
  <li>sched:调度程序操作和延迟的追踪和测量。</li>
  <li>list:列出可能的事件。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之分支预测]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/26/branch-predictor/"/>
    <updated>2019-04-26T08:58:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/26/branch-predictor</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">预测种类</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">程序示例</a></li>
</ul>

<p>分支预测是在分支指令执行结束之前猜测哪一路分支将会被执行，以提高处理器的指令流水线的性能。使用分支预测器的目的，在于改善指令管线化的流程。</p>

<!--more-->

<h2 id="section">预测种类</h2>

<ul>
  <li>
    <p>静态预测：最简单的分支预测技术，不依赖于代码执行的动态历史信息。静态预测可以再次细分，有的是总是预测条件跳转不发生，有的假定向后分支将会发生，向前的分支不发生。向后分支是指跳转到的新地址总比当前地址要低。</p>
  </li>
  <li>
    <p>双模特预测器：该预测器是一种有 4 个状态的状态机：强不选择、弱不选择、弱选择、强选择。当一个分支命令被求值，对应的状态机被修改。分支不采纳，则向“强不选择”方向降低状态值；如果分支被采纳，则向“强选择”方向提高状态值。</p>
  </li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/saturating_counter-dia.png" /></p>

<ul>
  <li>两级自适应预测器：对于一条分支指令，如果每 2 次执行发生一次条件跳转，或者其他的规则发生模式，那么用上文提到的双模态预测器就很难预测了。如图所示，一种两级自适应预测器可以记住过去 n 次执行指令时的分支情况的历史，可能的 2^n 种历史模式的每一种都有 1 个专用的双模态预测器，用来表示如果刚刚过去的 n 次执行历史是此种情况，那么根据这个双模态预测器预测为跳转还是不跳转。</li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/Two-level_branch_prediction.png" /></p>

<h2 id="section-1">程序示例</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line"><span class="cp">#include &lt;chrono&gt;</span>
</span><span class="line"><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line">
</span><span class="line"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">arraySize</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">        <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">arraySize</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">               <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">())</span><span class="o">*</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">num</span><span class="o">/</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">den</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;const total &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; sec&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的双重 for 循环，如果对数组不排序、或者修改循环体内的条件语句为</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">;</span>
</span><span class="line">        <span class="n">sum</span> <span class="o">+=</span> <span class="o">~</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>三种相同功能的代码，耗时如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">代码结构</th>
      <th style="text-align: center">耗时</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">不排序</td>
      <td style="text-align: center">26.27s</td>
    </tr>
    <tr>
      <td style="text-align: center">排序</td>
      <td style="text-align: center">9.87s</td>
    </tr>
    <tr>
      <td style="text-align: center">不分支预测</td>
      <td style="text-align: center">10.97s</td>
    </tr>
  </tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之利用局部性原理]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/21/locality-of-reference/"/>
    <updated>2019-04-21T02:56:40-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/21/locality-of-reference</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">局部性示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">局部性原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">存储器层次结构</a></li>
</ul>

<p>局部性原理是指程序通常倾向于引用邻近于其最近引用过的数据项的数据项，或最近引用过的数据本身。</p>

<!--more-->

<h2 id="section">局部性示例</h2>

<p>先看下面两个对数组访问的示例，</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define ARRAY_ROW_SIZE 1000</span>
</span><span class="line"><span class="cp">#define ARRAY_COL_SIZE 1000</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_col</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_row</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<table>
  <thead>
    <tr>
      <th style="text-align: center">used time</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">access_array_row</td>
      <td style="text-align: center">3521</td>
      <td style="text-align: center">4287</td>
      <td style="text-align: center">4741</td>
    </tr>
    <tr>
      <td style="text-align: center">access_array_col</td>
      <td style="text-align: center">12389</td>
      <td style="text-align: center">10713</td>
      <td style="text-align: center">11985</td>
    </tr>
  </tbody>
</table>

<p>从上面的例子可以看出，同样是访问一个数组，采用列访问和采用行访问，事件相差非常大，原因就是<code>access_array_row</code>利用局部性原理。</p>

<h2 id="section-1">局部性原理</h2>

<p>局部性主要包括两种形式，时间局部性和空间局部性。</p>

<ul>
  <li>时间局部性：被引用过一次的存储器位置很可能在不远的将来再被多次引用。</li>
  <li>空间局部性：如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。</li>
</ul>

<p>有良好局部性的程序比局部性差的程序运行得更快，计算机系统设计中，局部性原理在硬件和软件中都有应用，硬件层上，采用了<strong>高速缓存存储器</strong>充分利用了局部性原理；软件层上，操作系统用主存来缓存硬盘文件系统。</p>

<h2 id="section-2">存储器层次结构</h2>

<p>局部性原理在存储器中使用特别频繁。</p>

<p><img src="http://lazybing.github.io/images/locality/locality.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之减少调用]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call/"/>
    <updated>2019-04-19T09:59:18-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">简单函数处理</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数处理</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">减少调用后续优化</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">总结</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">参考资料</a></li>
</ul>

<p>函数调用会带来相当大的开销，而且它会阻碍其他形式的程序优化。单独的较少调用次数可能对性能提升并不明显，但考虑到减少调用后，可以进一步进行其他形式的优化，减少函数调用还是很有必要的。</p>

<!--more-->

<h2 id="section">简单函数处理</h2>

<ul>
  <li>
    <p>直接将函数展开，写入调用函数处，去掉调用函数。</p>
  </li>
  <li>
    <p>使用<strong>inline</strong>关键字，将经常调用的函数写成内联函数。</p>
  </li>
  <li>
    <p>使用<strong>define</strong>关键字，使得代码在编译时将其展开。</p>
  </li>
</ul>

<p>例如，下面的函数调用</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>可以使用上面提到的三种优化方式：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">// method 1</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="c1">//method 2</span>
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class="line"><span class="c1">//method 3</span>
</span><span class="line"><span class="cp">#define IMIN(a, b) return ((a) &lt; (b) ? (a) : (b))</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">IMIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-1">函数处理</h2>

<p>上面的方法针对小函数、频繁调用的情况较试用，当函数较复杂时，我们就不适合直接展开了，那样会显得整个代码特别繁琐；另外如果被调用函数并不是我们自己的代码，就更没办法用上面提到的方法了。此时，就要分析函数的功能，选择替代方案减少调用。举个例子：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="n">vec_rec</span><span class="p">,</span> <span class="o">*</span><span class="n">vec_ptr</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">vec_ptr</span> <span class="nf">new_vec</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">vec_ptr</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec_ptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vec_rec</span><span class="p">));</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">result</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">data_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">data_t</span><span class="p">));</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">){</span>
</span><span class="line">            <span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
</span><span class="line">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">get_vec_element</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">long</span> <span class="kt">int</span> <span class="nf">vec_length</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">        <span class="n">get_vec_element</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的<code>combine2</code>函数的 for 循环中会一直调用 <strong>get_vec_element</strong>函数来获取一个元素，通过分析该函数可以看出，它获取的其实是<strong>vec_rec.v-&gt;data</strong>数组的元素，该元素也是随着循环索引<strong>i</strong>来递增的，因此可以把该函数提到<strong>for</strong>循环的外面，减少函数调用，修改后的函数如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">data_t</span> <span class="o">*</span><span class="nf">get_vec_start</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2_reducing_proc_call</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>分析上面的优化，其实它是破坏了函数的结构的，这种方法会损害函数的模块性和抽象性，上面的例子中，我们是通过分析<code>get_vec_element</code>函数和<code>for</code>循环才确定的减少调用是可用的。</p>

<h3 id="section-2">减少调用后续优化</h3>

<p>上面提到的都是针对减少调用本身来提升性能的，减少调用本身对系统性能的提升非常有限，但减少调用后，可以方便的进行进一步的优化，而进一步的优化可能效果非常显著。例如上面提到的 combine 函数，将调用函数提取到 for 循环外后，可以对整个 for 循环进行 NEON 优化，效率的提升会更加明显。</p>

<p>在做 AV1 效率优化时，也遇到过类似的优化案例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define add_noise_y(x, y, grain)    \</span>
</span><span class="line"><span class="cp">    pixel *src = src_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    pixel *dst = dst_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    int noise  = round2(scaling[ *src ] * (grain), data-&gt;scaling_shift); \</span>
</span><span class="line"><span class="cp">    *dst = iclip(*src + noise, min_value max_value);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bw</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">grain</span> <span class="o">=</span> <span class="n">sample_lut</span><span class="p">(</span><span class="n">grain_lut</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">add_noise_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>未优化前，此段代码在解码过程中，大概耗时 8ms，优化完成后，降低到 7ms，效率提升了 12.5%。提升还是很大的。</p>

<h2 id="section-3">总结</h2>

<h2 id="section-4">参考资料</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之循环展开]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/17/loop-unroll/"/>
    <updated>2019-04-17T07:36:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/17/loop-unroll</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例分析</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">循环展开扩展</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结论总结</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">参考资料</a></li>
</ul>

<p>循环展开是通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开只能针对整形加法和乘法的性能改进。</p>

<!--more-->

<p>循环展开从两个方面改变程序的性能：</p>

<ul>
  <li>分支预测失败减少。</li>
  <li>减少不直接有助于程序结果的操作的数量，如循环索引计算和条件分支。</li>
  <li>提供了一种方法，可以进一步变换代码，减少整个计算中关键路径上的操作数量。</li>
</ul>

<h2 id="section">示例分析</h2>

<figure class="code"><figcaption><span>loop_unrolling.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span><span class="p">;</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll1</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll2</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll3</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>运行上面的程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -funroll-loops -pg loop_unrolling.c -o loop_unrolling</span></code></pre></td></tr></table></div></figure>

<p>执行三次后，结果如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Executions</th>
      <th style="text-align: center">loop_unroll1</th>
      <th style="text-align: center">loop_unroll2</th>
      <th style="text-align: center">loop_unroll3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">12618</td>
      <td style="text-align: center">1890</td>
      <td style="text-align: center">3162</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7456</td>
      <td style="text-align: center">1987</td>
      <td style="text-align: center">1629</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">9868</td>
      <td style="text-align: center">2446</td>
      <td style="text-align: center">2388</td>
    </tr>
  </tbody>
</table>

<p>上面的结果可以看出，产开次数为2相对于未展开时，性能有明显提升，但展开次数为4时，性能相对于展开次数为2并没有多少提升。另外，编译器选项<code>-funroll-loops</code>好像并没有起到什么作用。但是如果添加编译选项<code>-O1</code>或<code>-O2/-O3</code>时，编译器会自动优化该函数。</p>

<p>关于展开次数和性能之间的关系，CSAPP 这本书里有介绍一个实验结果，如图所示：</p>

<p><img src="http://lazybing.github.io/images/loop_unroll/loop_unrolling.png" /></p>

<p>从图中可以看出，当循环展开到6次时的CPE(Cycles Per Element,每元素的周期数)测量值，对于展开2次或3次时观察到的趋势还在继续——循环展开对浮点数运算没有帮助，但对整数加法和乘法，CPE降至1.00.</p>

<p>实验过程中发现，CSAPP中描述的结论与我自己测试的结果有几点需要注意：</p>

<ol>
  <li>测试中，循环展开对于浮点数的加法和乘法是有效的。</li>
  <li>编译器选项<code>-funroll-loops</code>并没有起到循环展开的作用。</li>
  <li>循环展开对于性能的提升确实是都有帮助的。</li>
</ol>

<h2 id="section-1">循环展开扩展</h2>

<p>循环展开的本质是降低循环开销、增加并行运行的可能性。网上找到的大部分讲解循环展开的都是针对<strong>for</strong>循环的，既然是循环展开，那么对于<strong>while</strong>循环，理论上也是适用的，最后找到了<a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling</a>。关于<strong>while</strong>循环展开的方法，可以用下面的描述语言表示：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">while B do S; &lt;==&gt; while B ^ wp(S, B) do begin S;S end; while B do S;</span></code></pre></td></tr></table></div></figure>
<p>按照论文的讲解，手动写了两个替换的等价循环</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>遗憾的是，运行后，两者的时间并没有太大的差别，有时第二段代码方法甚至更慢。猜测可能原因有两点：现代编译器对此类优化方法已经完成的很好；不同运行环境运行效果不同；所以，循环展开这类方法，最好是实际操作运行看结果，理论与实际可能有出入。</p>

<h2 id="section-2">结论总结</h2>

<p>循环展开对于性能的提升是由帮助的，但这种帮助并不是无限的，随着展开次数的增多，性能并不会继续增加，相反，循环展开次数过多，会使得程序代码膨胀、代码可读性降低。另外，编译器优化选项<code>-O1</code>或<code>-O2</code>等，会使得编译器自身会对代码进行优化，此时手动循环展开并不是一个好的方法。再者，受运行环境的影响（我的测试用例都是在Ubuntu虚拟机下完成），其测试结果可能有不同。</p>

<h2 id="section-3">参考资料</h2>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80">循环展开</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop Unrolling</a></li>
  <li><a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling: a Method for Program Speed-Up</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/37582101">C++性能榨汁机之循环展开</a></li>
  <li><a href="https://github.com/shihyu/CSAPP2e/blob/master/Computer%20Systems%20-%20A%20Programmer's%20Perspective%20(2nd).pdf">Computer Systems - A Programmer’s Perspective</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之vallgrind之callgrind分析瓶颈]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/15/profiler/"/>
    <updated>2019-04-15T08:08:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/15/profiler</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#callgrind-" id="markdown-toc-callgrind-">Callgrind 概述</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">主要功能</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">基本使用方法</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">高级使用方法</a>    <ul>
      <li><a href="#profile-" id="markdown-toc-profile-">生成多个 profile 文件</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">限制收集事件的范围</a></li>
    </ul>
  </li>
  <li><a href="#callgrind--1" id="markdown-toc-callgrind--1">Callgrind 命令行选项</a>    <ul>
      <li><a href="#dump-" id="markdown-toc-dump-">dump 生成选项</a></li>
      <li><a href="#activity-" id="markdown-toc-activity-">activity 选项</a></li>
      <li><a href="#data-collection-" id="markdown-toc-data-collection-">data collection 选项</a></li>
      <li><a href="#cost-entity-separations-" id="markdown-toc-cost-entity-separations-">cost entity separations 选项</a></li>
      <li><a href="#simulation-" id="markdown-toc-simulation-">simulation 选项</a></li>
      <li><a href="#cache-simulation-" id="markdown-toc-cache-simulation-">cache simulation 选项</a></li>
    </ul>
  </li>
  <li><a href="#callgrindannotate-" id="markdown-toc-callgrindannotate-">callgrind_annotate 命令行选项</a></li>
  <li><a href="#callgrindcontrol-" id="markdown-toc-callgrindcontrol-">callgrind_control 命令行选项</a></li>
</ul>

<p>对程序进行性能优化的前提是知道程序性能瓶颈在哪里。本文记录 vallgrind 工具之 callgrind 来测试程序性能。</p>

<!--more-->

<p>在优化 AV1 解码库时，使用 callgrind 和 kcachegrind 来检测程序性能，下面先给出测试结果，然后用一个小的程序进行逐步分析。</p>

<p><img src="http://lazybing.github.io/images/valgrind_callgrind/valgrind_callgrind_dav1d.png" /></p>

<h2 id="callgrind-">Callgrind 概述</h2>

<p>使用该工具，必须在使用 valgrind 命令行时指定工具<code>--tool=callgrind</code>。</p>

<p>callgrind 是一个性能剖析工具，它记录一个程序运行时函数间调用历史。默认状态下，收集到的数据包括执行指令的个数、指令与源码行的对应关系、函数间调用和被调用的关系以及调用次数。除此外，模拟缓存和分支预测可能会产生更多关于应用程序运行的信息。</p>

<p>分析的数据在程序结束时会写到一个文件中。用于显示数据以及剖析互动控制，有如下两个命令 <strong>callgrind_annotate</strong> 和 <strong>callgind_control</strong>。</p>

<ul>
  <li><strong>callgrind_annotate</strong> 该命令读取 profile 数据，将函数占用时间打印出来，也可以使用图形化工具 Kcachegrind。</li>
  <li><strong>callgrind_control</strong> 该命令在执行 callgrind 时，使我们可以交互的观察和控制当前运行程序的状态，而不用停止该程序。可以用该命令获取统计信息以及当前堆栈跟踪信息。</li>
</ul>

<h3 id="section">主要功能</h3>

<p><strong>cachegrind</strong> 主要是收集 flat profile 数据：数据读取和 cache 命中率等事件发生的次数直接归因于它们发生的函数。这种归因机制称为自我归因或独占归因。</p>

<p><strong>callgrind</strong> 通过跨越函数调用边界的成本将 cachegrind 的功能进行扩展。如果函数 <strong>foo</strong> 调用 <strong>bar</strong>,从 <strong>bar</strong> 返回的消耗算到 <strong>foo</strong> 消耗里。当作为一只整体应用到程序中时，这就构建成了一个所谓的包容性成本的图片，即，每个函数的消耗包括它直接调用或间接调用的函数的消耗。</p>

<p>比如，main 函数的包容性消耗应该接近整个程序消耗的 100%。因为在调用 main 函数前，还会有其他初始的运行时间，因此最终的消耗只是接近 100%。</p>

<p>同调用图一起，可以清晰的看到从 main 开始的整个调用链，调用链上会清晰的给出程序主要消耗在什么地方。函数调用对剖析函数也是非常有用的，优化的机会一般取决于更改调用者的代码，尤其是降低调用次数。</p>

<p>callgrind 的 cache 模拟是基于 cachegrind 基础之上的。接下来的描述都是在 cachegrind 的特性基础之上进行的。</p>

<p>callgrind 的主要功能是依据它运行平台的指令集，检测函数调用和返回，它能很好地运行在 x86 和 amd64 平台上，但不幸的是在 ARM、PowerPC 或 MIPS平台上运行的并不好，因为这些平台上没有明确的调用和返回指令。</p>

<h3 id="section-1">基本使用方法</h3>

<p>和 cachegrind 一样，必须在编译时添加<code>-g</code>选项来获取调试信息，并且要将优化选项打开。启动剖析程序，只需执行如下命令：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">valgrind --tool=callgrind [callgrind options] your-program [program options]</span></code></pre></td></tr></table></div></figure>

<p>程序运行过程中，想要观察执行情况，只需要执行如下命令<code>callgrind_control -b</code>。</p>

<p>程序运行完成后，会生成一个名为<code>callgrind.out.&lt;pid&gt;</code>的文件，其中 pid 就是程序的线程 ID。该文件就包含了程序执行过程中各个函数的调用情况以及指令读取(<strong>Instruction Read(Ir)</strong>)情况。</p>

<p>想要从 profile 数据文件中生成函数的总结，使用<code>callgrind_annotate [options] callgrind.out.&lt;pid&gt;</code>。该命令与 cachegrind 中的<code>cg_annotate</code>类似，函数会按照消耗排序。callgrind 的额外的重要的特性是如下两个选项：</p>

<ul>
  <li><code>--inclusive=yes</code>:使用该选项后，会使用并显示包容性消耗的函数排序，而不是独立性消耗的排序。</li>
  <li><code>--tree=both</code>:</li>
</ul>

<h2 id="section-2">高级使用方法</h2>

<h3 id="profile-">生成多个 profile 文件</h3>

<p>有些时候，我们对完成程序运行的特性并不关心，而只是关注其中很小的一部分，比如执行某个算法。如果有多个算好或一个算法有不同的输入数据，一个单独程序运行的不同部分的 profile 数据是非常有用的。profile 数据文件有如下形式的名字<code>callgrind.out.pid.part-threadID</code>。</p>

<p>dump 多个 profile 文件的方法和形式有多种，举例如下：</p>

<ul>
  <li><strong>Dump on program termination</strong>, 该方法就是标准的方法，不需要额外的做任何操作。</li>
  <li><strong>Spontaneous,interactive dumping</strong>，使用<code>callgrind_control -d [hint [PID/Name]]</code>来使得 profile 信息的dump带有 PID 或 Name。hint 是可以随意指定的字符串用于区分 profile dump 文件。dump 结束前，控制程序不会停止。注意，为例检测 dump 命令，应用程序必须处于运行态。如果你使用的是<code>Kcachegrind</code>，想要查看 profile 信息，可以使用工具栏按钮<strong>Force dump</strong>，就会发起一个 dump 请求。</li>
  <li><strong>Periodic dumping after execution of a apecified number of basic blocks</strong>，使用<code>--dump-every-bb=count</code>选项。</li>
  <li><strong>Dumping at enter/leave of specified functions</strong>。使用<code>--dump-before=function</code>和<code>--dump-after=function</code>选项。想要在进入某个函数前清零计数器，使用<code>--zero-before=function</code>选项。针对不同的函数，可以多次使用该选项。而且函数名可以使用如下形式<code>--dump-before='foo*'</code>，它会为每个函数名的开头为 foo 的函数生成 dump 文件。</li>
  <li><strong>Program controlled dumping</strong>。在需要 dump profile 发送的代码中插入<code>CALLGRIND_DUMP_STATS</code>。使用<code>CALLGRIND_ZERO_STATS</code>清零 profile 计数器。</li>
</ul>

<p>如果你正运行一个多线程应用程序，在命令行使用<code>--separate-threads=yes</code>选项，每个线程都会生成单独的 profile 文件。因此上面的最后两种方法只会生成当前运行线程生成的 dump 文件，其他方法，则会为每个线程生成多个dump文件。</p>

<h3 id="section-3">限制收集事件的范围</h3>

<p>默认情况下，当事件发生时(比如指令执行或cache命中或未命中)，callgrind 即可将这些事件计入事件计数器。但有时我们只对某个特定的函数或者一段程序代码感兴趣，函数或某段代码结束后，就不在将额外的部分计入事件计数器。</p>

<h2 id="callgrind--1">Callgrind 命令行选项</h2>

<h3 id="dump-">dump 生成选项</h3>

<ul>
  <li><code>--callgrind-out-file=&lt;file&gt;</code>选项影响 profile 数据文件的名称和格式，该选择指定 profile 数据写到 file 中而不是默认的输出文件<code>callgrind.out.&lt;pid&gt;</code>文件。</li>
  <li><code>--dump-line=&lt;no|yes&gt; [default:yes]</code>,该选项指定事件计数应该以源码行执行。这对于编译时带有调试信息的源码。</li>
  <li><code>--dump-instr=&lt;no|ys&gt; [default:no]</code>, 该选项指定事件计数应该以指令执行。这允许汇编。当前结果可以通过 KCachegrind 显示。</li>
  <li><code>--compress-strings=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定文件和函数名是否用数字区分。他会压缩文件，但使得更加难以读取。</li>
  <li><code>--compress-pos=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定数字位置是绝对值还是相对值。</li>
  <li><code>--combine-dumps=&lt;no|yes&gt; [default:no]</code>, 不推荐，使能该选项后，多个 profile 数据会追加到同一个输出文件。</li>
</ul>

<h3 id="activity-">activity 选项</h3>

<p>这类选项指定与事件计数相关的行为什么时候发生。对于交互控制，使用 callgrind_control 控制。</p>

<ul>
  <li><code>--dump-every-bb=&lt;count&gt; [default:0, never]</code>，Dump profile data every count basic blocks。</li>
  <li><code>--dump-before=&lt;function&gt;</code>，进入函数前 dump。</li>
  <li><code>--zero-before=&lt;function&gt;</code>, 进入函数前清零所有消耗统计。</li>
  <li><code>--dump-after=&lt;function&gt;</code>, 推出函数时 dump。</li>
</ul>

<h3 id="data-collection-">data collection 选项</h3>

<p>此类选项指定何时将事件聚合到事件计数中。</p>

<ul>
  <li><code>--instr-atstart=&lt;yes|no&gt; [default:yes]</code>，</li>
  <li><code>--collect-atstart=&lt;yes|no&gt; [default:yes]</code>,</li>
  <li><code>--toggle-collect=&lt;fucntion&gt;</code>,</li>
  <li><code>--collect-jumps=&lt;no|yes&gt; [default:no]</code></li>
  <li><code>--collect-systime=&lt;no|yes&gt; [default:no]</code>, 该选项指定系统调用的信息是否要被收集。</li>
  <li><code>--collect-bus=&lt;no|yes&gt; [default:no]</code>, 该选项指定全局总线事件的数量是否被收集。</li>
</ul>

<h3 id="cost-entity-separations-">cost entity separations 选项</h3>

<h3 id="simulation-">simulation 选项</h3>

<ul>
  <li><code>--cache-sim=&lt;yes|no&gt; [default:no]</code>,该选项指定是否做高速缓存模拟。默认情况下，只有指令读访问才会被计数(<strong>Ir</strong>)。如果启动高速缓存模拟，会有更多的事件被计数：指令读取的高速缓存命中率(<strong>I1mr/ILmr</strong>)，数据读取访问(<strong>Dr</strong>)以及相关的数据读取缓存miss(<strong>D1mr/DLmr</strong>),写数据访问(<strong>Dw</strong>)以及相关的cache misses(<strong>D1mw/DLmw</strong>)。</li>
  <li><code>--branch-sim=&lt;yes|no&gt;[default:no]</code>,该选项指定是否做分支预测模拟。使能该选项后，会有更多的事件计数被启动：执行分支预测的数量以及相关的分支miss(<strong>Bc/Bcm</strong>)，执行的间接跳跃和相关的跳转地址预测的miss(<strong>Bi/Bim</strong>)。</li>
</ul>

<h3 id="cache-simulation-">cache simulation 选项</h3>

<ul>
  <li><code>--simulate-wb=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对写块行为进行模拟。</li>
  <li><code>--simulate-hwpref=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对硬件预取器的模拟。</li>
  <li><code>--cacheuse=&lt;yes|no&gt;[default:no]</code>,该选择指定是否对高速缓存行的使用进行收集。</li>
  <li><code>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>。</li>
</ul>

<h2 id="callgrindannotate-">callgrind_annotate 命令行选项</h2>

<ul>
  <li><code>--show=A,B,C [default:all]</code>, only show figures for events A, B, C.</li>
  <li><code>--sort=A,B,C</code>,sort columns by events A, B, C[event column order], Optionally, each event is followed by a : and a threshold, to specify different thresholds depending on the event.</li>
  <li><code>--threshold=&lt;0--100&gt; [default:99%]</code>, Percentage of counts(of primary sort event) we are interested in.</li>
  <li><code>--auto=&lt;yes|no&gt; [default: no]</code>, Annotate all source files containing functions that helped reach the event count threshold..</li>
  <li><code>--context=N [default: 8]</code>, Print N lines of context before and after annotated lines.</li>
  <li><code>--inclusive=&lt;yes|no&gt; [default: no]</code>, Add subroutine costs to functions calls.</li>
  <li><code>--tree=&lt;none|caller|calling|both&gt; [default: none]</code>, Print for each function their callers, the called functions or both..</li>
  <li><code>-I, --include=&lt;dir&gt;</code>, Add dir to the list of directories to search for source files.</li>
</ul>

<h2 id="callgrindcontrol-">callgrind_control 命令行选项</h2>

<p>(未完待续。。。)</p>

]]></content>
  </entry>
  
</feed>
