<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-11-16T08:24:58-08:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(十)之帧内编码平滑帧内编码Smooth_Intra_Prediction]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/16/smooth-intra-prediction-process/"/>
    <updated>2019-11-16T06:24:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/16/smooth-intra-prediction-process</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 代码</a></li>
</ul>

<p>帧内预测种，除了方向预测模式外，AV1 还支持非定向帧内预测模式，它有 4 种不同的方法对当前值进行预测，其中包括 3 种平滑预测模式 SMOOTH_V、SMOOTH_H、SMOOTH 以及 PAETH 预测器。</p>

<!--more-->

<h2 id="section">概述</h2>

<h2 id="dav1d-">DAV1D 代码</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_paeth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">tl_ptr</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                          <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">topleft</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">cont</span> <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">tl_ptr</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">top</span> <span class="o">-</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">ldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tdiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">tldiff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">topleft</span> <span class="o">-</span> <span class="n">base</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tdiff</span> <span class="o">&amp;&amp;</span> <span class="n">ldiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">left</span> <span class="p">:</span>
</span><span class="line">                    <span class="n">tdiff</span> <span class="o">&lt;=</span> <span class="n">tldiff</span> <span class="o">?</span> <span class="nl">top</span> <span class="p">:</span> <span class="n">topleft</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>3 种平滑预测的方法如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_startup/smooth_intra_predictors.png" /></p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_smooth_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span>
</span><span class="line">                           <span class="k">const</span> <span class="kt">int</span> <span class="n">max_width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">max_height</span>
</span><span class="line">                           <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_hor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">width</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">weights_ver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dav1d_sm_weights</span><span class="p">[</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">width</span><span class="p">],</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="n">height</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_ver</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="o">*</span> <span class="n">bottom</span> <span class="o">+</span>
</span><span class="line">                                <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)]</span> <span class="o">+</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">256</span> <span class="o">-</span> <span class="n">weights_hor</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pred</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(九)之帧内编码帧内拷贝模式 Intra_Block_Copy]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/16/intra-block-copy/"/>
    <updated>2019-11-16T00:59:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/16/intra-block-copy</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">几个概念</a></li>
</ul>

<p>AV1 允许它的帧内编码器在预测当前块时，反向搜索当前帧中之前已经重建的部分，该方式在某种程度上与帧间编码搜索之前的帧是类似的。
该方法对于屏幕内容的视频压缩非常有效，因为屏幕内容的视频通常会在同一帧中包含相同的文本、字符等内容。</p>

<!--more-->

<h2 id="section">概述</h2>

<p>帧内块拷贝(Intra Block Copy，简称 IntraBC)，除了传统的帧内和帧间预测模式外，IBC 模式采用当前帧中已重建帧作为预测块，可以认为 IntraBC 是当前编码图像内的运动补偿。</p>

<h2 id="section-1">几个概念</h2>

<p>AV1 SPEC 中关于 IntraBC 的几点。</p>

<blockquote>
  <p><strong>allow_intrabc</strong> equal to 1 indicates that intra block copy may be used in this frame. allow_intrabc equal to 0 indicates that intra block copy is not allowed in this frame.<br />
<strong>Note:</strong> intra block copy is only allowed in intra frames, and disables all loop filtering. force_integer_mv will be equal to 1 for intra frames, so only integer offsets are allowed in block copy mode.<br />
<strong>force_integer_mv</strong> equal to 1 specifies that motion vectors will always be integers. force_integer_mv equal to 0 specifies that motion vectors can contain fractional bits.</p>
</blockquote>

<p>allow_intrabc 为1，表示该帧中可能存在 intra block copy，否则不存在。同时，intra block copy 仅仅在帧内编码图像中允许，使用了 intra block copy 的块，禁止任何的滤波。</p>

<blockquote>
  <p><strong>use_intrabc</strong> equal to 1 specifies that intra block copy should be used for this block. use_intrabc equal to 0 specifies that intra block copy should not be used.</p>
</blockquote>

<p>use_intrabc 为 1，表示该宏块使用 intra_block_copy ，否则不使用该方法。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(八)之帧内编码调色板模式 Color Palette]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/14/intra-color-palette-predictor/"/>
    <updated>2019-11-14T08:04:43-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/14/intra-color-palette-predictor</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">调色板模式概述</a></li>
  <li><a href="#color-palette" id="markdown-toc-color-palette">Color Palette</a></li>
</ul>

<p>调色板模式，对于屏幕内容图像，很多编码块内部的颜色数是有限的，调色板模式枚举这些颜色生成颜色表，然后为每个样本传递一个索引以指示它属于颜色表中的哪种颜色。和基于预测-变换的传统编码方法相比，对于颜色数相对集中的屏幕内容图像，调色板模式往往更加有效。</p>

<!--more-->

<h2 id="section">调色板模式概述</h2>

<p>调色板模式将块内的元素当做几种离散的颜色，不同于直接传输像素本身的参数值，而是通过传输色块的颜色编号实现压缩的目的。
AV1 支持从 8x8 到 64x64 的块，支持调色板模式，编码器会自动根据视频内容选择是否使用调色板模式。调色板模式对于当前块
有单一色调的场景十分有用，一般这种场景出现在屏幕内容的压缩当中。</p>

<h2 id="color-palette">Color Palette</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">pal_pred_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">pal</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">pal</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">x</span><span class="p">]];</span>
</span><span class="line">        <span class="n">idx</span> <span class="o">+=</span> <span class="n">w</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D)解码详解(七)之帧间编码 OBMC]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/13/inter-overlapped-block-motion-compensation/"/>
    <updated>2019-11-13T08:04:43-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/13/inter-overlapped-block-motion-compensation</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#obmc-" id="markdown-toc-obmc-">OBMC 概述</a></li>
  <li><a href="#section" id="markdown-toc-section">代码</a></li>
</ul>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<!--more-->

<h2 id="obmc-">OBMC 概述</h2>

<p>OBMC 会使用当前块运动矢量和相邻子块运动矢量进行运动补偿，减少方块效应。OBMC 通过融合相邻块的 Motion Vector 预测，很大程度上降低当前块预测错误。</p>

<h2 id="section">代码</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="nf">obmc</span><span class="p">(</span><span class="n">Dav1dTileContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">t</span><span class="p">,</span>
</span><span class="line">                <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">dst_stride</span><span class="p">,</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">b_dim</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">pl</span><span class="p">,</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">int</span> <span class="n">bx4</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">by4</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">w4</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h4</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bx</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">by</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">));</span>
</span><span class="line">    <span class="k">const</span> <span class="n">Dav1dFrameContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="n">refmvs</span> <span class="o">*</span><span class="k">const</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">mvs</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">by</span> <span class="o">*</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">b4_stride</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bx</span><span class="p">];</span>
</span><span class="line">    <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">lap</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">scratch</span><span class="p">.</span><span class="n">lap</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_ver</span> <span class="o">=</span> <span class="o">!!</span><span class="n">pl</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">DAV1D_PIXEL_LAYOUT_I420</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_hor</span> <span class="o">=</span> <span class="o">!!</span><span class="n">pl</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">layout</span> <span class="o">==</span> <span class="n">DAV1D_PIXEL_LAYOUT_I444</span><span class="p">;</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">h_mul</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="n">ss_hor</span><span class="p">,</span> <span class="n">v_mul</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">&gt;&gt;</span> <span class="n">ss_ver</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">by</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tiling</span><span class="p">.</span><span class="n">row_start</span> <span class="o">&amp;&amp;</span>
</span><span class="line">        <span class="p">(</span><span class="o">!</span><span class="n">pl</span> <span class="o">||</span> <span class="n">b_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h_mul</span> <span class="o">+</span> <span class="n">b_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v_mul</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">))</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">w4</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imin</span><span class="p">(</span><span class="n">b_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">4</span><span class="p">);)</span> <span class="p">{</span>
</span><span class="line">            <span class="c1">// only odd blocks are considered for overlap handling, hence + 1</span>
</span><span class="line">            <span class="k">const</span> <span class="n">refmvs</span> <span class="o">*</span><span class="k">const</span> <span class="n">a_r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">b4_stride</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">a_b_dim</span> <span class="o">=</span>
</span><span class="line">                <span class="n">dav1d_block_dimensions</span><span class="p">[</span><span class="n">sbtype_to_bs</span><span class="p">[</span><span class="n">a_r</span><span class="o">-&gt;</span><span class="n">sb_type</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">a_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">int</span> <span class="n">ow4</span> <span class="o">=</span> <span class="n">iclip</span><span class="p">(</span><span class="n">a_b_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">int</span> <span class="n">oh4</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">b_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                <span class="n">res</span> <span class="o">=</span> <span class="n">mc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ow4</span> <span class="o">*</span> <span class="n">h_mul</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pixel</span><span class="p">),</span> <span class="n">ow4</span><span class="p">,</span> <span class="n">oh4</span><span class="p">,</span>
</span><span class="line">                         <span class="n">t</span><span class="o">-&gt;</span><span class="n">bx</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">by</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">a_r</span><span class="o">-&gt;</span><span class="n">mv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
</span><span class="line">                         <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">refp</span><span class="p">[</span><span class="n">a_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
</span><span class="line">                         <span class="n">dav1d_filter_2d</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">bx4</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bx4</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]);</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class="line">                <span class="n">f</span><span class="o">-&gt;</span><span class="n">dsp</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">blend_h</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">h_mul</span><span class="p">],</span> <span class="n">dst_stride</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span>
</span><span class="line">                                   <span class="n">h_mul</span> <span class="o">*</span> <span class="n">ow4</span><span class="p">,</span> <span class="n">v_mul</span> <span class="o">*</span> <span class="n">oh4</span><span class="p">);</span>
</span><span class="line">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">x</span> <span class="o">+=</span> <span class="n">imax</span><span class="p">(</span><span class="n">a_b_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bx</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">tiling</span><span class="p">.</span><span class="n">col_start</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">h4</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">imin</span><span class="p">(</span><span class="n">b_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="c1">// only odd blocks are considered for overlap handling, hence +1</span>
</span><span class="line">            <span class="k">const</span> <span class="n">refmvs</span> <span class="o">*</span><span class="k">const</span> <span class="n">l_r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">[(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">b4_stride</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">l_b_dim</span> <span class="o">=</span>
</span><span class="line">                <span class="n">dav1d_block_dimensions</span><span class="p">[</span><span class="n">sbtype_to_bs</span><span class="p">[</span><span class="n">l_r</span><span class="o">-&gt;</span><span class="n">sb_type</span><span class="p">]];</span>
</span><span class="line">
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">l_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">int</span> <span class="n">ow4</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">b_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                <span class="k">const</span> <span class="kt">int</span> <span class="n">oh4</span> <span class="o">=</span> <span class="n">iclip</span><span class="p">(</span><span class="n">l_b_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class="line">                <span class="n">res</span> <span class="o">=</span> <span class="n">mc</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">h_mul</span> <span class="o">*</span> <span class="n">ow4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pixel</span><span class="p">),</span> <span class="n">ow4</span><span class="p">,</span> <span class="n">oh4</span><span class="p">,</span>
</span><span class="line">                         <span class="n">t</span><span class="o">-&gt;</span><span class="n">bx</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">by</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">l_r</span><span class="o">-&gt;</span><span class="n">mv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
</span><span class="line">                         <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">refp</span><span class="p">[</span><span class="n">l_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">l_r</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
</span><span class="line">                         <span class="n">dav1d_filter_2d</span><span class="p">[</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">by4</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">.</span><span class="n">filter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">by4</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]);</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class="line">                <span class="n">f</span><span class="o">-&gt;</span><span class="n">dsp</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">blend_v</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">v_mul</span> <span class="o">*</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">dst_stride</span><span class="p">)],</span>
</span><span class="line">                                <span class="n">dst_stride</span><span class="p">,</span> <span class="n">lap</span><span class="p">,</span> <span class="n">h_mul</span> <span class="o">*</span> <span class="n">ow4</span><span class="p">,</span> <span class="n">v_mul</span> <span class="o">*</span> <span class="n">oh4</span><span class="p">);</span>
</span><span class="line">                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">y</span> <span class="o">+=</span> <span class="n">imax</span><span class="p">(</span><span class="n">l_b_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(六)之帧内编码 Chroma_From_Luma]]></title>
    <link href="http://lazybing.github.io/blog/2019/11/12/intra-chrom-from-luma/"/>
    <updated>2019-11-12T14:00:19-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/11/12/intra-chrom-from-luma</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">概述</a></li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 代码</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">结论</a></li>
</ul>

<p>AV1 在帧编码中使用了Chroma_From_Luma 的工具，它是利用视觉图像中亮度值和色度值具有高度相似性的特点，通过选择适当的参数结合重建亮度值来预测色度值，该工具在游戏视频中具有很好地压缩效果。</p>

<!--more-->

<h2 id="section">概述</h2>

<p>Chrom_From_Luma(CFL) 的整个流程可以由下图表示。</p>

<p>当 chroma 分量通过下采样得到时，为使得像素分量一致，重建的 luma 分量需要对应的下采样。之后相应的重建 luma 像素减去平均值，得到 AC 分量。 scale 因子和符号，是通过码流中解码获得。CFL 预测值通过将重建 luma 像素的 AC 分量和 scale 因子相乘，并将结果与帧内的 DC 预测相加得到。如下图所示。</p>

<p><img src="http://lazybing.github.io/images/av1_cfl/chroma_from_luma.png" /></p>

<p>该流程分为三步：</p>

<ol>
  <li>Compute Luma AC Contribution。</li>
  <li>Scale Chroma Plane</li>
  <li>Add Chroma DC_PRED</li>
</ol>

<h2 id="dav1d-">DAV1D 代码</h2>

<p>DAV1D 中关于 CFL 的部分，主要由下面两类函数完成，其中一类就是求 AC Contribution。第二类就是 alpha * AC + DC_PRED。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">dav1d_inta_ped_dsp_init</span><span class="p">(</span><span class="n">Dav1dIntraPredDSPContext</span> <span class="o">*</span><span class="k">const</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I420</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_420_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I422</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_422_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_ac</span><span class="p">[</span><span class="n">DAV1D_PIXEL_LAYOUT_I444</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfl_ac_444_c</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">DC_128_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_128_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">TOP_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_top_c</span><span class="p">;</span>
</span><span class="line">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">cfl_pred</span><span class="p">[</span><span class="n">LEFT_DC_PRED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipred_cfl_left_c</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>关于求 AC Contribution 的函数如下，它根据 YUV 三个分量的组成比例，会有不同的参数传递，但整体思路是一样的.</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cfl_ac_c</span><span class="p">(</span><span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">ypx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">w_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h_pad</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_hor</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ss_ver</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int16_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">ac_orig</span> <span class="o">=</span> <span class="n">ac</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">w_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">w_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">);</span>
</span><span class="line">    <span class="n">assert</span><span class="p">(</span><span class="n">h_pad</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">h_pad</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">h_pad</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">w_pad</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">ac_sum</span> <span class="o">=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">ss_hor</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ss_ver</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">ss_hor</span><span class="p">)</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">ss_hor</span><span class="p">)</span> <span class="n">ac_sum</span> <span class="o">+=</span> <span class="n">ypx</span><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac_sum</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_ver</span> <span class="o">+</span> <span class="o">!</span><span class="n">ss_hor</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">ypx</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">ss_ver</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">memcpy</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">[</span><span class="o">-</span><span class="n">width</span><span class="p">],</span> <span class="n">width</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ac</span><span class="p">));</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">log2sz</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">log2sz</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">sum</span> <span class="o">&gt;&gt;=</span> <span class="n">log2s</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//subtract DC</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">ac</span> <span class="o">=</span> <span class="n">ac_orig</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sum</span><span class="p">;</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define cfl_ac_fn(fmt, ss_hor, ss_ver)  \</span>
</span><span class="line"><span class="cp">    static void cfl_ac_##fmt##_c(int16_t *const ac, const pixel *const ypx, \</span>
</span><span class="line"><span class="cp">                                 const ptrdiff_t stide, const int w_pad, \</span>
</span><span class="line"><span class="cp">                                 const int h_pad, const int cw, const int ch) \</span>
</span><span class="line"><span class="cp">{   \</span>
</span><span class="line"><span class="cp">    cfl_ac_c(ac, ypx, stride, w_pad, h_pad, cw, ch, ss_hor, ss_ver);    \</span>
</span><span class="line"><span class="cp">}</span>
</span><span class="line">
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">422</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line"><span class="n">cfl_ac_fn</span><span class="p">(</span><span class="mi">444</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来是求解 DC PRED 的值以及最终的 Chroma 值。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                       <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class="line">    <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">!=</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">*=</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">height</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="nl">MULTIPLIER_1x4</span> <span class="p">:</span>
</span><span class="line">                                                            <span class="n">MULTIPLIER_1x2</span><span class="p">;</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">&gt;&gt;=</span> <span class="n">BASE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span>
</span><span class="line"><span class="nf">cfl_pred</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span><span class="p">,</span>
</span><span class="line">         <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">ac</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span><span class="line">            <span class="n">dst</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">iclip_pixel</span><span class="p">(</span><span class="n">dc</span> <span class="o">+</span> <span class="n">apply_sign</span><span class="p">((</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">,</span> <span class="n">diff</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">ac</span> <span class="o">+=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line">        <span class="n">dst</span> <span class="o">+=</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                        <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_128_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="cp">#if BITDEPTH == 16</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitdepth_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="cp">#else</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
</span><span class="line"><span class="cp">#endif</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span> <span class="n">stride</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_left</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">++</span> <span class="n">topleft</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">)];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">dc_gen_top</span><span class="p">(</span><span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">topleft</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="n">dc</span> <span class="o">&gt;&gt;</span> <span class="n">ctz</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_left_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                             <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                             <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">dc_gen_left</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">ipred_cfl_top_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="n">pixel</span> <span class="o">*</span><span class="k">const</span> <span class="n">topleft</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int</span> <span class="n">widht</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
</span><span class="line">                            <span class="k">const</span> <span class="kt">int16_t</span> <span class="o">*</span><span class="n">ac</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">alpha</span>
</span><span class="line">                            <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">cfl_pred</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">dc_gen_top</span><span class="p">(</span><span class="n">topleft</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">ac</span><span class="p">,</span> <span class="n">alpha</span> <span class="n">HIGHBD_DECL_SUFFIX</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-1">结论</h2>

<p>AV1 中采用的 Chroma_From_Luma 预测工具，该工具不仅降低了解码器复杂度，同时降低了预测错误率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Doxygen和graphviz使用]]></title>
    <link href="http://lazybing.github.io/blog/2019/07/11/doxygen-graphviz/"/>
    <updated>2019-07-11T06:24:57-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/07/11/doxygen-graphviz</id>
    <content type="html"><![CDATA[<p><code>Doxygen</code>可以从一套归档源文件开始，生成HTML格式的在线浏览器，<code>Graphviz</code>是一个图形化可视化软件。Doxygen 使用 Graphviz 生成各种图形，如类的继承关系图、合作图，头文件包含关系图等。</p>

<!--more-->

<table>
  <thead>
    <tr>
      <th style="text-align: center">EXTRACT_ALL</th>
      <th style="text-align: center">输出所有的函数，但 private 和 static 函数不属于其管制</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">EXTRACT_PRIVATE</td>
      <td style="text-align: center">输出 private 函数</td>
    </tr>
    <tr>
      <td style="text-align: center">EXTRACT_STATIC</td>
      <td style="text-align: center">输出 static 函数，同时还有几个 EXTRACT，相应查看文档即可</td>
    </tr>
    <tr>
      <td style="text-align: center">HAVE_DOT</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(五)之DEBLOCK FILTER]]></title>
    <link href="http://lazybing.github.io/blog/2019/07/10/deblock-filter/"/>
    <updated>2019-07-10T07:07:33-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/07/10/deblock-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析及优化</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">参考资料</a></li>
</ul>

<p>AV1 使用了非常多的环路滤波器工具应用于解码帧。环路滤波的第一个阶段是去块滤波器(Deblocking Filter)。</p>

<!--more-->

<p>AV1 的去块滤波器与 VP9 中使用的滤波器基本相同，只是做了很小的改动————最长滤波从 VP9 的 15 抽头降成了 13 抽头。除了去块滤波器，AV1 还采用了CDEF 滤波器、Loop Restoration 滤波器、Film Grain 滤波器。</p>

<p>去块滤波器(Deblocking Filter, DBF)又称去块效应滤波器，是一种减少在区块边界产生视觉上瑕疵的滤波器。这种视觉瑕疵称为区块效应，这种效应主要构成原因是以区块为基础的编解码器所造成的人造边界，以区块为基底的编解码器（AVC/HEVC/AV1）都会在解码过程中利用去块滤波器将区块效应的影响降低以改善视频影像的质量。</p>

<h3 id="section">介绍</h3>

<p>以区块为基础的编解码器在预测(Prediction)或转换(Transform)编码时，都会将影像分成区块再做编码。因此影像重建时会造成在区块间边缘处不连续的现象，该现象称为去块效应，而这些区块边缘间视觉上的不连续称为人造边界。人造边界的主要成因有两个：</p>

<ul>
  <li>预测时出现不准的地方称为残量(Residual)，残量会利用离散余弦变换做量化，由于量化与反量化会产生误差，因此会在区块边界上产生视觉上的不连续。</li>
  <li>运动补偿，同一个画面内部相邻区块可能不是从前几个编码影像中相邻区块获取来做预测，因此会造成不连续的现象。同样的，画面内预测的方式也可能造成影像不连续。</li>
</ul>

<p>去区块滤波器主要有三个工作，分别是边界强度计算(Boundary Strength Computation)、边界分析(Boundary Analysis)以及滤波器应用(Filter Implementation)。</p>

<ol>
  <li>边界强度计算：主要是去计算边界强度(Boundary Strength, Bs)这个参数，边界强度呈现出相邻区块边界不连续的程序，而这个参数会跟量化的方式、区块类型、移动向量以及边界取样的梯度有关。</li>
  <li>边界分析：因为区块边缘不连续的现象可能真的是对象边缘所产生，并非所谓的人造边界，这个工作主要是判断是否为人造边界。</li>
  <li>滤波器的应用：做完前面两个工作可以决定边界强度以及判断是否真的为人造边界，这个工作主要对人造边界对应的边界强度选择该应用的滤波器。</li>
</ol>

<h3 id="section-1">源码分析及优化</h3>

<p>首先看 DAV1D 中，关于去块滤波的 C 实现函数：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">void</span> <span class="nf">loop_filter_h_sb128y_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">ptrdiff_t</span> <span class="n">stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">vmast</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)[</span><span class="mi">4</span><span class="p">],</span> <span class="kt">ptrdiff_t</span> <span class="n">b4_stride</span><span class="p">,</span>
</span><span class="line">                                    <span class="k">const</span> <span class="n">AvFilterLUT</span> <span class="o">*</span><span class="n">lut</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">vm</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">         <span class="n">y</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="n">l</span> <span class="o">+=</span> <span class="n">b4_stride</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">vm</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">H</span> <span class="o">=</span> <span class="n">L</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">E</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">e</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">I</span> <span class="o">=</span> <span class="n">lut</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">[</span><span class="n">L</span><span class="p">];</span>
</span><span class="line">            <span class="k">const</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="o">!!</span><span class="p">(</span><span class="n">vmask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">loop_filter</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">PXSTRIDE</span><span class="p">(</span><span class="n">stride</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面只是给出 Y 分量上的 水平滤波函数，从上面给出的 C 实现看，要实现 NEON 优化，并不简单，但如果再看它的汇编优化，简直太聪明了，在 DAV1D 发布0.3版本时，官方就称，仅仅去块滤波这一个模块，解码 8bit 流时，解码效率提升7%~34%之高。
后来我自己实现 10bit NEON 优化时，因为寄存器个数的限制（10bit，一个128位寄存器只能存放8个像素;而8bit，一个128位寄存器可存放16个像素），简码效率也有至少5%的提升。当时仿照 8bit 实现时，感慨汇编的技巧使用，惊为天人！</p>

<h3 id="section-2">参考资料</h3>

<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%8E%BB%E5%8D%80%E5%A1%8A%E6%BF%BE%E6%B3%A2%E5%99%A8">去块滤波器</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之性能分析工具perf]]></title>
    <link href="http://lazybing.github.io/blog/2019/05/17/perf/"/>
    <updated>2019-05-17T08:43:15-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/05/17/perf</id>
    <content type="html"><![CDATA[<p>本文主要记录性能优化工具 perf 的方法技巧。</p>

<!--more-->

<p><strong>perf</strong>有些子命令：</p>

<ul>
  <li>stat: 测试单个程序的事件总数。</li>
  <li>top:类似top命令，动态显示最耗时的函数。</li>
  <li>record:测试并保存单个程序的抽样数据。</li>
  <li>report:分析由 perf record 命令生成的文件，可以生成 flat 或 graph profile   文件。</li>
  <li>annotate:annotate源文件或汇编。</li>
  <li>sched:调度程序操作和延迟的追踪和测量。</li>
  <li>list:列出可能的事件。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之分支预测]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/26/branch-predictor/"/>
    <updated>2019-04-26T08:58:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/26/branch-predictor</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">预测种类</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">程序示例</a></li>
</ul>

<p>分支预测是在分支指令执行结束之前猜测哪一路分支将会被执行，以提高处理器的指令流水线的性能。使用分支预测器的目的，在于改善指令管线化的流程。</p>

<!--more-->

<h2 id="section">预测种类</h2>

<ul>
  <li>
    <p>静态预测：最简单的分支预测技术，不依赖于代码执行的动态历史信息。静态预测可以再次细分，有的是总是预测条件跳转不发生，有的假定向后分支将会发生，向前的分支不发生。向后分支是指跳转到的新地址总比当前地址要低。</p>
  </li>
  <li>
    <p>双模特预测器：该预测器是一种有 4 个状态的状态机：强不选择、弱不选择、弱选择、强选择。当一个分支命令被求值，对应的状态机被修改。分支不采纳，则向“强不选择”方向降低状态值；如果分支被采纳，则向“强选择”方向提高状态值。</p>
  </li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/saturating_counter-dia.png" /></p>

<ul>
  <li>两级自适应预测器：对于一条分支指令，如果每 2 次执行发生一次条件跳转，或者其他的规则发生模式，那么用上文提到的双模态预测器就很难预测了。如图所示，一种两级自适应预测器可以记住过去 n 次执行指令时的分支情况的历史，可能的 2^n 种历史模式的每一种都有 1 个专用的双模态预测器，用来表示如果刚刚过去的 n 次执行历史是此种情况，那么根据这个双模态预测器预测为跳转还是不跳转。</li>
</ul>

<p><img src="http://lazybing.github.io/images/branch_predictor/Two-level_branch_prediction.png" /></p>

<h2 id="section-1">程序示例</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line"><span class="cp">#include &lt;chrono&gt;</span>
</span><span class="line"><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line">
</span><span class="line"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">arraySize</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">        <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">arraySize</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">){</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">               <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class="line">    <span class="kt">double</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">())</span><span class="o">*</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">num</span><span class="o">/</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">den</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;const total &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; sec&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的双重 for 循环，如果对数组不排序、或者修改循环体内的条件语句为</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="o">++</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="mi">128</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">;</span>
</span><span class="line">        <span class="n">sum</span> <span class="o">+=</span> <span class="o">~</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>三种相同功能的代码，耗时如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">代码结构</th>
      <th style="text-align: center">耗时</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">不排序</td>
      <td style="text-align: center">26.27s</td>
    </tr>
    <tr>
      <td style="text-align: center">排序</td>
      <td style="text-align: center">9.87s</td>
    </tr>
    <tr>
      <td style="text-align: center">不分支预测</td>
      <td style="text-align: center">10.97s</td>
    </tr>
  </tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之利用局部性原理]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/21/locality-of-reference/"/>
    <updated>2019-04-21T02:56:40-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/21/locality-of-reference</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">局部性示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">局部性原理</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">存储器层次结构</a></li>
</ul>

<p>局部性原理是指程序通常倾向于引用邻近于其最近引用过的数据项的数据项，或最近引用过的数据本身。</p>

<!--more-->

<h2 id="section">局部性示例</h2>

<p>先看下面两个对数组访问的示例，</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define ARRAY_ROW_SIZE 1000</span>
</span><span class="line"><span class="cp">#define ARRAY_COL_SIZE 1000</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_col</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">access_array_row</span><span class="p">(</span><span class="kt">int</span> <span class="n">array1</span><span class="p">[</span><span class="n">ARRAY_ROW_SIZE</span><span class="p">][</span><span class="n">ARRAY_COL_SIZE</span><span class="p">])</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_ROW_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ARRAY_COL_SIZE</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">array1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<table>
  <thead>
    <tr>
      <th style="text-align: center">used time</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">access_array_row</td>
      <td style="text-align: center">3521</td>
      <td style="text-align: center">4287</td>
      <td style="text-align: center">4741</td>
    </tr>
    <tr>
      <td style="text-align: center">access_array_col</td>
      <td style="text-align: center">12389</td>
      <td style="text-align: center">10713</td>
      <td style="text-align: center">11985</td>
    </tr>
  </tbody>
</table>

<p>从上面的例子可以看出，同样是访问一个数组，采用列访问和采用行访问，事件相差非常大，原因就是<code>access_array_row</code>利用局部性原理。</p>

<h2 id="section-1">局部性原理</h2>

<p>局部性主要包括两种形式，时间局部性和空间局部性。</p>

<ul>
  <li>时间局部性：被引用过一次的存储器位置很可能在不远的将来再被多次引用。</li>
  <li>空间局部性：如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。</li>
</ul>

<p>有良好局部性的程序比局部性差的程序运行得更快，计算机系统设计中，局部性原理在硬件和软件中都有应用，硬件层上，采用了<strong>高速缓存存储器</strong>充分利用了局部性原理；软件层上，操作系统用主存来缓存硬盘文件系统。</p>

<h2 id="section-2">存储器层次结构</h2>

<p>局部性原理在存储器中使用特别频繁。</p>

<p><img src="http://lazybing.github.io/images/locality/locality.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之减少调用]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call/"/>
    <updated>2019-04-19T09:59:18-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">简单函数处理</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数处理</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">减少调用后续优化</a></li>
    </ul>
  </li>
  <li><a href="#section-3" id="markdown-toc-section-3">总结</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">参考资料</a></li>
</ul>

<p>函数调用会带来相当大的开销，而且它会阻碍其他形式的程序优化。单独的较少调用次数可能对性能提升并不明显，但考虑到减少调用后，可以进一步进行其他形式的优化，减少函数调用还是很有必要的。</p>

<!--more-->

<h2 id="section">简单函数处理</h2>

<ul>
  <li>
    <p>直接将函数展开，写入调用函数处，去掉调用函数。</p>
  </li>
  <li>
    <p>使用<strong>inline</strong>关键字，将经常调用的函数写成内联函数。</p>
  </li>
  <li>
    <p>使用<strong>define</strong>关键字，使得代码在编译时将其展开。</p>
  </li>
</ul>

<p>例如，下面的函数调用</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>可以使用上面提到的三种优化方式：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">// method 1</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="c1">//method 2</span>
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">imin</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">imin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span><span class="line"><span class="c1">//method 3</span>
</span><span class="line"><span class="cp">#define IMIN(a, b) return ((a) &lt; (b) ? (a) : (b))</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">IMIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-1">函数处理</h2>

<p>上面的方法针对小函数、频繁调用的情况较试用，当函数较复杂时，我们就不适合直接展开了，那样会显得整个代码特别繁琐；另外如果被调用函数并不是我们自己的代码，就更没办法用上面提到的方法了。此时，就要分析函数的功能，选择替代方案减少调用。举个例子：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="n">vec_rec</span><span class="p">,</span> <span class="o">*</span><span class="n">vec_ptr</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">vec_ptr</span> <span class="nf">new_vec</span><span class="p">(</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">vec_ptr</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec_ptr</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">vec_rec</span><span class="p">));</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">result</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">data_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">data_t</span><span class="p">));</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">){</span>
</span><span class="line">            <span class="n">free</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">);</span>
</span><span class="line">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class="line">        <span class="n">result</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">get_vec_element</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">long</span> <span class="kt">int</span> <span class="nf">vec_length</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">data_t</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">        <span class="n">get_vec_element</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>上面的<code>combine2</code>函数的 for 循环中会一直调用 <strong>get_vec_element</strong>函数来获取一个元素，通过分析该函数可以看出，它获取的其实是<strong>vec_rec.v-&gt;data</strong>数组的元素，该元素也是随着循环索引<strong>i</strong>来递增的，因此可以把该函数提到<strong>for</strong>循环的外面，减少函数调用，修改后的函数如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">data_t</span> <span class="o">*</span><span class="nf">get_vec_start</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">combine2_reducing_proc_call</span><span class="p">(</span><span class="n">vec_ptr</span> <span class="n">v</span><span class="p">,</span> <span class="kt">data_t</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">vec_length</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">    <span class="kt">data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">get_vec_start</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">IDENT</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">+</span> <span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>分析上面的优化，其实它是破坏了函数的结构的，这种方法会损害函数的模块性和抽象性，上面的例子中，我们是通过分析<code>get_vec_element</code>函数和<code>for</code>循环才确定的减少调用是可用的。</p>

<h3 id="section-2">减少调用后续优化</h3>

<p>上面提到的都是针对减少调用本身来提升性能的，减少调用本身对系统性能的提升非常有限，但减少调用后，可以方便的进行进一步的优化，而进一步的优化可能效果非常显著。例如上面提到的 combine 函数，将调用函数提取到 for 循环外后，可以对整个 for 循环进行 NEON 优化，效率的提升会更加明显。</p>

<p>在做 AV1 效率优化时，也遇到过类似的优化案例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define add_noise_y(x, y, grain)    \</span>
</span><span class="line"><span class="cp">    pixel *src = src_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    pixel *dst = dst_row + (y) * stride + (bx + x);  \</span>
</span><span class="line"><span class="cp">    int noise  = round2(scaling[ *src ] * (grain), data-&gt;scaling_shift); \</span>
</span><span class="line"><span class="cp">    *dst = iclip(*src + noise, min_value max_value);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">bh</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bw</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">grain</span> <span class="o">=</span> <span class="n">sample_lut</span><span class="p">(</span><span class="n">grain_lut</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span><span class="line">            <span class="n">add_noise_y</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grain</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>未优化前，此段代码在解码过程中，大概耗时 8ms，优化完成后，降低到 7ms，效率提升了 12.5%。提升还是很大的。</p>

<h2 id="section-3">总结</h2>

<h2 id="section-4">参考资料</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之循环展开]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/17/loop-unroll/"/>
    <updated>2019-04-17T07:36:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/17/loop-unroll</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例分析</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">循环展开扩展</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结论总结</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">参考资料</a></li>
</ul>

<p>循环展开是通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开只能针对整形加法和乘法的性能改进。</p>

<!--more-->

<p>循环展开从两个方面改变程序的性能：</p>

<ul>
  <li>分支预测失败减少。</li>
  <li>减少不直接有助于程序结果的操作的数量，如循环索引计算和条件分支。</li>
  <li>提供了一种方法，可以进一步变换代码，减少整个计算中关键路径上的操作数量。</li>
</ul>

<h2 id="section">示例分析</h2>

<figure class="code"><figcaption><span>loop_unrolling.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span><span class="p">;</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll1</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll2</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll3</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>运行上面的程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -funroll-loops -pg loop_unrolling.c -o loop_unrolling</span></code></pre></td></tr></table></div></figure>

<p>执行三次后，结果如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Executions</th>
      <th style="text-align: center">loop_unroll1</th>
      <th style="text-align: center">loop_unroll2</th>
      <th style="text-align: center">loop_unroll3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">12618</td>
      <td style="text-align: center">1890</td>
      <td style="text-align: center">3162</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7456</td>
      <td style="text-align: center">1987</td>
      <td style="text-align: center">1629</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">9868</td>
      <td style="text-align: center">2446</td>
      <td style="text-align: center">2388</td>
    </tr>
  </tbody>
</table>

<p>上面的结果可以看出，产开次数为2相对于未展开时，性能有明显提升，但展开次数为4时，性能相对于展开次数为2并没有多少提升。另外，编译器选项<code>-funroll-loops</code>好像并没有起到什么作用。但是如果添加编译选项<code>-O1</code>或<code>-O2/-O3</code>时，编译器会自动优化该函数。</p>

<p>关于展开次数和性能之间的关系，CSAPP 这本书里有介绍一个实验结果，如图所示：</p>

<p><img src="http://lazybing.github.io/images/loop_unroll/loop_unrolling.png" /></p>

<p>从图中可以看出，当循环展开到6次时的CPE(Cycles Per Element,每元素的周期数)测量值，对于展开2次或3次时观察到的趋势还在继续——循环展开对浮点数运算没有帮助，但对整数加法和乘法，CPE降至1.00.</p>

<p>实验过程中发现，CSAPP中描述的结论与我自己测试的结果有几点需要注意：</p>

<ol>
  <li>测试中，循环展开对于浮点数的加法和乘法是有效的。</li>
  <li>编译器选项<code>-funroll-loops</code>并没有起到循环展开的作用。</li>
  <li>循环展开对于性能的提升确实是都有帮助的。</li>
</ol>

<h2 id="section-1">循环展开扩展</h2>

<p>循环展开的本质是降低循环开销、增加并行运行的可能性。网上找到的大部分讲解循环展开的都是针对<strong>for</strong>循环的，既然是循环展开，那么对于<strong>while</strong>循环，理论上也是适用的，最后找到了<a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling</a>。关于<strong>while</strong>循环展开的方法，可以用下面的描述语言表示：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">while B do S; &lt;==&gt; while B ^ wp(S, B) do begin S;S end; while B do S;</span></code></pre></td></tr></table></div></figure>
<p>按照论文的讲解，手动写了两个替换的等价循环</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>遗憾的是，运行后，两者的时间并没有太大的差别，有时第二段代码方法甚至更慢。猜测可能原因有两点：现代编译器对此类优化方法已经完成的很好；不同运行环境运行效果不同；所以，循环展开这类方法，最好是实际操作运行看结果，理论与实际可能有出入。</p>

<h2 id="section-2">结论总结</h2>

<p>循环展开对于性能的提升是由帮助的，但这种帮助并不是无限的，随着展开次数的增多，性能并不会继续增加，相反，循环展开次数过多，会使得程序代码膨胀、代码可读性降低。另外，编译器优化选项<code>-O1</code>或<code>-O2</code>等，会使得编译器自身会对代码进行优化，此时手动循环展开并不是一个好的方法。再者，受运行环境的影响（我的测试用例都是在Ubuntu虚拟机下完成），其测试结果可能有不同。</p>

<h2 id="section-3">参考资料</h2>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80">循环展开</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop Unrolling</a></li>
  <li><a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling: a Method for Program Speed-Up</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/37582101">C++性能榨汁机之循环展开</a></li>
  <li><a href="https://github.com/shihyu/CSAPP2e/blob/master/Computer%20Systems%20-%20A%20Programmer's%20Perspective%20(2nd).pdf">Computer Systems - A Programmer’s Perspective</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之vallgrind之callgrind分析瓶颈]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/15/profiler/"/>
    <updated>2019-04-15T08:08:54-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/15/profiler</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#callgrind-" id="markdown-toc-callgrind-">Callgrind 概述</a>    <ul>
      <li><a href="#section" id="markdown-toc-section">主要功能</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">基本使用方法</a></li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">高级使用方法</a>    <ul>
      <li><a href="#profile-" id="markdown-toc-profile-">生成多个 profile 文件</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">限制收集事件的范围</a></li>
    </ul>
  </li>
  <li><a href="#callgrind--1" id="markdown-toc-callgrind--1">Callgrind 命令行选项</a>    <ul>
      <li><a href="#dump-" id="markdown-toc-dump-">dump 生成选项</a></li>
      <li><a href="#activity-" id="markdown-toc-activity-">activity 选项</a></li>
      <li><a href="#data-collection-" id="markdown-toc-data-collection-">data collection 选项</a></li>
      <li><a href="#cost-entity-separations-" id="markdown-toc-cost-entity-separations-">cost entity separations 选项</a></li>
      <li><a href="#simulation-" id="markdown-toc-simulation-">simulation 选项</a></li>
      <li><a href="#cache-simulation-" id="markdown-toc-cache-simulation-">cache simulation 选项</a></li>
    </ul>
  </li>
  <li><a href="#callgrindannotate-" id="markdown-toc-callgrindannotate-">callgrind_annotate 命令行选项</a></li>
  <li><a href="#callgrindcontrol-" id="markdown-toc-callgrindcontrol-">callgrind_control 命令行选项</a></li>
</ul>

<p>对程序进行性能优化的前提是知道程序性能瓶颈在哪里。本文记录 vallgrind 工具之 callgrind 来测试程序性能。</p>

<!--more-->

<p>在优化 AV1 解码库时，使用 callgrind 和 kcachegrind 来检测程序性能，下面先给出测试结果，然后用一个小的程序进行逐步分析。</p>

<p><img src="http://lazybing.github.io/images/valgrind_callgrind/valgrind_callgrind_dav1d.png" /></p>

<h2 id="callgrind-">Callgrind 概述</h2>

<p>使用该工具，必须在使用 valgrind 命令行时指定工具<code>--tool=callgrind</code>。</p>

<p>callgrind 是一个性能剖析工具，它记录一个程序运行时函数间调用历史。默认状态下，收集到的数据包括执行指令的个数、指令与源码行的对应关系、函数间调用和被调用的关系以及调用次数。除此外，模拟缓存和分支预测可能会产生更多关于应用程序运行的信息。</p>

<p>分析的数据在程序结束时会写到一个文件中。用于显示数据以及剖析互动控制，有如下两个命令 <strong>callgrind_annotate</strong> 和 <strong>callgind_control</strong>。</p>

<ul>
  <li><strong>callgrind_annotate</strong> 该命令读取 profile 数据，将函数占用时间打印出来，也可以使用图形化工具 Kcachegrind。</li>
  <li><strong>callgrind_control</strong> 该命令在执行 callgrind 时，使我们可以交互的观察和控制当前运行程序的状态，而不用停止该程序。可以用该命令获取统计信息以及当前堆栈跟踪信息。</li>
</ul>

<h3 id="section">主要功能</h3>

<p><strong>cachegrind</strong> 主要是收集 flat profile 数据：数据读取和 cache 命中率等事件发生的次数直接归因于它们发生的函数。这种归因机制称为自我归因或独占归因。</p>

<p><strong>callgrind</strong> 通过跨越函数调用边界的成本将 cachegrind 的功能进行扩展。如果函数 <strong>foo</strong> 调用 <strong>bar</strong>,从 <strong>bar</strong> 返回的消耗算到 <strong>foo</strong> 消耗里。当作为一只整体应用到程序中时，这就构建成了一个所谓的包容性成本的图片，即，每个函数的消耗包括它直接调用或间接调用的函数的消耗。</p>

<p>比如，main 函数的包容性消耗应该接近整个程序消耗的 100%。因为在调用 main 函数前，还会有其他初始的运行时间，因此最终的消耗只是接近 100%。</p>

<p>同调用图一起，可以清晰的看到从 main 开始的整个调用链，调用链上会清晰的给出程序主要消耗在什么地方。函数调用对剖析函数也是非常有用的，优化的机会一般取决于更改调用者的代码，尤其是降低调用次数。</p>

<p>callgrind 的 cache 模拟是基于 cachegrind 基础之上的。接下来的描述都是在 cachegrind 的特性基础之上进行的。</p>

<p>callgrind 的主要功能是依据它运行平台的指令集，检测函数调用和返回，它能很好地运行在 x86 和 amd64 平台上，但不幸的是在 ARM、PowerPC 或 MIPS平台上运行的并不好，因为这些平台上没有明确的调用和返回指令。</p>

<h3 id="section-1">基本使用方法</h3>

<p>和 cachegrind 一样，必须在编译时添加<code>-g</code>选项来获取调试信息，并且要将优化选项打开。启动剖析程序，只需执行如下命令：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">valgrind --tool=callgrind [callgrind options] your-program [program options]</span></code></pre></td></tr></table></div></figure>

<p>程序运行过程中，想要观察执行情况，只需要执行如下命令<code>callgrind_control -b</code>。</p>

<p>程序运行完成后，会生成一个名为<code>callgrind.out.&lt;pid&gt;</code>的文件，其中 pid 就是程序的线程 ID。该文件就包含了程序执行过程中各个函数的调用情况以及指令读取(<strong>Instruction Read(Ir)</strong>)情况。</p>

<p>想要从 profile 数据文件中生成函数的总结，使用<code>callgrind_annotate [options] callgrind.out.&lt;pid&gt;</code>。该命令与 cachegrind 中的<code>cg_annotate</code>类似，函数会按照消耗排序。callgrind 的额外的重要的特性是如下两个选项：</p>

<ul>
  <li><code>--inclusive=yes</code>:使用该选项后，会使用并显示包容性消耗的函数排序，而不是独立性消耗的排序。</li>
  <li><code>--tree=both</code>:</li>
</ul>

<h2 id="section-2">高级使用方法</h2>

<h3 id="profile-">生成多个 profile 文件</h3>

<p>有些时候，我们对完成程序运行的特性并不关心，而只是关注其中很小的一部分，比如执行某个算法。如果有多个算好或一个算法有不同的输入数据，一个单独程序运行的不同部分的 profile 数据是非常有用的。profile 数据文件有如下形式的名字<code>callgrind.out.pid.part-threadID</code>。</p>

<p>dump 多个 profile 文件的方法和形式有多种，举例如下：</p>

<ul>
  <li><strong>Dump on program termination</strong>, 该方法就是标准的方法，不需要额外的做任何操作。</li>
  <li><strong>Spontaneous,interactive dumping</strong>，使用<code>callgrind_control -d [hint [PID/Name]]</code>来使得 profile 信息的dump带有 PID 或 Name。hint 是可以随意指定的字符串用于区分 profile dump 文件。dump 结束前，控制程序不会停止。注意，为例检测 dump 命令，应用程序必须处于运行态。如果你使用的是<code>Kcachegrind</code>，想要查看 profile 信息，可以使用工具栏按钮<strong>Force dump</strong>，就会发起一个 dump 请求。</li>
  <li><strong>Periodic dumping after execution of a apecified number of basic blocks</strong>，使用<code>--dump-every-bb=count</code>选项。</li>
  <li><strong>Dumping at enter/leave of specified functions</strong>。使用<code>--dump-before=function</code>和<code>--dump-after=function</code>选项。想要在进入某个函数前清零计数器，使用<code>--zero-before=function</code>选项。针对不同的函数，可以多次使用该选项。而且函数名可以使用如下形式<code>--dump-before='foo*'</code>，它会为每个函数名的开头为 foo 的函数生成 dump 文件。</li>
  <li><strong>Program controlled dumping</strong>。在需要 dump profile 发送的代码中插入<code>CALLGRIND_DUMP_STATS</code>。使用<code>CALLGRIND_ZERO_STATS</code>清零 profile 计数器。</li>
</ul>

<p>如果你正运行一个多线程应用程序，在命令行使用<code>--separate-threads=yes</code>选项，每个线程都会生成单独的 profile 文件。因此上面的最后两种方法只会生成当前运行线程生成的 dump 文件，其他方法，则会为每个线程生成多个dump文件。</p>

<h3 id="section-3">限制收集事件的范围</h3>

<p>默认情况下，当事件发生时(比如指令执行或cache命中或未命中)，callgrind 即可将这些事件计入事件计数器。但有时我们只对某个特定的函数或者一段程序代码感兴趣，函数或某段代码结束后，就不在将额外的部分计入事件计数器。</p>

<h2 id="callgrind--1">Callgrind 命令行选项</h2>

<h3 id="dump-">dump 生成选项</h3>

<ul>
  <li><code>--callgrind-out-file=&lt;file&gt;</code>选项影响 profile 数据文件的名称和格式，该选择指定 profile 数据写到 file 中而不是默认的输出文件<code>callgrind.out.&lt;pid&gt;</code>文件。</li>
  <li><code>--dump-line=&lt;no|yes&gt; [default:yes]</code>,该选项指定事件计数应该以源码行执行。这对于编译时带有调试信息的源码。</li>
  <li><code>--dump-instr=&lt;no|ys&gt; [default:no]</code>, 该选项指定事件计数应该以指令执行。这允许汇编。当前结果可以通过 KCachegrind 显示。</li>
  <li><code>--compress-strings=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定文件和函数名是否用数字区分。他会压缩文件，但使得更加难以读取。</li>
  <li><code>--compress-pos=&lt;no|yes&gt; [default:yes]</code>，该选项会影响 profile 数据的输出格式。它指定数字位置是绝对值还是相对值。</li>
  <li><code>--combine-dumps=&lt;no|yes&gt; [default:no]</code>, 不推荐，使能该选项后，多个 profile 数据会追加到同一个输出文件。</li>
</ul>

<h3 id="activity-">activity 选项</h3>

<p>这类选项指定与事件计数相关的行为什么时候发生。对于交互控制，使用 callgrind_control 控制。</p>

<ul>
  <li><code>--dump-every-bb=&lt;count&gt; [default:0, never]</code>，Dump profile data every count basic blocks。</li>
  <li><code>--dump-before=&lt;function&gt;</code>，进入函数前 dump。</li>
  <li><code>--zero-before=&lt;function&gt;</code>, 进入函数前清零所有消耗统计。</li>
  <li><code>--dump-after=&lt;function&gt;</code>, 推出函数时 dump。</li>
</ul>

<h3 id="data-collection-">data collection 选项</h3>

<p>此类选项指定何时将事件聚合到事件计数中。</p>

<ul>
  <li><code>--instr-atstart=&lt;yes|no&gt; [default:yes]</code>，</li>
  <li><code>--collect-atstart=&lt;yes|no&gt; [default:yes]</code>,</li>
  <li><code>--toggle-collect=&lt;fucntion&gt;</code>,</li>
  <li><code>--collect-jumps=&lt;no|yes&gt; [default:no]</code></li>
  <li><code>--collect-systime=&lt;no|yes&gt; [default:no]</code>, 该选项指定系统调用的信息是否要被收集。</li>
  <li><code>--collect-bus=&lt;no|yes&gt; [default:no]</code>, 该选项指定全局总线事件的数量是否被收集。</li>
</ul>

<h3 id="cost-entity-separations-">cost entity separations 选项</h3>

<h3 id="simulation-">simulation 选项</h3>

<ul>
  <li><code>--cache-sim=&lt;yes|no&gt; [default:no]</code>,该选项指定是否做高速缓存模拟。默认情况下，只有指令读访问才会被计数(<strong>Ir</strong>)。如果启动高速缓存模拟，会有更多的事件被计数：指令读取的高速缓存命中率(<strong>I1mr/ILmr</strong>)，数据读取访问(<strong>Dr</strong>)以及相关的数据读取缓存miss(<strong>D1mr/DLmr</strong>),写数据访问(<strong>Dw</strong>)以及相关的cache misses(<strong>D1mw/DLmw</strong>)。</li>
  <li><code>--branch-sim=&lt;yes|no&gt;[default:no]</code>,该选项指定是否做分支预测模拟。使能该选项后，会有更多的事件计数被启动：执行分支预测的数量以及相关的分支miss(<strong>Bc/Bcm</strong>)，执行的间接跳跃和相关的跳转地址预测的miss(<strong>Bi/Bim</strong>)。</li>
</ul>

<h3 id="cache-simulation-">cache simulation 选项</h3>

<ul>
  <li><code>--simulate-wb=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对写块行为进行模拟。</li>
  <li><code>--simulate-hwpref=&lt;yes|no&gt; [default:no]</code>，该选项指定是否对硬件预取器的模拟。</li>
  <li><code>--cacheuse=&lt;yes|no&gt;[default:no]</code>,该选择指定是否对高速缓存行的使用进行收集。</li>
  <li><code>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>或<code>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt;</code>。</li>
</ul>

<h2 id="callgrindannotate-">callgrind_annotate 命令行选项</h2>

<ul>
  <li><code>--show=A,B,C [default:all]</code>, only show figures for events A, B, C.</li>
  <li><code>--sort=A,B,C</code>,sort columns by events A, B, C[event column order], Optionally, each event is followed by a : and a threshold, to specify different thresholds depending on the event.</li>
  <li><code>--threshold=&lt;0--100&gt; [default:99%]</code>, Percentage of counts(of primary sort event) we are interested in.</li>
  <li><code>--auto=&lt;yes|no&gt; [default: no]</code>, Annotate all source files containing functions that helped reach the event count threshold..</li>
  <li><code>--context=N [default: 8]</code>, Print N lines of context before and after annotated lines.</li>
  <li><code>--inclusive=&lt;yes|no&gt; [default: no]</code>, Add subroutine costs to functions calls.</li>
  <li><code>--tree=&lt;none|caller|calling|both&gt; [default: none]</code>, Print for each function their callers, the called functions or both..</li>
  <li><code>-I, --include=&lt;dir&gt;</code>, Add dir to the list of directories to search for source files.</li>
</ul>

<h2 id="callgrindcontrol-">callgrind_control 命令行选项</h2>

<p>(未完待续。。。)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之性能分析工具gprof]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/13/profiler-gprof/"/>
    <updated>2019-04-13T09:52:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/13/profiler-gprof</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gprof">Gprof</a> 是一个 Unix 应用程序性能分析工具。
<!--more--></p>

<h2 id="gprof-">gprof 概述</h2>

<p><a href="https://sourceware.org/binutils/docs/gprof/index.html">Profiling</a> 可以使我们看到程序运行时程序的调用关系、函数的消耗时长等。这些信息可以使我们了解程序中那块代码耗时高于预期。</p>

<p>使用 Profiling 主要包括如下三步：</p>

<ul>
  <li>
    <p>编译链接程序时要使能 profiling 。</p>
  </li>
  <li>
    <p>执行编译处的可执行文件，产生 profile 数据文件。</p>
  </li>
  <li>
    <p>使用 gpro 分析 profile 数据。</p>
  </li>
</ul>

<p>根据产生的 profile ，可以产生各种不同实行的分析输出。如 The Flat Profile、The Call Graph、The Annotated Source Listing。</p>

<h2 id="gprof--1">gprof 示例代码</h2>

<p>示例分析：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun2</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10240</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun1</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">fun2</span><span class="p">();</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2048</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">sum</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">fun1</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译，注意要添加<code>-pg</code>选项，这样才能与后面的 gprof 结合使用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -pg -o test test.c</span></code></pre></td></tr></table></div></figure>

<p>执行, 执行完毕后，会生成 gmon.out 文件，用于性能分析的文件。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">./test</span></code></pre></td></tr></table></div></figure>

<p>分析, 使用 gprof 分析。</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gprof test gmon.out &gt; analysis.txt</span></code></pre></td></tr></table></div></figure>

<p>此时生成的分析文件 analysis.txt 中有两种形式的分析数据。</p>

<h3 id="flat-profile-">Flat Profile 示例图</h3>

<p>Flat Profile 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Flat_profile.png" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标注</th>
      <th style="text-align: center">释义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">%time</td>
      <td style="text-align: center">每个函数占用的时间比例，所有函数占比和为100%</td>
    </tr>
    <tr>
      <td style="text-align: center">cumulative seconds</td>
      <td style="text-align: center">函数及其调用函数执行累计占用时间</td>
    </tr>
    <tr>
      <td style="text-align: center">self seconds</td>
      <td style="text-align: center">单独函数执行累计占用时间</td>
    </tr>
    <tr>
      <td style="text-align: center">calls</td>
      <td style="text-align: center">函数调用次数</td>
    </tr>
    <tr>
      <td style="text-align: center">self ms/call</td>
      <td style="text-align: center">每次调用函数花费的时间,单位毫秒, 不包含调用函数运行的时间</td>
    </tr>
    <tr>
      <td style="text-align: center">total ms/call</td>
      <td style="text-align: center">每次调用函数花费的时间,单位毫秒,包括调用函数运行的时间</td>
    </tr>
    <tr>
      <td style="text-align: center">name</td>
      <td style="text-align: center">函数名称</td>
    </tr>
  </tbody>
</table>

<h3 id="call-graph-">Call Graph 示例图</h3>

<p>Call Graph 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Call_graph.png" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标注</th>
      <th style="text-align: center">释义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">index</td>
      <td style="text-align: center">每个函数第一次出现时分配一个编号，根据编号可以方便查找函数的具体分析数据</td>
    </tr>
    <tr>
      <td style="text-align: center">%time</td>
      <td style="text-align: center">函数以及调用子函数所占用的总运行时间的百分比</td>
    </tr>
    <tr>
      <td style="text-align: center">self</td>
      <td style="text-align: center">函数的总运行时间</td>
    </tr>
    <tr>
      <td style="text-align: center">children</td>
      <td style="text-align: center">子函数执行的总时间</td>
    </tr>
    <tr>
      <td style="text-align: center">called</td>
      <td style="text-align: center">函数被调用的次数，不包括递归调用</td>
    </tr>
    <tr>
      <td style="text-align: center">name</td>
      <td style="text-align: center">函数名称, name 列中，可查看函数之间的调用关系</td>
    </tr>
  </tbody>
</table>

<h2 id="section">参考资料</h2>
<ol>
  <li><a href="https://computing.llnl.gov/tutorials/performance_tools/">Performance Analysis Tools</a></li>
  <li><a href="https://sourceware.org/binutils/docs/gprof/">GNU gprof</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(四)之LOOP RESTORATION]]></title>
    <link href="http://lazybing.github.io/blog/2019/03/02/loop-restoration/"/>
    <updated>2019-03-02T18:02:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/03/02/loop-restoration</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#switchable-restoration-framework" id="markdown-toc-switchable-restoration-framework">switchable restoration framework(可切换的恢复框架)</a></li>
  <li><a href="#wiener-filter-" id="markdown-toc-wiener-filter-">Wiener Filter 维纳滤波器</a></li>
  <li><a href="#selfguided-filter-" id="markdown-toc-selfguided-filter-">Selfguided Filter 自导向投影滤波器</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p>LOOP RESTORATION，环内重建滤波器，是一个重要的增强图像质量处理方法。它包含了两种滤波器，编码器会从两者中选择其一。Wiener Filter(维纳滤波器)采用可分离的对称设计。SelfGuided(自导向投影滤波器)使用两个重建信号的线性组合来近似真实信号。编码器通过比较滤波结果，选择合适的参数，并传输给解码器。</p>

<!--more-->

<p>图像重建是一个比较成熟的领域，它包含了很多专业技术可用，比如 deblocking、deblurring、deringring、debanding、denoising、constrast enhancement、sharpening 和 resolution enhancement。</p>

<h2 id="switchable-restoration-framework">switchable restoration framework(可切换的恢复框架)</h2>

<p>在<code>AV1</code>中实现的 restoration 工具是可切换的恢复框架，该框架中 restoration 工具在每个 tile 之间切换。restoration 的 tile size 是可选的，包括<code>256x256</code>、<code>128x128</code>、<code>64x64</code>。通常情况下，对高分辨率的源，选择更大的 tile size。
对每一帧和每个组件(Y/CbCr)，<code>frame_restoration_type</code>符号会被发送。对于 Y 组件，符号有如下几个值：</p>

<ul>
  <li>RESTORE_NOEN: 不恢复帧。</li>
  <li>RESTORE_WIENER: 帧中的每个 tile 可能不恢复或者使用 wiener 滤波。</li>
  <li>RESTORE_SGRPROJ：帧中的每个 tile 可能不恢复或者使用 self-guided 滤波。</li>
  <li>RESTORE_DOMTXFMRF: 帧中的每个 tile 可能不恢复或者使用 Domain Transform Recursive 滤波。</li>
  <li>RESTORE_SWITCHABLE: 帧中的每个 tile 可能不恢复或者使用任何支持的滤波工具。</li>
</ul>

<p>对 chroma components 来说，只有上面的前三个滤波。</p>

<p>根据每个 component 的帧恢复类型，对每个 tile 会有额外的信息来表示实际的恢复类型，如有需要，可能也会有额外的信息。编码器会根据使用的 restoration 来对合适的 RD。解码器只是将受到的信息解码出来并用到滤波器上。</p>

<p>注意：除了 domain transform filter外，其他的滤波器在解码器至少需要 3 行未滤波的像素。此外，解码器操作足够简单，对硬件非常友好。也正因为这个原因，AV1 解码器中删除了 Domain Transform filter。</p>

<h2 id="wiener-filter-">Wiener Filter 维纳滤波器</h2>

<p>Degraded 帧的每个像素都经过维纳滤波，维纳滤波的系数存在码流中。因为归一化和对称性，对于垂直和水平滤波器，只需要从编码端传递三个参数。编码器决定使用的滤波抽头(filter tap),解码端只是简单的使用从码流中获取的滤波抽头。</p>

<p>分析<code>DAV1D</code>解码中，维纳滤波主要分为三步：</p>

<ul>
  <li>填充数据(padding)，此步骤主要目的是为后面的滤波做准备，将后面用到的像素汇集到一起。因为此步骤并没有改变一些像素的值，只是为了后面的滤波更加方便，所以该步骤在优化时，可以去掉，直接进行滤波，这样就少了一步数据拷贝，可以提升解码效率，在它的 ARM 汇编的实现中，就是这样做的。</li>
  <li>水平滤波。该步通过水平滤波，将上面的填充数据滤波到另外一个临时数组中，水平滤波后的数据时为下一步的垂直滤波做数据准备的。</li>
  <li>垂直滤波。该步通过垂直滤波，将水平滤波结束的数据重新放回最初原始数据的位置，从而完成对像素的整个维纳滤波。</li>
</ul>

<p><img src="http://lazybing.github.io/images/av1_lr/wiener_filter.png" /></p>

<h2 id="selfguided-filter-">Selfguided Filter 自导向投影滤波器</h2>

<h2 id="section">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="https://static1.squarespace.com/static/56ac12221f40397fbfd21993/t/59cf3d9a2278e777855714bb/1506753947391/0000265.pdf">A SWITCHABLE LOOP-RESTORATION WITH SIDE-INFORMATION FRAMEWORK FOR THE EMERGING AV1 VIDEO CODEC</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1(DAV1D) 解码详解(三)之CDEF]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter/"/>
    <updated>2019-01-28T06:32:04-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cdef-" id="markdown-toc-cdef-">CDEF 介绍</a></li>
  <li><a href="#section" id="markdown-toc-section">方向查找</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">非线性低通滤波器</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">定向滤波器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">代码实现分析</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">方向查找实现</a></li>
          <li><a href="#cdef--1" id="markdown-toc-cdef--1">CDEF 方向滤波</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">参考文档</a></li>
</ul>

<p>CDEF(constrained directional enhancement)约束方向增强滤波器是 AV1 里的几种滤波器之一， SPEC 中定义的该部分在 7.15 CDEF process 中。AOM 代码中在 cdef.c 相关的文件中。除此外，还可以参考 <code>The AV1 CONSTRAINED DIRECTIONAL ENHANCEMENT FILTER</code>论文，本文就是基于上面三个部分分析的结果。</p>

<!--more-->

<p>环路滤波器基于非线性低通滤波器，专为矢量化效率设计的。该滤波器考虑边缘方向和滤波模式，它通过确定每个 block 块的方向，然后自适应的用沿方向的滤波强度进行滤波。增强滤波目的是提高 AOM 的质量，尤其是低复杂性的配置中。</p>

<h2 id="cdef-">CDEF 介绍</h2>

<p>CDEF 的主要目的是过滤掉编码杂音，同时保留图像的详细内容。AV1 中采用的方法是非线性空间滤波器，该滤波器的设计非常适用于矢量化，即可以使用 SIMD 操作，而其他非线性滤波器（如中值滤波器和双边滤波器）并非如此。</p>

<p>CDEF 滤波器的设计基于以下观察：编码图像中杂音的数量通常与量化步长大致成比例，图像详细内容的数量是输入图像的一个属性，保留在量化过的图像中的最小的实际信息量也与量化成一定的比例。对于给定的步长，杂音的幅度要比细节的幅度小很多。</p>

<p>CDEF 首先判断每个块的方向，之后沿着判断的方向自适应的滤波，并沿着判断的方向小幅度旋转 45 度，滤波强度明确表示，对模糊的高度控制。</p>

<p>CDEF 是基于之前提到的两个环路滤波器，结合的滤波器用在了 AV1 Codec 中。</p>

<p>从 SPEC 中的7.15 节可以看出，CDEF 可以理解为，输入为重建像素的当前帧数组，输出为包含了 Deringed 像素的数组 CDEF 帧。CDEF 的作用就是在侦测到的块方向上执行 DEringing， 码流中 CDEF 参数存放到每个64x64块(luma像素)中。可以将 CDEF 模块大致分为3步：</p>

<ul>
  <li>CDEF Block 处理</li>
  <li>CDEF Direction 处理</li>
  <li>CDEF Filter 处理</li>
</ul>

<h2 id="section">方向查找</h2>

<p>方块滤波后，方向查找就作用在重建像素上。因为重建像素对解码器是可获取的，因此滤波方向不需要特定的给出。查找作用在 8x8 块上，当应用到量化过后的图像时，该大小对于充分处理非直接边缘已经足够小，而对可靠地估计出方向又已经足够大了,有一个固定方向作用在8x8区域上，使得矢量化滤波更容易。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/av1_cdef_find_dir.png" /></p>

<p>对每个方向d，每行k的平均像素是: $ u_{d,k} = \frac{1}{N_{d,k}} \sum_{p \in P_{d,k}} x_p$ 其中：</p>

<ul>
  <li>$x_p$ 是像素$p$的值</li>
  <li>$P_{d,k}$是在方向$d$上第$k$行的一组像素值</li>
  <li>$N_{d,k}$是相对$P_{d,k}$对应的基数，如$N_{1,0}=2, N_{1,4}=8$</li>
</ul>

<p><code>SSD</code>的计算公式如下：$E_{d}^2 = \sum_{k} \big[\sum_{p \in P_{d,k}} \big( x_{p} - u_{d,k}\big)^2 \big]$</p>

<p>将上面的两个公式整合后，结果如下：$E_{d}^2 = \sum_{p}x_{p}^2 - \sum_{k}\frac{1}{N_{d,k}} \big(\sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>我们可以通过计算上面公式中第二部分的最大值来寻找最佳方向 $d_{opt}$, $d_opt = max_d s_d$, 其中 $s_{d} = \sum_{k}\frac{1}{N_{d,k}} \big(sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>可以用 840 乘以$S_d$来避免除以$N_{d,k}$,840 是所有$N_{d,k}$的最小公倍数。对于 8bit 数据，数据值为$[-128, 127]$，所有$840S_d$和所有的其他计算都适用于 32位 signed 整数类型。对于更高的bit，如10bit或12bit，在查找方向时，缩放像素到 8bit。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/direction_search.png" /></p>

<p>上图展示了一个针对 8x8 块，寻找方向的例子，寻找的算法如下。为了节省解码器的复杂度，我们假定亮度和色度方向是相关的，因此我们只寻找亮度原件的方向，该方向与色度方向相同。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/algorithm_find_direction.png" /></p>

<h2 id="section-1">非线性低通滤波器</h2>

<p>CDEF 使用非线性低通滤波器，去除编码杂音的同时不会模糊块的边缘。AV1 根据特定方向寻找滤波器抽头位置，同时当滤波器运用到块边界时，要防止过度模糊。使用非线性低通滤波器，在滤波像素偏差过大时，就不再对该像素过度强调。</p>

<h3 id="section-2">定向滤波器</h3>

<p>确认方向是为了统一特定方向上滤波器抽头，来降低振铃，同时不会模糊特定的边缘。但是单纯的定向滤波器有时无法高效的降低振铃效应，因此同时需要对像素数据使用滤波器抽头，该抽头并不是直接沿着主要方向。为了降低模糊块的风险，这些额外的抽头会被更保守的处理。因此，CDEF 定义了 primary taps 和 secondary taps。</p>

<p>primary taps 沿着方向 d，它的系数如上面图 4 所示。对 primary taps，对不同的 strength，会有不同的系数，对于1/3/5的strength，与2/4/6的strength，系数是不同的。secondary tpas 会形成一个十字架，是方向 d 旋转 45° 后得到，系数如图 5。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/primary_filter.png" />
<img src="http://lazybing.github.io/images/av1_cdef/secondary_filter.png" /></p>

<p>2-D CDEF 滤波器公式如下：</p>

<p>$y(i,j) = x(i,j) + round( \sum_{m,n} w_{d,m,n}^{(p)} f(x(m,n) -x(i, j), S^{(p)}, D) + \sum_{m,n} w_{d,m,n}^{(s)} f(x(m,n) -x(i,j), S^{(s)}, D))$</p>

<ul>
  <li>$S_{p}$和$S_{s}$是 primary 和 secondary 抽头的 strength。</li>
</ul>

<p>每个要滤波的 8x8 块，方向、strength 和 damping 参数是固定的。当处理位置(i, j)处的像素时，滤波器允许使用 x(i+m, j+m)处的像素，该像素可能超出 8x8 块的边界。如果处理像素超出了帧范围，像素会被忽略(f(d, S, D) = 0)。为最大化并行，CDEF 总是作用在输入(post-deblocking)像素 x(i,j)上，这样在滤波其他像素时，不会用的之前已经滤波王城的像素。</p>

<h3 id="section-3">代码实现分析</h3>

<p>此处以 DAV1D 工程里的 CDEF 模块作为例子，主要介绍两部分，<code>cdef_find_dir</code>和<code>cdef_filter_block</code>，并把 10bit 汇编优化完成。完成后，在 pixel2 手机上测试，效率提升大概 30% 左右。</p>

<h4 id="section-4">方向查找实现</h4>

<p>DAV1D 工程里，对 CDEF 方向查找，完成了 C 代码实现和对 8bit 码流的汇编优化，对10bit优化并没有完成。</p>

<figure class="code"><figcaption><span>cdef_find_dir.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">
</span></code></pre></td></tr></table></div></figure>

<h4 id="cdef--1">CDEF 方向滤波</h4>

<p>滤波主要由两步完成，</p>

<h2 id="section-5">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="http://www.mirlab.org/conference_papers/international_conference/ICASSP%202018/pdfs/0001193.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
  <li><a href="https://jmvalin.ca/misc_stuff/icassp2018_slides.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM64 汇编指令总结]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/24/neon-of-coding/"/>
    <updated>2019-01-24T06:35:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/24/neon-of-coding</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#sqdmulhvectorby-element" id="markdown-toc-sqdmulhvectorby-element">SQDMULH(vector/by element)</a></li>
  <li><a href="#sqrdmulhvectorby-element" id="markdown-toc-sqrdmulhvectorby-element">SQRDMULH(vector/by element)</a></li>
  <li><a href="#sqrshrun-sqrshrun2" id="markdown-toc-sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</a></li>
  <li><a href="#sqshrun-sqshrun2" id="markdown-toc-sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</a></li>
  <li><a href="#shl" id="markdown-toc-shl">SHL</a></li>
  <li><a href="#shll-shll2" id="markdown-toc-shll-shll2">SHLL, SHLL2</a></li>
  <li><a href="#sshll-sshll2" id="markdown-toc-sshll-sshll2">SSHLL, SSHLL2</a></li>
  <li><a href="#ushll-ushll2" id="markdown-toc-ushll-ushll2">USHLL, USHLL2</a></li>
  <li><a href="#trn1--trn2" id="markdown-toc-trn1--trn2">TRN1 &amp; TRN2</a></li>
  <li><a href="#sxtl-sxtl2" id="markdown-toc-sxtl-sxtl2">SXTL, SXTL2</a></li>
  <li><a href="#uxtl-uxtl2" id="markdown-toc-uxtl-uxtl2">UXTL, UXTL2</a></li>
  <li><a href="#ext" id="markdown-toc-ext">EXT</a></li>
  <li><a href="#bfm-ubfm-sbfmbitfield-move" id="markdown-toc-bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</a></li>
  <li><a href="#srshr" id="markdown-toc-srshr">SRSHR</a></li>
</ul>

<p>ARMv8 指令集可以大致分为三类:A64 指令集、A32&amp;T32 指令集。</p>

<p>ARM 汇编真的太痛苦了。。。一个命令一个命令的学习记录吧</p>

<!--more-->

<p>指令格式：</p>

<p><code>&lt;Opcode&gt;[&lt;Cond&gt;]&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; [.&lt;Opcode2&gt;]</code></p>

<ul>
  <li>其中尖括号的选项是必须的，花括号是可选的。</li>
  <li>A32 : Rd==&gt;{R0-R14}</li>
  <li>A64 : Rd==&gt;Xt==&gt;{X0-X30}</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标识符</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Opcode</td>
      <td style="text-align: center">操作码，也就是助记符，说明指令需要执行的操作类型</td>
    </tr>
    <tr>
      <td style="text-align: center">Cond</td>
      <td style="text-align: center">指令执行条件码，在编码中占4bit, 0b000-0b1110</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">条件码设置项，决定本次指令是否影响 PSTATE 寄存器响应状态位值</td>
    </tr>
    <tr>
      <td style="text-align: center">Rd/Xt</td>
      <td style="text-align: center">目标寄存器，A32 指令可以选择 R0-R14，T32指令大部分只能选择R0-R7,A64指令可以选择X0-X30 或 W0-W30</td>
    </tr>
    <tr>
      <td style="text-align: center">Rn/Xn</td>
      <td style="text-align: center">第一个操作数的寄存器，和 Rd 一样，不同指令有不同要求</td>
    </tr>
    <tr>
      <td style="text-align: center">Opcode2</td>
      <td style="text-align: center">第二个操作数，可以是立即数，寄存器Rm 和寄存器移位方式(Rm, #shift)</td>
    </tr>
  </tbody>
</table>

<h2 id="sqdmulhvectorby-element">SQDMULH(vector/by element)</h2>

<p>Signed saturating Doubling Multiply return High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;T&gt;</code>:4H/8H/2S/4S 中的一个</li>
</ul>

<p>示例</p>

<ul>
  <li>sqdmulh v0.8h, v0.8h, v30.8h</li>
</ul>

<p>Signed saturation Doubling Multiply return High half(by element).该指令将第一个源寄存器的每个矢量元素乘以第二个源寄存器的某个特定矢量元素，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrdmulhvectorby-element">SQRDMULH(vector/by element)</h2>

<p>Signed saturating Rounding Doubling Multiply returning High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</h2>

<p>Signed saturating Rounded Shift Right Unsigned Narrow(immediate).</p>

<p>Scalar:</p>

<p><code>SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>sqrshrun v0.8b, v1.8h, #5</li>
</ul>

<p>Vector:</p>

<p><code>SQRSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</h2>

<p>Signed saturating Shift Right Unsigned Narror(immediate).</p>

<p>Scalar:</p>

<p><code>SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SQSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="shl">SHL</h2>

<p>Shift Left(immediate)。</p>

<p>Scalar:</p>

<p><code>SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<h2 id="shll-shll2">SHLL, SHLL2</h2>

<p>Shift Left Long(by element size)。</p>

<p>Vector:</p>

<p><code>SHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li>
    <p><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</p>
  </li>
  <li>shll  v28.8h, v30.8b,  #8</li>
  <li>shll2 v29.8h, v30.16b, #8</li>
</ul>

<h2 id="sshll-sshll2">SSHLL, SSHLL2</h2>

<p>Signed Shift Left Long(immediate)。</p>

<p><code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="ushll-ushll2">USHLL, USHLL2</h2>

<p>Unsigned Shift Left Long(immediate)。</p>

<p><code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="trn1--trn2">TRN1 &amp; TRN2</h2>

<p>TRN1:转置向量 Transpose vector(primary), 该指令从零开始读取两个源寄存器 SIMD&amp;FP 的相应偶数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn1 v4.2d, v4.2d, v5.2d</li>
</ul>

<p>TRN2:转置向量 Transpose vectors(secondary)。该指令读取两个源寄存器 SIMD&amp;FP 的相应奇数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>T</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn2 v7.2s, v5.2s, v7.2s</li>
</ul>

<p><img src="http://lazybing.github.io/images/neon_coding/trn.png" /></p>

<h2 id="sxtl-sxtl2">SXTL, SXTL2</h2>

<p>SXTL:Signed extend Long,该指令</p>

<p>Vector:</p>

<p><code>SXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>sxtl v0.8h, v0.8b</li>
</ul>

<h2 id="uxtl-uxtl2">UXTL, UXTL2</h2>

<p>UXTL:Unsigned extend Long.</p>

<p>Vector:</p>

<p><code>UXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>uxtl v4.8h, v4.8b</li>
</ul>

<h2 id="ext">EXT</h2>

<p>EXT:Extract vector from pair of vectors.</p>

<p>Advanced SIMD variant</p>

<p><code>EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</code></p>

<p><img src="http://lazybing.github.io/images/neon_coding/ext.png" /></p>

<p>示例：</p>

<ul>
  <li>ext v5.16b, v4.16b, v4.16b, #2</li>
</ul>

<h2 id="bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</h2>

<p>BFM:</p>

<p>32-bit variant</p>

<p><code>BFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>SBFM:</p>

<p>32-bit variant</p>

<p><code>SBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>UBFM:</p>

<p>32-bit variant</p>

<p><code>UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>示例：</p>

<ul>
  <li>ubfm w9, w5, #7, #13</li>
</ul>

<h2 id="srshr">SRSHR</h2>

<p>SRSHR:Signed Rounding Shift Right(immediate)。</p>

<p>Scalar variant:</p>

<p><code>SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SRSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>srshr v24.8h, v24.8h, #2</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程5——重排矢量]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/23/neon-rearranging-vector/"/>
    <updated>2019-01-23T06:35:06-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/23/neon-rearranging-vector</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">开始之前</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">可替换的</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">指令</a>    <ul>
      <li><a href="#vmov--vswapmove--swap" id="markdown-toc-vmov--vswapmove--swap">VMOV 和 VSWAP：Move 和 Swap</a></li>
      <li><a href="#vrevreverse" id="markdown-toc-vrevreverse">VREV:Reverse</a></li>
      <li><a href="#vextextract" id="markdown-toc-vextextract">VEXT:Extract</a></li>
      <li><a href="#vrtntranspose" id="markdown-toc-vrtntranspose">VRTN:Transpose</a></li>
      <li><a href="#vzip--vuzpzip--unzip" id="markdown-toc-vzip--vuzpzip--unzip">VZIP 和 VUZP:Zip 和 Unzip</a></li>
      <li><a href="#vtbl-vtbxtable--table-extend" id="markdown-toc-vtbl-vtbxtable--table-extend">VTBL, VTBX:Table 和 Table Extend</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">其他</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">结论</a></li>
</ul>

<p>本文描述了用于重置矢量寄存器数据的NEON指令。</p>

<!--more-->

<h2 id="section">介绍</h2>

<p>当写 NEON 代码时，你或许会发现某些时候，寄存器中的数据格式并不适用于你的算法。可能需要重排矢量中的元素，从而让后续的算术可以。</p>

<p>重新排序操作称为<strong>permutation</strong>，<strong>permutation</strong>指令重置单独像素、选择从单个或多个寄存器来组织一个新的矢量。</p>

<h2 id="section-1">开始之前</h2>

<p>在使用 NEON 提供的<strong>permutation</strong>指令之前，一定要想清楚是否真的需要使用它们。<strong>permutation</strong>指令与 move 指令相似，因为它们通常代表用于准备数据而不是处理数据的 CPU 周期。</p>

<h2 id="section-2">可替换的</h2>

<p>如何避免不必要的<em>permutes</em>？有如下方法选项：</p>

<ul>
  <li>
    <p><strong>重排输入数据</strong>.</p>
  </li>
  <li>
    <p><strong>重新设计算法</strong></p>
  </li>
  <li>
    <p><strong>修改上一个处理阶段</strong></p>
  </li>
  <li>
    <p><strong>使用交错负载和存储</strong></p>
  </li>
  <li>
    <p><strong>综合方法</strong></p>
  </li>
</ul>

<h2 id="section-3">指令</h2>

<h3 id="vmov--vswapmove--swap">VMOV 和 VSWAP：Move 和 Swap</h3>

<h3 id="vrevreverse">VREV:Reverse</h3>

<h3 id="vextextract">VEXT:Extract</h3>

<h3 id="vrtntranspose">VRTN:Transpose</h3>

<h3 id="vzip--vuzpzip--unzip">VZIP 和 VUZP:Zip 和 Unzip</h3>

<h3 id="vtbl-vtbxtable--table-extend">VTBL, VTBX:Table 和 Table Extend</h3>

<h3 id="section-4">其他</h3>

<h2 id="section-5">结论</h2>

<p>仔细考虑你的代码是否真的需要重置你的数据是明智的。然而，当你的算法需要它时，permute 指令提供了一个高效的方法来使得你的数据存放到正确的格式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程4——左右移位]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right/"/>
    <updated>2019-01-22T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">向量移位</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">移位与插入</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">移位与计算</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">指令修改器</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可用移位表</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">示例：转换颜色深度</a>    <ul>
      <li><a href="#section-6" id="markdown-toc-section-6">从 565 到 888</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">从888到565</a></li>
    </ul>
  </li>
  <li><a href="#section-8" id="markdown-toc-section-8">结论</a></li>
</ul>

<p>本文将介绍 NEON 提供的移位运算，并介绍如何利用移位运算在常用颜色深度之间转换影像数据。本系列前期已发布的文章包括：第一部分：加载与存储，第二部分：余数的处理，第三部分：矩阵乘法。</p>

<!--more-->

<h2 id="section">向量移位</h2>

<p>NEON 上的移位与标量 ARM 编码中可能用到的移位非常相似，即每个向量元素的位数均向左或向右移位，出现在每个元素左侧与右侧的位将被删除；它们不能移位至相连的元素。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_vector.png" /></p>

<p>带符号元素的向量上发生的右移位由指令附加的类型指定，并会将符号扩展至每一个元素。这与 ARM 编码中可能用到的算术移位相同。应用到无符号向量的移位不会发生符号扩展。</p>

<h2 id="section-1">移位与插入</h2>

<p>NEON 也支持通过插入产生移位，使两个不同向量的位相结合。例如，左移位与插入（VSLI）可使源向量的每一个元素均向左移位。每个元素右侧新插入的位就是目标向量中的对应为。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_insert.png" /></p>

<h2 id="section-2">移位与计算</h2>

<p>最后，NEON 还支持向量元素向右移位，并将结果计入到另一个向量中。这种方法对于先在高精度条件下进行临时计算，然后再将结果与低精度计算器相结合的情况非常有用。</p>

<h2 id="section-3">指令修改器</h2>

<p>每个移位指令都能拥有一个或多个修改器。这些修改器并不改变移位运算本身，而是通过调整输入值与输出值，消除偏差或饱和状态，保持一定的范围。共有五种移位修改器：</p>

<ul>
  <li>舍位修改器(Rounding)，以 R 前缀表示，可以纠正右移时舍位导致的偏差。</li>
  <li>窄修改器(Narrow)，以 N 后缀表示，可以让结果中每个元素的位数减半。它代表Q(128位)源和D(64位)目标寄存器。</li>
  <li>长修改器(Long),以 L 后缀表示，可以让结果中每个元素的位数加倍。它代表D源和Q目标寄存器。饱和修改器(Saturating)，以Q前缀表示，可以在最大和最小可表示范围内设置每个结果元素，前提是结果未超出该范围。向量的位数和符号类型可用于确定饱和范围。</li>
  <li>无符号饱和修改器(Unsigned Saturationg)，以Q前缀和U后缀表示，与饱和修改器类似，但在进行带符号与无符号输入时，结果将在无符号范围内表示为饱和。</li>
</ul>

<p>这些修改器的部分组合并未表现出有用的运算，因此 NEON 也没有提供相应指令。例如，饱和右移位（应称为 VQSHR）其实就毫无必要，因为右移位只会让结果变得更小，因而值根本无法超出有效范围。</p>

<h2 id="section-4">可用移位表</h2>

<p>NEON 提供的所有移位指令均在下表中列出。它们根据先前提到的修改器进行排列。如果你还是不太确定修改器各个字母代表的含义，请利用下表选择需要的指令。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_table_avaliable.png" /></p>

<h2 id="section-5">示例：转换颜色深度</h2>

<p>颜色深度之间的转换是图形处理中经常需要的运算。通常，输入或输出数据都是 RGB565 16 位颜色格式，但 RGB888 格式的数据处理起来更为方便。对于 NEON 而言尤其如此，因为它无法为 RGB565 这样的数据类型提供本机支持。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/color_format.png" /></p>

<p>但是，NEON 仍然可以有效地处理 RGB565 数据，上文中介绍的向量移位便提供了处理方法。</p>

<h3 id="section-6">从 565 到 888</h3>

<p>首先，我们来看如何将 RGB565 转换为 RGB888。假设寄存器 q0 中有 8 个 16 位像素，我们想要在 d2、d3和d4这三个寄存器中将红色、绿色和蓝色分离成 8 位的元素。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vshr.u8</span>     <span class="no">q1</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift red elements right by three bits,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">at</span> <span class="no">the</span> <span class="no">bottom</span> <span class="no">of</span> <span class="no">the</span> <span class="no">red</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vshrn.i16</span>   <span class="no">d2</span><span class="p">,</span> <span class="no">q1</span><span class="p">,</span> <span class="c">#5  @shift red element right and narrow,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits.</span>
</span><span class="line"><span class="nf">vshrn.i16</span>   <span class="no">d3</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#5  @shift green elements right and narrow,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">bits</span> <span class="no">and</span> <span class="no">some</span> <span class="no">red</span> <span class="no">bits</span> <span class="no">due</span> <span class="no">to</span> <span class="no">narrowing.</span>
</span><span class="line"><span class="nf">vshl.i8</span>     <span class="no">d3</span><span class="p">,</span> <span class="no">d3</span><span class="p">,</span> <span class="c">#2  @shift green elements left, discarding the remaining red bits,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">and</span> <span class="no">placing</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">in</span> <span class="no">the</span> <span class="no">correct</span> <span class="no">place.</span>
</span><span class="line"><span class="nf">vshl.i16</span>    <span class="no">q0</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift blue elements left to most-significant </span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">color</span> <span class="no">channel.</span>
</span><span class="line"><span class="nf">vmovn.i16</span>   <span class="no">d4</span><span class="p">,</span> <span class="no">q0</span>      <span class="err">@</span><span class="no">remove</span> <span class="no">remaining</span> <span class="no">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">by</span> <span class="no">narrowing</span> <span class="no">to</span> <span class="mi">8</span> <span class="no">bits</span>
</span></code></pre></td></tr></table></div></figure>

<p>每个指令的效果都在上面备注中做了描述，但总而言之，每个通道上执行的运算为：</p>

<ol>
  <li>利用移位推掉元素任意一端的位数，清除相邻通道的颜色数据。</li>
  <li>使用第二次移位将颜色数据放置到每个元素最重要的位上，并缩短位数将元素大小从 16 位减至 8 位。</li>
</ol>

<p>请注意在这个顺序中使用元素大小来确定 8 位和 16 位元素的位置，以进行部分掩码运算。</p>

<h3 id="section-7">从888到565</h3>

<p>现在，我们来看反向运算，即从 RGB888 转换为 RGB565。这里，我们假设 RGB888 数据为上述代码产生的格式；在d0、d1和d2这三个寄存器上，每个寄存器均包含每种颜色的 8 个元素。结果将存储为 q2 格式的 8 个 16 位 RGB565 元素。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vshll.u8</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">d0</span><span class="p">,</span> <span class="c">#8  @shift red element left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">ushll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d1</span><span class="p">,</span> <span class="c">#8  @shift green elements left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">fo</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements</span>
</span><span class="line"><span class="nf">vsri.16</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#5  @shift green elemnts right and insert into red</span>
</span><span class="line">                        <span class="err">@</span> <span class="nf">red</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vshll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d2</span><span class="p">,</span> <span class="c">#8  @shift blue elements left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vsri.16</span>     <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#11 @shift blue elements right and insert into</span>
</span><span class="line">                        <span class="err">@</span> <span class="nf">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">elements.</span>
</span></code></pre></td></tr></table></div></figure>

<p>同样，每个指令的详细说明在备注中列出，但总而言之，对于每个通道而言：</p>

<ol>
  <li>将每个元素的长度扩展到 16 位，并将颜色数据移至最重要的位上。</li>
  <li>使用插入右移位，将每个颜色通道放置到结果寄存器中。</li>
</ol>

<h2 id="section-8">结论</h2>

<p>NEON 提供的强大的移位指令范围让你能够：</p>

<ul>
  <li>利用舍入和饱和，通过二次幂快速进行向量的除法和乘法运算。</li>
  <li>通过移位将一个向量位复制到另一个向量位。</li>
  <li>在高精度条件下进行临时计算，并在低精度条件下计算结果。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程3——矩阵相乘]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication/"/>
    <updated>2019-01-21T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">矩阵</a></li>
  <li><a href="#algorithm" id="markdown-toc-algorithm">算法(Algorithm)</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">代码</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">浮点数运算</a></li>
      <li><a href="#d-and-q-" id="markdown-toc-d-and-q-">D and Q 寄存器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">回到代码中</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">定点运算</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">宏定义：</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">如果考虑到调度的话</a></li>
</ul>

<p>前面两篇分别介绍了如何使用 NEON 来加载和存储数据，如何使用 NEON 处理多余的数据。这一篇介绍一点儿使用的数据处理——矩阵相乘。</p>

<!--more-->

<h2 id="section">矩阵</h2>

<p>本篇文章会分析如何有效的完成4x4矩阵相乘，这种操作在 3D 图形中经常会用到。假设矩阵存放到内存中，并且是列优先的顺序，该格式在 OpenGL-ES 中使用。</p>

<h2 id="algorithm">算法(Algorithm)</h2>

<p>先详细的检测一下矩阵相乘的操作，通过把计算扩展开，并确定哪些子操作可以使用 NEON 指令实现。</p>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/neon_matrix_multiply.png" /></p>

<p>在上图中，我们将第一个矩阵的每一列(红色标记)乘以在第二个矩阵中对应的数值(蓝色标记)，然后将结果加起来，得到结果中的一个列的数值。这个操作将被重复四次。</p>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/vector_by_scalar_multiply.png" /></p>

<p>如果每个列都是在 NEON 寄存器中的一个向量，我们能够用 vector-by-scalar multiplication 指令来计算每个列。即上图中显示的指令。我们可以用同样指令的累计版本来将结果都加起来组成每一列的结果。</p>

<p>当我们处理第一个矩阵的列，产生结果中的一列时，读取和写入数据到或者从内存中都是一个线性操作，不需要交错读取及存储指令。</p>

<h2 id="section-1">代码</h2>

<h3 id="section-2">浮点数运算</h3>

<p>首先，我们先关注乘以单精度浮点数矩阵的实现。</p>

<p>从内存中加载矩阵到 NEON 寄存器，该矩阵是使用列顺序进行存储，所以存储的列都是线性的存储在内存中。一个列能够用 VLD1 指令加载到 NEON 寄存器，用 VST1 写入到内存。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d20-d23</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span>   <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span>   <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>

<p>NEON 有 32 个 64 位寄存器，我们可以从矩阵中加载所有的数据到寄存器，并且还有剩余的寄存器可以用来作为累加用。这里 d16 到 d23 保存第一个矩阵中的 16 个数据，而 d0 到 d7 保存第二个矩阵中的 16 个数据。</p>

<h3 id="d-and-q-">D and Q 寄存器</h3>

<p>大部分 NEON 指令能够用一下两种方式使用寄存器组：</p>

<ul>
  <li>32 个双字寄存器， 64bits 大小，从 d0 到 d31。</li>
  <li>16 个四字寄存器， 128bits 大小，从 q0 到 q15。</li>
</ul>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/neon_register.png" /></p>

<p>这些寄存器用别名表示，因此，在 Q 寄存器，以及在相对应的两个 D 寄存器中，数据都是一样的。例如，q0 可被分为 d0 及 d1，数据可以在两种模式下进行访问。在 C 中，这种方式类似于 union。</p>

<p>对于浮点数矩阵乘法的例子，我们频繁的使用 Q 寄存器，因为我们处理 4 个 32-bit 浮点数的列，这将对应于一个 128 位的 Q 寄存器。</p>

<h3 id="section-3">回到代码中</h3>

<p>应用 NEON 乘法指令，我们能够计算矩阵相乘的一个列。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vmul.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>  <span class="err">@</span><span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>  <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q10</span><span class="p">,</span> <span class="no">d1</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span> <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q11</span><span class="p">,</span> <span class="no">d1</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span> <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>

<p>第一个指令实现了在矩阵乘法分解图中的操作，x0、x1、x2 和 x3（在 q8 寄存器中）分别乘以 y0（d0 的第 0 个数据），结果保存在 q12。接下来的指令用于处理第一个矩阵中的其他列，乘以第二个矩阵第一列中对应的元素。结果将会累加到 q12，来构成最终结果的第一列。</p>

<p>需要注意的是，乘法指令中的标量是 D 寄存器，尽管q0[3]的数据与d1[1]相同，但是这里使用d1[1]更加说得过去，并且 GNU 汇编器并不支持这种格式。因此，我们不得不使用 D 寄存器。</p>

<p>宏：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="na">.macro</span> <span class="no">mul_col_f32</span> <span class="no">res_q</span><span class="p">,</span> <span class="no">col0_d</span><span class="p">,</span> <span class="no">col1_d</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="err">\</span><span class="no">col0_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>      <span class="err">@</span> <span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="err">\</span><span class="no">col0_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>      <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q10</span><span class="p">,</span> <span class="err">\</span><span class="no">col1_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>  <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q11</span><span class="p">,</span> <span class="err">\</span><span class="no">col1_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>  <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">3</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line"><span class="na">.endm</span>
</span></code></pre></td></tr></table></div></figure>

<p>4x4 浮点矩阵相乘可以被这样实现：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d20-d23</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>              <span class="err">@</span> <span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>              <span class="err">@</span> <span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q12</span><span class="p">,</span> <span class="no">d0</span><span class="p">,</span> <span class="no">d1</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q13</span><span class="p">,</span> <span class="no">d2</span><span class="p">,</span> <span class="no">d3</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q14</span><span class="p">,</span> <span class="no">d4</span><span class="p">,</span> <span class="no">d5</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q15</span><span class="p">,</span> <span class="no">d6</span><span class="p">,</span> <span class="no">d7</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">
</span><span class="line">    <span class="nf">vst1.32</span>  <span class="err">{</span><span class="no">d24-d27</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">store</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span><span class="line">    <span class="nf">vst1.32</span>  <span class="err">{</span><span class="no">d28-d31</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">store</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-4">定点运算</h2>

<p>使用定点数运算通常比浮点数更快，因为它占用更小的内存带来读取及写入数值，并且整数的乘法通常来说更快。然而，在使用定点数运算时，当需要保证程序要求的计算精度时，你必须仔细选择表示方法来避免溢出或者饱和。</p>

<p>使用定点数进行矩阵乘法与浮点数非常类似。在这个例子中个，我们使用 Q1.14 定点数格式，但是操作上与其他格式类似，可能只需要最终左移的位数。</p>

<h3 id="section-5">宏定义：</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="na">.macro</span> <span class="no">mul_col_s16</span> <span class="no">res_d</span><span class="p">,</span> <span class="no">col_d</span>
</span><span class="line">    <span class="nf">vmull.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d16</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d17</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d18</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">2</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d19</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">3</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">3</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">    <span class="nf">vqrshrn.s32</span> <span class="err">\</span><span class="no">res_d</span><span class="p">,</span> <span class="no">q12</span><span class="p">,</span> <span class="c">#14            @ shift right and narrow accumulator into</span>
</span><span class="line">                                            <span class="err">@</span>  <span class="nf">Q1.14</span> <span class="no">fixed</span> <span class="no">point</span> <span class="no">format</span><span class="p">,</span> <span class="no">with</span> <span class="no">saturation</span>
</span><span class="line"><span class="na">.endm</span>
</span></code></pre></td></tr></table></div></figure>

<p>与浮点数版本的宏进行对比，你将会发现：</p>

<ul>
  <li>数值是16位而不是32为，我们可以使用D寄存器保存4个输入。</li>
  <li>两个16位数的相乘结果是一个32位数，我们使用VMULL及VMLAL，因为它们将保存结果至Q寄存器，使用两倍于数据的大小来保存所有的位数。</li>
  <li>最后的结果为16位，但是累加器是32位的。我们通过VQRSHRN获取16位结果，一个向量，饱和计算，四舍五入，右移窄运算。这将把所有正确的值加起来到各自的数据，右移并饱和计算到新的更窄的数据大小。</li>
</ul>

<p>32位数到16位数的减少对内存访问有所影响。数据会被加载和存储使用更少的指令，代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"> <span class="nf">vld1.16</span>  <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]</span>       <span class="err">@</span> <span class="no">load</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"> <span class="nf">vld1.16</span>  <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]</span>         <span class="err">@</span> <span class="no">load</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d4</span><span class="p">,</span> <span class="no">d0</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d5</span><span class="p">,</span> <span class="no">d1</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d6</span><span class="p">,</span> <span class="no">d2</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d7</span><span class="p">,</span> <span class="no">d3</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">
</span><span class="line"> <span class="nf">vst1.16</span>  <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]</span>         <span class="err">@</span> <span class="no">store</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-6">如果考虑到调度的话</h2>

<p>我们会在以后的文章中讨论调度的细节，现在的话，可以看看在代码中查看改进指令调度的影响。</p>

<p>在宏中，临近的乘法指令写入到相同的寄存器，使得NEON流水线在开始下个指令执行时必须等待每个乘法完成。</p>

<p>如果我们把这些指令移出宏然后重新安排顺序，我们能够分离出那些依赖于其他指令的部分，这部分指令能够在其他指令在后台完成时也被执行。 
在这个实例中，我们重组代码来分离累加寄存器的使用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col0</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col0</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q13</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d2</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col1</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col1</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q14</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d4</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col2</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col2</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q15</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d6</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col3</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col3</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col0</span> <span class="err">+=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col1</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col0</span> <span class="no">elt1</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="no">q13</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d2</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col1</span> <span class="err">+=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col1</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col1</span> <span class="no">elt1</span><span class="p">)</span>
</span><span class="line">    <span class="na">...</span>
</span><span class="line">    <span class="na">...</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
