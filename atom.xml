<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2017-07-03T08:38:00-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[X264 源码分析之帧内预测]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction/"/>
    <updated>2017-06-30T08:12:22-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/30/x264-intra-prediction</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#intra16x16vertical-" id="markdown-toc-intra16x16vertical-">Intra_16x16_Vertical 预测模式</a></li>
  <li><a href="#intra16x16horizontal-" id="markdown-toc-intra16x16horizontal-">Intra_16x16_Horizontal 预测模式</a></li>
  <li><a href="#intra16x16dc-" id="markdown-toc-intra16x16dc-">Intra_16x16_DC 预测模式</a></li>
</ul>

<p>本文主要记录 x264 中使用到的帧内预测技术。</p>

<!--more-->

<p>x264 中对于预测</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">intra16x16Predmode</th>
      <th style="text-align: center">Name of Intra16x16PredMode</th>
      <th style="text-align: center">Note</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">Intra_16x16_Vertical(prediction mode)</td>
      <td style="text-align: center">由上边像素推出相应像素值</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Intra_16x16_Horicontal(prdiction mode)</td>
      <td style="text-align: center">由左边像素推出相应像素值</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Intra_16x16_DC(prediction mode)</td>
      <td style="text-align: center">由上边和左边像素平均值推出相应像素值</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Intra_16x16_Plane(prediction mode)</td>
      <td style="text-align: center">利用线性 plan 函数及左、上像素推出相应像素值，适用于亮度变化平缓区域</td>
    </tr>
  </tbody>
</table>

<p>下面依次分析这几种预测模式：</p>

<h3 id="intra16x16vertical-">Intra_16x16_Vertical 预测模式</h3>

<p>在 SPEC 中，关于该预测模式的定义如下：</p>

<blockquote><p>This Intra_16x16 prediction mode shall be used only when the samples p[x, -1] with x=0...15 are marked as "available for Intra_16x16 prediction".The values of the prediction samples pred[x, y] with x,y=0...15, are derived by pred[x,y]=p[x,-1],with x,y=0...15</p></blockquote>

<p>x264 中关于模式 Vertical 的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_predict_16x16_v_c</span><span class="p">(</span><span class="n">pixel</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">pixel4</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span> <span class="mi">0</span><span class="o">-</span><span class="n">FDEC_STRIDE</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">    <span class="n">pixel4</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span> <span class="mi">4</span><span class="o">-</span><span class="n">FDEC_STRIDE</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">    <span class="n">pixel4</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span> <span class="mi">8</span><span class="o">-</span><span class="n">FDEC_STRIDE</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">    <span class="n">pixel4</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">src</span><span class="p">[</span><span class="mi">12</span><span class="o">-</span><span class="n">FDEC_STRIDE</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v0</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">4</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v1</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">8</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v2</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span><span class="mi">12</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v3</span><span class="p">;</span>
</span><span class="line">        <span class="n">src</span> <span class="o">+=</span> <span class="n">FDEC_STRIDE</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意，上面代码中的 pixel 为 uint8_t，而 pixel4 为 uint32_t，而 MPIXEL_X4 定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#define MPIXEL_X4(src) M32(src)  
</span><span class="line">#deinfe M32(src) (((x264_union32_t *)(src))-&gt;i)  
</span><span class="line">typedef union { uint32_t i; uint16_t b[2]; uint8_t  c[4]; } MAY_ALIAS x264_union32_t;</span></code></pre></td></tr></table></div></figure>

<h3 id="intra16x16horizontal-">Intra_16x16_Horizontal 预测模式</h3>

<p>在 SPEC 中，关于该预测模式的定义如下：</p>

<blockquote><p>This Intra_16x16 prediction mode shall be used only when the samples p[−1, y] with y = 0..15 are marked as "available<br />for Intra_16x16 prediction".<br />The values of the prediction samples predL[ x, y ], with x, y = 0..15, are derived by<br />predL[ x, y ] = p[ −1, y ], with x, y = 0..15</p></blockquote>

<p>x264 中关于模式 Horizontal 的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_predict_16x16_h_c</span><span class="p">(</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">src</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="n">pixel4</span> <span class="n">v</span> <span class="o">=</span> <span class="n">PIXEL_SPLAT_X4</span><span class="p">(</span> <span class="n">src</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">4</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span> <span class="mi">8</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class="line">        <span class="n">MPIXEL_X4</span><span class="p">(</span> <span class="n">src</span><span class="o">+</span><span class="mi">12</span> <span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span><span class="line">        <span class="n">src</span> <span class="o">+=</span> <span class="n">FDEC_STRIDE</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中<code>PIXEL_SPLAT_X4</code>定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#   define PIXEL_SPLAT_X4(x) ((x)*0x01010101U)</span></code></pre></td></tr></table></div></figure>

<h3 id="intra16x16dc-">Intra_16x16_DC 预测模式</h3>

<p>在 SPEC 中，关于该预测模式的定义如下：</p>

<blockquote><p>This Intra_16x16 prediction mode operates, depending on whether the neighbouring samples are marked as "available for<br />Intra_16x16 prediction", as follows:</p></blockquote>

<p>x264 中关于模式 DC 的代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_predict_16x16_dc_c</span><span class="p">(</span> <span class="n">pixel</span> <span class="o">*</span><span class="n">src</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">dc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">src</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">FDEC_STRIDE</span><span class="p">];</span>
</span><span class="line">        <span class="n">dc</span> <span class="o">+=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">FDEC_STRIDE</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">pixel4</span> <span class="n">dcsplat</span> <span class="o">=</span> <span class="n">PIXEL_SPLAT_X4</span><span class="p">(</span> <span class="p">(</span> <span class="n">dc</span> <span class="o">+</span> <span class="mi">16</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span> <span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">PREDICT_16x16_DC</span><span class="p">(</span> <span class="n">dcsplat</span> <span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264代码解析之x264_encoder_open函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/24/x264-encoder-open/"/>
    <updated>2017-06-24T18:24:01-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/24/x264-encoder-open</id>
    <content type="html"><![CDATA[
<p>本文主要记录<code>x264_encoder_open</code>函数。</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 参数详解]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/23/x264-paraments-illustra/"/>
    <updated>2017-06-23T20:07:55-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/23/x264-paraments-illustra</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">输入</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">预设值</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">帧类型</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">码率控制</a></li>
</ul>

<p>x264 中参数选项详解</p>

<!--more-->

<h2 id="section">输入</h2>
<p>用1个绝对路径定义输入文件（或者2个，rawYUV文件）。如下例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">x264.exe -o NUL C:\input.avs  
</span><span class="line">x264 -o /dev/null ~/input.y4m  </span></code></pre></td></tr></table></div></figure>

<p>如果输入文件是rawYUV格式的，还要把分辨率一并输入。如果开启了比特率控制，还需要输入帧率。如下例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">x264.exe -o NUL –fps 25 D:\input.yuv 1280×720  
</span><span class="line">x264 -o /dev/null –fps 30000/1001 ~/input.yuv 640×480  </span></code></pre></td></tr></table></div></figure>

<h2 id="section-1">预设值</h2>
<p>预设值是x264在r1177版本增加的一个方便的命令行选项。可以用x264.exe –fullhelp查看所有的命令行帮助。</p>

<ul>
  <li>
    <p>profile<br />
默认：无<br />
说明：限制输出文件的profile。这个参数将覆盖其它所有值，此选项能保证输出profile兼容的视频流。如果使用了这个选项，将不能进行无损压缩（qp 0 or crf 0）。<br />
可选：baseline，main，high<br />
建议：不设置。除非解码环境只支持main或者baseline profile的解码。</p>
  </li>
  <li>
    <p>preset<br />
默认：medium<br />
一些在压缩效率和运算时间中平衡的预设值。如果指定了一个预设值，它会在其它选项生效前生效。<br />
可选：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow and placebo.<br />
建议：可接受的最慢的值</p>
  </li>
  <li>
    <p>tune<br />
默认：无<br />
说明：在上一个选项基础上进一步优化输入。如果定义了一个tune值，它将在preset之后，其它选项之前生效。<br />
可选：film, animation, grain, stillimage, psnr, ssim, fastdecode, zerolatency and touhou.<br />
建议：根据输入选择。如果没有合适的就不要指定。</p>
  </li>
  <li>
    <p>slow-firstpass<br />
默认：无<br />
说明：随着预设值机制在r1177版本的出现，使用–pass 1会在解析命令行时增加以下设置：<code>ref 1</code>
<code>no-8x8dct</code><code>partitions i4x4 (if originally enabled, else none)</code><code>me dia</code><code>subme MIN( 2, subme )</code><code>trellis 0</code><br />
如果设置preset=placebo则自动关闭此特性。如果想显式关闭此特性，使用slow-firstpass。</p>
  </li>
</ul>

<h2 id="section-2">帧类型</h2>

<ul>
  <li>
    <p>keyint<br />
默认：250<br />
说明：设置x264输出中最大的IDR帧（亦称关键帧）间距。<br />
IDR帧是视频流的“分隔符”，所有帧都不可以使用越过关键帧的帧作为参考帧。IDR帧是I帧的一种，所以它们也不参照其它帧。这意味着它们可以作为视频的搜索（seek）点。<br />
通过这个设置可以设置IDR帧的最大间隔帧数（亦称最大图像组长度）。较大的值将导致IDR帧减少（会用占用空间更少的P帧和B帧取代），也就同时减弱了参照帧选择的限制。较小的值导致减少搜索一个随机帧所需的平均时间。<br />
建议：默认值（fps的10倍）对大多数视频都很好。如果在为蓝光、广播、直播流或者其它什么专业流编码，也许会需要更小的图像组长度（一般等于fps）。<br />
参见：min-keyint, scenecut, intra-refresh</p>
  </li>
  <li>
    <p>min-keyint<br />
默认：auto（keyint/10）<br />
说明：参见keyint的说明。过小的keyint范围会导致产生“错误的”IDR帧（比如说，一个闪屏场景，参见上一篇blog）。此选项限制了IDR帧之间的最小距离。<br />
建议：默认，或者与fps相等<br />
参见：keyint, scenecut</p>
  </li>
  <li>
    <p>no-scenecut<br />
默认：无<br />
说明：完全关闭自适应I帧决策。<br />
参见：scenecut</p>
  </li>
  <li>
    <p>scenecut<br />
默认：40<br />
说明：设置决策使用I帧、IDR帧的阈值（场景变换检测）。<br />
x264会计算每一帧与前一帧的不同程度并得出一个值。如果这个值低于scenecut，那么就算检测到一个“场景变换”。如果此时距离上一帧的距离小于 min-keyint则插入一个I帧，反之则插入一个IDR帧。较高的值会增加侦测到“场景变换”纪律。参见更详细的<a href="http://forum.doom9.org/showthread.PHP?t=121116">工作原理</a><br />
设置scenecut=0与no-scenecut等效。<br />
建议：使用默认值<br />
参见：keyint, min-keyint, no-scenecut</p>
  </li>
  <li>
    <p>intra-refresh<br />
默认：off<br />
说明：让x264为每keyint数量的帧使用宏块内部编码取代IDR帧。块以水平移动列的方式更新，也叫刷新波。对于低延迟的流，这样可以让帧的尺寸比使用标准的IDR帧更加保持恒定。而且这样可以增强视频流对丢包的容错能力。这个选项会降低压缩率，所以在确实需要的时候才选择它。<br />
还有一些有意思的事情：1、第一帧依然是IDR帧。2、内部宏块只在P帧中存在，刷新波在一个或多个B帧后的P帧中广泛存在。3、主要的压缩率下降原因是在宏块中新（左边）的波并不能参考旧（右边）的波。<br />
建议：使用默认值</p>
  </li>
  <li>
    <p>bframes
默认：3<br />
说明：设置x264可使用的B帧的最大连续数量。<br />
没有B帧时，一个典型的x264流帧类型是这样的：IPPPPP…PI。如果设置了-bframes 2，那么两个连续的P帧就可以用B帧替换，然后就像这样：IBPBBPBPPPB…PI。<br />
B帧和P帧的区别在于它可以参照它之后的帧，这个特点让它可以显著地提升压缩率。他们的平均品质受 –pbratio选项的控制。<br />
还有一些有意思的事情：<br />
1、x264有2种B帧，一种可以作为参照帧，一种不能；<br />
2、关于x264如何决策B帧或P帧，可以看看这个ffmpeg-devel<a href="http://article.gmane.org /gmane.comp.video.ffmpeg.devel/29064">邮件列表</a>。这种情况下帧类型看起来就像这样IBBBPBBBPBPI（假设设置 –bframes 3）。<br />
参见：–no-b-adapt, –b-bias, –b-pyramid, –ref, –pbratio, –partitions, –weightb</p>
  </li>
  <li>
    <p>b-adapt
默认：1<br />
说明：设置B帧决策算法，这个选项会影响到x264使用P帧或者B帧。<br />
0 —— 关闭。总是使用B帧。和以前的 no-b-adapt选项效果相同；<br />
1 —— ‘快速’算法。快速，–b-frames越大速度越快。推荐配合使用–bframes 16；<br />
2 —— ‘最佳’算法，慢速，–b-frames越大速度越慢；<br />
注意：多趟编码时，只有第一趟编码的此选项起效，因为第一趟编码结束时，帧类型就已经被决定了。</p>
  </li>
  <li>
    <p>b-bias<br />
默认：0<br />
说明：调节使用B帧的力度。越大的值越偏向B帧，可以在-100和100之间选择。100或-100不能保证完全或是全是B帧（使用 –b-adapt 0）。请只在你认为你能做出比x264更好的码率控制时才使用这个选项。<br />
参见： –b-frames, –ipratio</p>
  </li>
  <li>
    <p>b-pyramid
默认：normal<br />
说明：允许B帧作为参照帧。如果关闭，那么只有I帧和P帧才能作为参照帧。可以作为参照帧的B帧的量化参数会介于P帧和普通B帧之间。只在–b-frames设置大于等于2时此选项才生效。如果是在为蓝光光盘编码，请使用none或者strict。<br />
none —— 不允许B帧作为参照帧；<br />
strict —— 一个图像组内只允许一个B帧参照帧，这是蓝光编码强制要求的标准；<br />
normal —— 任意使用B帧参照帧；<br />
参见：–bframes, –refs, –no-mixed-refs</p>
  </li>
  <li>
    <p>open-gop
默认：none<br />
说明：Open-GOP是一个提升压缩效率的编码技术。它有以下选项：<br />
none —— 关闭<br />
normal —— 开启<br />
bluray —— 开启。一个稍低效的open-GOP版本，因为normal模式不能用于蓝光编码<br />
有些解码器不能完全支持open-GOP流，因此这个选项默认关闭。如果要用，请测试你的解码器。
更多open-gop的资料参见该<a href="http://forum.doom9.org/showthread.php?p=1300124#post1300124">链接</a></p>
  </li>
  <li>
    <p>no-cabac<br />
默认：无<br />
说明：关闭CABAC (Context Adaptive Binary Arithmetic Coder)压缩，使用较为低效的CAVLC (Context Adaptive Variable Length Coder)。这两者在压缩效率和解码效率上有10%-20%的差别。</p>
  </li>
  <li>
    <p>ref<br />
默认：3<br />
说明：控制DPB (Decoded Picture Buffer)的大小。可以在0-16之间选择。简单地说，就是设置P帧可以选择它之前的多少帧作为参照帧（B帧的值要小1-2，取决于那个B帧能不能作为参照）。最小可以选择值1，只参照自己前面的那帧。注意H.264标准限制了每个level可以参照的帧的数量。如果选择level4.1，1080p最大选4，720p最大选9。<br />
参照： –b-pyramid, –no-mixed-refs, –level</p>
  </li>
  <li>
    <p>no-deblock<br />
默认：无<br />
说明：完全关闭内置去块滤镜。不推荐使用。<br />
参见： –deblock</p>
  </li>
  <li>
    <p>deblock<br />
默认：0:0<br />
说明：调节H.264标准中的内置去块滤镜。这是个性价比很高的选则。详解参见<a href="http://forum.doom9.org/showthread.php?t=109747">参数运作原理</a>。
参见: –no-deblock</p>
  </li>
  <li>
    <p>slices  　　
默认：0  　　
说明：设置每帧的分片数，强制使用矩形分片。（会被–slice-max-size 或 –slice-max-mbs选项覆盖)如果是在为蓝光光盘编码，设置为4。如果不是，不要使用这个选项，除非你确定你需要它。  　　
参见：–slice-max-size, –slice-max-mbs  　　　　</p>
  </li>
  <li>
    <p>slice-max-size  　　
默认：0  　　
说明：设置每个分块包括NAL头的最大大小（bytes）。 (目前与 –interlaced选项不兼容)  　　
参见：–slices  　　</p>
  </li>
  <li>slice-max-mbs  　　
默认：0  　　
说明：设置每个分块包含的最大宏块数量。 (目前与 –interlaced选项不兼容)  　　
参见：–slices 
 　　</li>
  <li>
    <p>tff<br />
说明：开启隔行编码并设置上半场在前。x264的隔行编码使用MBAFF，因此效率不如逐行扫描。所以，仅在需要在隔行显示的设备上显示时才开启这个选项（或是送给x264之前无法进行反隔行扫描）。这个选项会触发 –pic-struct开启。</p>
  </li>
  <li>
    <p>bff<br />
说明：开启隔行编码并设置下半场在前。更多信息同–tff。</p>
  </li>
  <li>
    <p>constrained-intra<br />
默认：无<br />
说明：开启SVC编码的底层要求的强制帧内预测。选择每个人都无视SVC了，你也可以忽略这个设置。</p>
  </li>
  <li>
    <p>pulldown<br />
默认：none<br />
说明：为你的输入流（逐行扫描的，固定帧率的）使用一组预设的“软性电视模式”。“软性电视模式”在HandBrake Wiki里面有很好的解释。<br />
可选的参数有：none、22、32、64、double、triple、euro。除了none之外的选项都会触发 –pic-struct开启。</p>
  </li>
  <li>fake-interlaced<br />
默认：无<br />
说明：把流标志为隔行的但不按隔行编码。用于编码25p和30p的蓝光兼容视频。</li>
</ul>

<h2 id="section-3">码率控制</h2>

<ul>
  <li>
    <p>qp<br />
默认：无<br />
说明：三种可选的码率控制方法之一。设置x264使用固定量化参数模式。给定的数量将被作为P帧的量化参数，I帧和B帧的量化参数由–ipratio and –pbratio参数进一步算出。QP模式适用固定的量化参数，这意味着最终的文件大小是不可知的（可以通过一些其他方法预测）。设置为0将产出无损的输出。相同视觉质量时，QP模式产出的文件比crf模式大。QP模式将关闭自适应量化器，因为它是固定QP的。
这个选项和 –bitrate和–crf是互斥的，三者只能选一个，参见<a href="http://blog.yikuyiku.com/index.php/archives/1901">原理</a>。一般而言crf都能代替QP模式，不过QP因为完全不需要预测所以它会运行地更快些。<br />
参见：–bitrate, –crf, –ipratio, –pbratio</p>
  </li>
  <li>
    <p>bitrate<br />
默认：无<br />
说明：三种可选的码率控制方法之二。设置x264使用固定目标比特率模式。固定目标比特率意味着最终文件的大小是可知的，但是目标的质量是不可知的。 x264会试图让最终文件的整体码率与给定的码率相等。参数的量纲为kilobits/sec（8bit = 1byte）。通常这个选项和–pass选项配合进行2趟编码。
这个选项和 –qp和–crf是互斥的，三者只能选一个，参见<a href="http://blog.yikuyiku.com/index.php/archives/1901">原理</a>。<br />
参见：–qp, –crf, –ratetol, –pass, –stats</p>
  </li>
  <li>
    <p>crf
默认：23.0<br />
说明：三种可选的码率控制方法之二。固定ratefactor。QP是固定量化器，bitrate是固定文件大小，crf则是固定“质量”。crf可以提供跟QP一样的视觉的质量，但是文件更小。crf的单位是ratefactor。
crf是通过降低那些“不那么重要”的帧的质量做到这一切的。“不那么重要”意思是过于耗费码率又难以用肉眼察觉的帧，比如复杂或者超高速运行的场景。省下来的码率会用在其它更有效的帧里。
crf编码比2趟编码快，因为它相当于省略了第1趟编码。所以crf的最终码率也是不可预测的。你应该根据应用场景来选择码率控制方式。这个选项和 –qp和–crf是互斥的，三者只能选一个，参见<a href="http://blog.yikuyiku.com/index.php/archives/1901">原理</a>。<br />
参见：–qp, –bitrate</p>
  </li>
  <li>
    <p>rc-lookahead<br />
默认：40<br />
说明：为mb-tree ratecontrol（Macroblock Tree Ratecontrol）和vbv-lookahead设置可用的帧的数量。最大可设置为250。对于mb-tree而言，调大这个值会得到更准确地结果，但也会更慢。mb-tree能使用的最大值是–rc-lookahead和–keyint中较小的那一个。对于vbv-lookahead而言，调大这个值会得更稳定和精确的码率控制。vbv-lookahead能使用的最大值是如下公式算出来的：<code>MIN(rc-lookahead, MAX(–keyint, MAX(–vbv-maxrate, –bitrate) / –vbv-bufsize * –fps))</code><br />
参见：–no-mbtree, –vbv-bufsize, –vbv-maxrate</p>
  </li>
  <li>
    <p>vbv-maxrate<br />
默认：0<br />
说明：设置VBV（Video Buffering Verifier）可用的最大码率。使用VBV会降低视频质量，只在真正需要的才设定它。<br />
参见：–vbv-bufsize, –vbv-init，<a href="http://mewiki.project357.com/wiki/X264_Encoding_Suggestions#VBV_Encoding">详解</a></p>
  </li>
  <li>
    <p>vbv-bufsize<br />
默认：0<br />
说明：设置VBV（Video Buffering Verifier）可用的最大缓冲区，单位是kilobits。使用VBV会降低视频质量，只在真正需要的才设定它。<br />
参见：–vbv-maxsize, –vbv-init，<a href="http://mewiki.project357.com/wiki/X264_Encoding_Suggestions#VBV_Encoding">详解</a></p>
  </li>
  <li>
    <p>vbv-init<br />
默认：0.9<br />
说明：设置重放之前必须先载入多大的VBV缓冲。如果值小于1，那么大小就为 vbv-init * vbv-bufsize。如果大于1，则是以kbits为单位的值。<br />
参见：–vbv-maxsize, –vbv-bufsize</p>
  </li>
  <li>
    <p>crf-max<br />
默认：无<br />
说明：类似 –qp-max，但是设置的是最大的ratefactor值而不是量化参数。这个选项仅用于crf和vbv同时启用的时候。它阻止x264使用小于给定值的ratefactor（也就是“质量”），哪怕会违反vbv。一般用于流服务器。<a href="http://Git.videolan.org /gitweb.cgi/x264.git/?a=commit; h=81eee062a4ce9aae1eceb3befcae855c25e5ec52">更多的信息</a>。<br />
参见：–crf, –vbv-maxrate, –vbv-bufsize</p>
  </li>
  <li>
    <p>qpmin<br />
默认：10<br />
说明：设置x264可以使用的最小量化器。量化参数越小，输出越接近输入。使用某些值时，x264的输出可以和输入看起来完全一样，虽然其实并不是精确相同的，通常就够了没有必要使用更多比特在宏块上了。
如果开启了自适应量化器（默认开启），则不鼓励提高qpmin的值，那样可能会降低帧的平坦部分的质量。<br />
参见：–qpmax, –ipratio</p>
  </li>
  <li>
    <p>qpmax<br />
默认：51<br />
说明：qpmin的反面，设置x264可以使用的最大量化器。默认值51是H.264标准中的最大值，质量非常低。默认值51其实相当于没有设置 qpmax。如果你想控制x264输出的最低品质，也许你想要把这个值调低一点（调到30-40最低了），但一般而言不推荐调节这个值。<br />
参见：–qpmin, –pbratio, –crf-max</p>
  </li>
  <li>
    <p>qpstep<br />
默认：4<br />
说明：设置2帧间量化器最大的可变值。</p>
  </li>
  <li>
    <p>ratetol<br />
默认：1.0<br />
说明：这个参数有2个可能的含义：<br />
1、在1趟bitrate编码时，这个参数控制x264可以偏离给定的平均目标比特率的百分比。可以设置为inf完全关闭码率溢出侦测。最低可以设置为 0.01。较高的值可以让x264更好地处理影片结束部分的复杂场景。对于这个目的而言单位是百分比（1.0意味着允许1%的bitrate偏差）。很多影片（比如说动作打斗片）在最后的片段里十分复杂。1趟编码并不知道哪里是最复杂的片断，往往到最后比特都已经用完了。把rateol设置为inf就能解决这个问题，它允许编码器用类似 –crf的方式工作，当然，文件大小会溢出。<br />
2、当开启了vbv时（只要使用了任何–vbv-开头的选项就会开启），这个选项意味着vbv的强度。更高的值意味着允许更高的在设定的vbv值上下波动。在这个含义时，可以使用任意的度量单位。</p>
  </li>
  <li>
    <p>ipratio<br />
默认：1.40<br />
说明：设置平均的I帧的量化器相比P帧量化器增值。更高的值意味着更高的I帧质量。<br />
参见：–pbratio</p>
  </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SODB RBSP EBSP 的区别与联系]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/22/sodb-rbsp-ebsp/"/>
    <updated>2017-06-22T08:48:25-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/22/sodb-rbsp-ebsp</id>
    <content type="html"><![CDATA[
<p>简单总结 SODB、RBSP、EBSP、NALU 和 H.264 字节流的联系。</p>

<!--more-->

<ul>
  <li>SODB：String of Data Bits，数据比特串，它是最原始的编码数据。</li>
  <li>RBSP：Raw Byte Sequence Payload, 原始字节序列载荷，它是在 SODB 的后面添加了结尾比特和若干比特<code>0</code>，以便字节对齐。</li>
  <li>EBSP：Encapsulate Byte Sequence Payload，扩展字节序列载荷，它是在 RBSP 基础上添加了防校验字节<code>0x03</code>后得到的。</li>
</ul>

<p>关系大致如下：</p>

<p><code>SODB</code>+<code>RBSP Stop bit</code>+<code>0 bits</code>= <code>RBSP</code></p>

<p><code>RBSP part1</code>+<code>0x03</code>+<code>RBSP part2</code>+<code>0x03</code>+…+<code>RBSP partn</code> = <code>EBSP</code></p>

<p><code>NALU Header</code>+<code>EBSP</code>=<code>NALU</code></p>

<p><code>start code</code>+<code>NALU</code>+…+<code>start code</code>+<code>NALU</code>=<code>H.264 Byte Stream</code></p>

<p>在 H264 SPEC 中，SODB 定义如下：</p>

<blockquote>
  <p>3.149 string of data bits(SODB) : A sequence of some number of bits representing syntax elements present within a raw byte sequence payload prior to the raw byte sequnece payload stop bit.Within an SODB,the left-most bit is considered to be the first and most significant bit,and the right-most bit is considered to be the last and least significant bit。</p>
</blockquote>

<p>要组成一个 NALU 单元，首先要有原始数据，称之为 SODB 数据。它是原始的 H264 数据编码得到的，不包含 3 字节/4 字节的起始码，即不包含<code>0x000001</code>/<code>0x00000001</code>,同样的也不包括 1 字节的 NALU 头，NALU 头部信息包含了一些基础信息，比如 NALU 类型。</p>

<blockquote>
  <p>注意：起始码包括两种：3 字节(0x000001) 和 4 字节(0x00000001)，在 SPS、PPS 和 Access Unit 的第一个 NALU 使用 4 字节起始码，其余情况均使用 3 字节起始码。</p>
</blockquote>

<p>在 H264 SPEC 中，RBSP 定义如下：</p>

<blockquote>
  <p>3.118 raw byte sequence payload(RBSP): A syntax structure containing an integer number of bytes that is encapsulated in a NAL unit.An RBSP is either empty or has the form of a string of data bits containing syntax elements followed by an RBSp stop bit and followed by zero or more subsequent bits equal to 0.
3.119 raw byte sequence payload(RBSP) stop bit: A bit equal to 1 present within a raw byte sequence payload(RBSP) after a string of data bits.The location of the end of the string of data bits within an RBSP can be identified by searching from the end of the RBSP for the RBSP stop bit, which is the last non-zero bit in the RBSP.</p>
</blockquote>

<p>在 SODB 结束处添加表示结束的 bit 1 来表示 SODB 已经结束，因此添加的 bit 1 称为<code>rbsp_stop_one_bit</code>, <code>RBSP</code>也需要字节对齐，为此需要在<code>rbsp_stop_one_bit</code>后添加若干 0 补齐。<br />
简单说，要在 SODB 后面追加两样东西形成 RBSP ：</p>

<ol>
  <li>rbsp_stop_one_bit = 1</li>
  <li>rbsp_alignment_zero_bit(s) = 0(s)</li>
</ol>

<p>RBSP 的生成过程：首先，如果 SODB 的内容是空的，则 RBSP 的内容也是空的；其次，如果 SODB 的内容非空，RBSP 的第一个字节取自 SODB 的第 1 到第 8 个比特，RBSP 字节内部按照从左到右从高到低的顺序排列。
以此类推，RBSP 中的每个字节都直接取自 SODB 的相应比特。RBSP的最后一个字节包含 SODB 的最后几个比特，以及 trailing bits。其中，trailing bits 的第一个比特为 1，其余的比特为 0,保证字节对齐。最后，
在结尾添加 0x0000,即 CABAC_ZERO_WORD，从而形成 RBSP。</p>

<p><img src="http://lazybing.github.io/images/sodb_rbsp/sodb_rbsp.PNG" /></p>

<p>EBSP 的生成过程：NALU 数据 + 起始码就形成了Annex B 格式，起始码包括两种，0x00000001 或 0x000001。为了不让NALU的主体与起始码之间产生竞争，在对 RBSP 进行扫描时，如果遇到连续的两个<code>0x00</code>字节，则在该两个字节后面添加一个<code>0x03</code>字节。在解码的时候将该<code>0x03</code>字节去掉，也成为脱壳操作。
通过该种方式形成 EBSP，这需要将近两倍的整帧图像码流大小。为了减少存储器需求，在每个 macroblock 结束后，即检查该 macroblock 的 SODB 的起始码竞争问题，并保留 SODB 的最后两个字节的零字节个数，以便与下一个 macroblock 的 SODB 的开始字节形成连续的起始码竞争检测。对一帧图像的最后一个 macroblock，先添加结尾停止 bit，在检查起始码竞争。</p>

<p>替换规则如下：</p>

<ul>
  <li>0x000000 =&gt; 0x00000300</li>
  <li>0x000001 =&gt; 0x00000301</li>
  <li>0x000002 =&gt; 0x00000302</li>
  <li>0x000003 =&gt; 0x00000303</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 下载、安装和使用]]></title>
    <link href="http://lazybing.github.io/blog/2017/06/09/x264-download-install-and-use/"/>
    <updated>2017-06-09T08:51:11-07:00</updated>
    <id>http://lazybing.github.io/blog/2017/06/09/x264-download-install-and-use</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#x264-" id="markdown-toc-x264-">x264 获取代码：</a></li>
  <li><a href="#x264--1" id="markdown-toc-x264--1">x264 编译和安装</a></li>
  <li><a href="#x264--2" id="markdown-toc-x264--2">x264 的使用</a></li>
</ul>

<p><a href="http://www.videolan.org/developers/x264.html">x264官网</a>对 x264 项目进行了简单的描述，包括
<!--more--></p>

<h2 id="x264-">x264 获取代码：</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git clone http://git.videolan.org/git/x264.git</span></code></pre></td></tr></table></div></figure>

<h2 id="x264--1">x264 编译和安装</h2>

<p>此处记录的是在Linux下的编译和安装：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd x264
</span><span class="line">.configure
</span><span class="line">sudo make
</span><span class="line">sudo make install</span></code></pre></td></tr></table></div></figure>

<p>注意，如果想要在 Linux 下使用 GDB 进行逐步调试，需要修改<code>.configure</code>后生成的<code>config.mak</code>文件，将里面的<code>CC=gcc</code>改为<code>CC=gcc -g</code>。</p>

<p>之后就可以使用 X264 来进行编码 H264 格式的视频了。</p>

<h2 id="x264--2">x264 的使用</h2>
<p>x264 的使用可以通过命令行<code>x264 --help</code>来获取。格式一般为</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">x264 [options] -o outfile infile</span></code></pre></td></tr></table></div></figure>

<p>其中的输入文件可以是<code>raw</code>文件、<code>.y4m</code>文件等，输出文件格式可以是<code>.264</code>、<code>.mkv</code>、<code>.flv</code>和<code>.mp4</code>；其中输入文件如果是<code>raw</code>文件，需要在 infile 后面通过输入参数（–input-res 640x360）来指定分辨率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMpeg 实现视频编码、解码、封装、解封装、转码、缩放以及添加水印]]></title>
    <link href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/"/>
    <updated>2017-01-01T07:17:10-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ffmpeg-" id="markdown-toc-ffmpeg-">FFMpeg 编码实现</a></li>
  <li><a href="#ffmpeg--1" id="markdown-toc-ffmpeg--1">FFMpeg 解码实现</a></li>
  <li><a href="#ffmpeg--2" id="markdown-toc-ffmpeg--2">FFMpeg 封装实现</a></li>
  <li><a href="#ffmpeg--3" id="markdown-toc-ffmpeg--3">FFMpeg 解封装实现</a></li>
  <li><a href="#ffmpeg--4" id="markdown-toc-ffmpeg--4">FFMpeg 转码的实现</a></li>
  <li><a href="#ffmpeg--5" id="markdown-toc-ffmpeg--5">FFMpeg 视频缩放实现</a></li>
  <li><a href="#ffmpeg--6" id="markdown-toc-ffmpeg--6">FFMpeg 添加水印实现</a></li>
</ul>

<p><a href="&quot;https://ffmpeg.org/&quot;">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理，本文主要利用 FFMpeg 官方提供的 SDK 实现音视频最简单的几个实例：编码、解码、封装、解封装、转码、缩放以及添加水印。<br />
<!--more-->
接下来会由发现问题－＞分析问题－＞解决问题－＞实现方案，循序渐进的完成。<br />
参考代码：<a href="&quot;https://github.com/lazybing/ffmpeg-study-recording&quot;">ｌａｚｙｂｉｎｇ</a></p>

<h2 id="ffmpeg-">FFMpeg 编码实现</h2>

<p>本例子实现的是将视频域 YUV 数据编码为压缩域的帧数据，编码格式包含了 H.264/H.265/MPEG1/MPEG2 四种 CODEC 类型。
实现的过程，可以大致用如下图表示:</p>

<p><img src="http://lazybing.github.io/images/ffmpeg_sdk/encoder.png" /></p>

<p>从图中可以大致看出视频编码的流程:</p>

<ul>
  <li>首先要有未压缩的 YUV 原始数据。</li>
  <li>其次要根据想要编码的格式选择特定的编码器。</li>
  <li>最后编码器的输出即为编码后的视频帧。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>存放待压缩的 YUV 原始数据。此时可以利用 FFMpeg 提供的 AVFrame 结构体，并根据 YUV 数据来填充 AVFrame　结构的视频宽高、像素格式；根据视频宽高、像素格式可以分配存放数据的内存大小，以及字节对齐情况。</li>
  <li>获取编码器。利用想要压缩的格式，比如　H.264/H.265/MPEG1/MPEG2 等，来获取注册的编解码器，编解码器在 FFMpeg 中用 AVCodec 结构体表示，对于编解码器，肯定要对其进行配置，包括待压缩视频的宽高、像素格式、比特率等等信息，这些信息，FFMpeg 提供了一个专门的结构体 AVCodecContext 结构体。</li>
  <li>存放编码后压缩域的视频帧。FFMpeg 中用来存放压缩编码数据相关信息的结构体为 AVPacket。最后将 AVPacket 存储的压缩数据写入文件即可。</li>
</ul>

<hr />

<p>AVFrame 结构体的分配使用<code>av_frame_alloc()</code>函数，该函数会对 AVFrame 结构体的某些字段设置默认值，它会返回一个指向 AVFrame 的指针或 NULL指针(失败)。AVFrame 结构体的释放只能通过<code>av_frame_free()</code>来完成。注意，该函数只能分配 AVFrame 结构体本身，不能分配它的 data buffers 字段指向的内容，该字段的指向要根据视频的宽高、像素格式信息手动分配，本例使用的是<code>av_image_alloc()</code>函数。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//allocate AVFrame struct</span>
</span><span class="line"><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Frame Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//fill AVFrame struct fields</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
</span><span class="line"><span class="n">frame</span><span class="o">-&gt;</span><span class="n">pix_fmt</span> <span class="o">=</span> <span class="n">AV_PIX_FMT_YUV420P</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//allocate AVFrame data buffers field point</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">av_image_alloc</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//write input file data to frame-&gt;data buffer</span>
</span><span class="line"><span class="n">fread</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">widht</span><span class="o">*</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="p">...</span>
</span><span class="line"><span class="n">av_frame_free</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>编解码器相关的 AVCodec 结构体的分配使用<code>avcodec_find_encoder(enum AVCodecID id)</code>完成，该函数的作用是找到一个与 AVCodecID 匹配的已注册过得编码器；成功则返回一个指向 AVCodec ID 的指针，失败返回 NULL 指针。该函数的作用是确定系统中是否有该编码器，只是能够使用编码器进行特定格式编码的最基本的条件，要想使用它，至少要完成两个步骤：</p>

<ol>
  <li>根据特定的视频数据，对该编码器进行特定的配置；</li>
  <li>打开该编码器。</li>
</ol>

<p>针对第一步中关于编解码器的特定参数，FFMpeg 提供了一个专门用来存放 AVCodec 所需要的配置参数的结构体 AVCodecContext 结构。它的分配使用<code>avcodec_alloc_context3(const AVCodec *codec)</code>完成，该函数根据特定的 CODEC 分配一个 AVCodecContext 结构体，并设置一些字段为默认参数，成功则返回指向 AVCodecContext 结构体的指针，失败则返回 NULL 指针。分配完成后，根据视频特性，手动指定与编码器相关的一些参数，比如视频宽高、像素格式、比特率、GOP 大小等。最后根据参数信息，打开找到的编码器，此处使用<code>avcodec_open2()</code>函数完成。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//register all encoder and decoder</span>
</span><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line">
</span><span class="line"><span class="c1">//find the encoder</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_encoder</span><span class="p">(</span><span class="n">codec_id</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could Not Find the Encoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//allocate the AVCodecContext and fill it&#39;s fields</span>
</span><span class="line"><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecCtx Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="mi">4000000</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">width</span>    <span class="o">=</span> <span class="n">frameWidth</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">height</span>   <span class="o">=</span> <span class="n">frameHeight</span><span class="p">;</span>
</span><span class="line"><span class="n">codecCtx</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="o">=</span> <span class="p">(</span><span class="n">AVRational</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="c1">//open the encoder</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Encoder Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<hr />

<p>存放编码数据的结构体为 AVPacket，使用之前要对该结构体进行初始化，初始化函数为<code>av_init_packet(AVPacket *pkt)</code>，该函数会初始化 AVPacket 结构体中一些字段为默认值，但它不会设置其中的 data 和 size 字段，需要单独初始化,如果此处将 data 设为 NULL、size 设为 0，编码器会自动填充这两个字段。</p>

<p>有了存放编码数据的结构体后，我们就可以利用编码器进行编码了。FFMpeg 提供的用于视频编码的函数为<code>avcodec_encode_video2</code>,它作用是编码一帧视频数据，该函数比较复杂，单独列出如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avcodec_encode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">,</span>
</span><span class="line">                          <span class="k">const</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_packet_ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>它会接收来自 AVFrame-&gt;data 的视频数据，并将编码数据放到 AVPacket-&gt;data 指向的位置，编码数据大小为 AVPacket-&gt;size。</p>

<p>其参数和返回值的意义：</p>

<ul>
  <li>avctx: AVCodecContext 结构，指定了编码的一些参数；</li>
  <li>avPkt: AVPacket对象的指针，用于保存输出的码流；</li>
  <li>frame：AVFrame结构，用于传入原始的像素数据；</li>
  <li>got_packet_ptr:输出参数，用于标识是否已经有了完整的一帧；</li>
  <li>返回值：编码成功返回 0， 失败返回负的错误码；</li>
</ul>

<p>编码完成后就可将AVPacket-&gt;data内的编码数据写到输出文件中；代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVPacket</span> <span class="n">pkt</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//init AVPacket</span>
</span><span class="line"><span class="n">av_init_packet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkt</span><span class="p">);</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//encode the image</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_encode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pkt</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">got_output</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Encode Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="err">｝</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">got_output</span><span class="p">){</span>
</span><span class="line">	<span class="n">fwrite</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/encoder.c">编码实现</a>。</p>

<h2 id="ffmpeg--1">FFMpeg 解码实现</h2>

<p>解码实现的是将压缩域的视频数据解码为像素域的 YUV 数据。实现的过程，可以大致用如下图所示。</p>

<p><img src="http://lazybing.github.io/images/ffmpeg_sdk/decoder.png" /></p>

<p>从图中可以看出，大致可以分为下面三个步骤：</p>

<ul>
  <li>首先要有待解码的压缩域的视频。</li>
  <li>其次根据压缩域的压缩格式获得解码器。</li>
  <li>最后解码器的输出即为像素域的 YUV 数据。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>关于输入数据。首先，要分配一块内存，用于存放压缩域的视频数据；之后，对内存中的数据进行预处理，使其分为一个一个的 AVPacket 结构（AVPacket 结构的简单介绍如上面的编码实现）。最后，将 AVPacket 结构中的 data 数据给到解码器。</li>
  <li>关于解码器。首先，利用 CODEC_ID 来获取注册的解码器；之后，将预处理过得视频数据给到解码器进行解码。</li>
  <li>关于输出。FFMpeg 中，解码后的数据存放在 AVFrame 中；之后就将 AVFrame 中的 data 字段的数据存放到输出文件中。</li>
</ul>

<hr />

<p>对于输入数据，首先，通过 fread 函数实现将固定长度的输入文件的数据存放到一块 buffer 内。H.264中一个包的长度是不定的，读取固定长度的码流通常不可能刚好读出一个包的长度；对此，FFMpeg 提供了一个 AVCoderParserContext 结构用于解析读到 buffer 内的码流信息，直到能够取出一个完整的 H.264 包。为此，FFMpeg 提供的函数为<code>av_parser_parse2</code>，该函数比较复杂，定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">av_parser_parse2</span><span class="p">(</span><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
</span><span class="line">                     <span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">poutbuf</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">poutbuf_size</span><span class="p">,</span>
</span><span class="line">                     <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buf_size</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">int64_t</span> <span class="n">pts</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">dts</span><span class="p">,</span>
</span><span class="line">                     <span class="kt">int64_t</span> <span class="n">pos</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>函数的参数和返回值含义如下：</p>

<ul>
  <li>AVCodecParserContext *s:初始化过的 AVCodecParserContext 对象，决定了码流该以怎样的标准进行解析；</li>
  <li>AVCodecContext *avctx：预先定义好的 AVCodecContext 对象；</li>
  <li>uint8_t **poutbuf：AVPacket：：data 的地址，保存解析完成的包数据。</li>
  <li>int *poutbuf_size：AVPacket 的实际数据长度，如果没有解析出完整的一个包，该值为 0；</li>
  <li>const uint8_t *but:待解码的码流的地址；</li>
  <li>int buf_size:待解码的码流的长度；</li>
  <li>int64_t pts, int64_t dts:显示和解码的时间戳；</li>
  <li>int64_t pos:码流中的位置；</li>
  <li>返回值为解析所使用的比特位的长度；</li>
</ul>

<p>FFMpeg 中为我们提供的该函数常用的使用方式为：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">in_len</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">myparser</span><span class="p">.</span> <span class="n">AVCodecContext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">in_data</span><span class="p">,</span> <span class="n">in</span> <span class="n">len</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">dts</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">	<span class="n">in_data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">in_len</span>  <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
</span><span class="line">		<span class="n">decode_frame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>如果参数poutbuf_size的值为0，那么应继续解析缓存中剩余的码流；如果缓存中的数据全部解析后依然未能找到一个完整的包，那么继续从输入文件中读取数据到缓存，继续解析操作，直到pkt.size不为0为止。</p>

<p>因此，关于输入数据的处理，代码大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//open input file</span>
</span><span class="line"><span class="kt">FILE</span> <span class="o">*</span><span class="n">pInput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Input_FileName</span><span class="p">,</span> <span class="s">&quot;rb+&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pInput_File</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Input File Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class="line"><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class="line">							<span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class="line">							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class="line">	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="n">decode_frame</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意，上面提到的<code>av_parser_parse2</code>函数用的几个参数，其实是与具体的编码格式有关的，它们应该在之前已经分配好了，我们只是放到后面来讲一下，因为它们是与具体的解码器强相关的。</p>

<hr />

<p>对于解码器。与上面提到的编码实现类似，首先，根据 CODEC_ID 找到注册的解码器 AVCodec，FFMpeg 为此提供的函数为<code>avcodec_find_decoder()</code>；其次，根据找到的解码器获取与之相关的解码器上下文结构体 AVCodecC，使用的函数为编码中提到的<code>avcodec_alloc_context3</code>；再者，如上面提到的要获取完整的一个 NALU，解码器需要分配一个 AVCodecParserContext 结构，使用函数<code>av_parser_init</code>；最后，前面的准备工作完成后，打开解码器，即可调用 FFMpeg 提供的解码函数<code>avcodec_decode_video2</code>对输入的压缩域的码流进行解码，并将解码数据存放到 AVFrame-&gt;data 中。代码实现大致如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codecCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecParserContext</span> <span class="o">*</span><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">//register all encoder and decoder</span>
</span><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate AVFrame to Store the Decode Data</span>
</span><span class="line"><span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc Frame Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Find the  AVCodec Depending on the CODEC_ID</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Find the Decoder Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate the AVCodecContext </span>
</span><span class="line"><span class="n">codecCtx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codecCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecCtx Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Allocate the AVCodecParserContext </span>
</span><span class="line"><span class="n">pCodecParserCtx</span> <span class="o">=</span> <span class="n">av_parser_init</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pCodecParserCtx</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Alloc AVCodecParserContext Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//Open the Decoder</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could not Open the Decoder</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//read compressed bitstream form file to buffer</span>
</span><span class="line"><span class="n">uDataSize</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INBUF_SIZE</span><span class="p">,</span> <span class="n">pInput_File</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>	<span class="c1">//decode finish</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="c1">//decode the data in the buffer to AVPacket.data</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="n">uDataSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">	<span class="n">len</span> <span class="o">=</span> <span class="n">av_parser_parse2</span><span class="p">(</span><span class="n">pCodecParserCtx</span><span class="p">,</span> <span class="n">codecCtx</span><span class="p">,</span>
</span><span class="line">							<span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
</span><span class="line">							<span class="n">pDataPtr</span><span class="p">,</span> <span class="n">uDataSize</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">,</span> <span class="n">AV_NOPTS_VALUE</span><span class="p">,</span>
</span><span class="line">							<span class="n">AV_NOPTS_VALUE</span><span class="p">);</span>
</span><span class="line">	<span class="n">uDataSize</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">	<span class="n">uDataPtr</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">	<span class="k">if</span><span class="p">(</span><span class="n">pkt</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">	<span class="c1">//decode start</span>
</span><span class="line">	<span class="n">avcodec_decode_video2</span><span class="p">(</span><span class="n">codecCtx</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">got_frame</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>注意，上面解码的过程中，针对具体的实现，可能要做一些具体参数上的调整，此处只是理清解码的流程。</p>

<hr />

<p>对于输出数据。解码完成后，解码出来的像素域的数据存放在 AVFrame 的 data 字段内，只需要将该字段内存放的数据之间写文件到输出文件即可。解码函数<code>avcodec_decode_video2</code>函数完成整个解码过程，对于它简单介绍如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class="line">                         <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class="line">                         <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>该函数各个参数的意义：</p>

<ul>
  <li>AVCodecContext *avctx：编解码器上下文对象，在打开编解码器时生成；</li>
  <li>AVFrame *picture: 保存解码完成后的像素数据；我们只需要分配对象的空间，像素的空间codec会为我们分配好；</li>
  <li>int *got_picture_ptr: 标识位，如果为1，那么说明已经有一帧完整的像素帧可以输出了;</li>
  <li>const AVPacket *avpkt: 前面解析好的码流包；</li>
</ul>

<p>由此可见，当标识位为1时，代表解码一帧结束，可以写数据到文件中。代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">pOutput_File</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">Output_FileName</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pOutput_File</span><span class="p">){</span>
</span><span class="line">	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Open Output File Fail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">){</span>
</span><span class="line">	<span class="n">fwrite</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span> <span class="n">Len</span><span class="p">,</span> <span class="n">pOutput_File</span><span class="p">)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>解码的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/decoder.c">解码实现</a>。</p>

<h2 id="ffmpeg--2">FFMpeg 封装实现</h2>

<p>本例子实现的是将视频数据和音频数据，按照一定的格式封装为特定的容器，比如FLV、MKV、MP4、AVI等等。实现的过程，可以大致用如下图表示：</p>

<p><img src="http://lazybing.github.io/images/ffmpeg_sdk/muxer.png" /></p>

<p>从图中可以大致看出视频封装的流程：</p>

<ul>
  <li>首先要有编码好的视频、音频数据。</li>
  <li>其次要根据想要封装的格式选择特定的封装器。</li>
  <li>最后利用封装器进行封装。</li>
</ul>

<p>根据流程可以推倒出大致的代码实现：</p>

<ul>
  <li>利用给定的YUV数据编码得到某种 CODEC 格式的编码视频（可以参见上面提到的<a href="http://lazybing.github.io/blog/2017/01/01/ffmpeg-sdk-learning/#ffmpeg-">编码实现</a>），同样的方法得到音频数据。</li>
  <li>获取输出文件格式。获取输出文件格式可以直接指定文件格式，比如FLV/MKV/MP4/AVI等，也可以通过输出文件的后缀名来确定，或者也可以选择默认的输出格式。根据得到的文件格式，其中可能有视频、音频等，为此我们需要为格式添加视频、音频、并对格式中的一些信息进行设置（比如头）。</li>
  <li>利用设置好的音频、视频、头信息等，开始封装。</li>
</ul>

<hr />

<p>对于由 YUV 数据得到编码的视频数据部分，不再重复。直接看与 Muxer 相关的部分，与特定的 Muxer 相关的信息，FFMpeg 提供了一个 AVFormatContext 的结构体描述，并用<code>avformat_alloc_output_context2()</code>函数来分配它。该函数的声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avformat_alloc_output_context2</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">**</span><span class="n">ctx</span><span class="p">,</span> <span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">oformat</span><span class="p">,</span>
</span><span class="line">                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中：</p>

<ul>
  <li>ctx:输出到 AVFormatContext 结构的指针，如果函数失败则返回给该指针为 NULL。</li>
  <li>oformat：指定输出的 AVOutputFormat 类型，如果设为 NULL，则根据 format_name 和 filename 生成。</li>
  <li>format_name:输出格式的名称，如果设为 NULL，则使用 filename 默认格式。</li>
  <li>filename：目标文件名，如果不使用，可以设为 NULL。</li>
  <li>返回值：&gt;=0 则成功，否则失败。</li>
</ul>

<p>代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">;</span>
</span><span class="line"><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* allocate the output media context */</span>
</span><span class="line"><span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Could not deduce output format from file extension: using MPEG.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">avformat_alloc_output_context2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;mpeg&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oc</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">fmt</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">oformat</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>有了表示媒体文件格式的 AVFormatContext 结构后，就需要根据媒体格式来判断是否需要往媒体文件中添加视频流、音频流（有的媒体文件，这两种流并不是必须的）；以 MP4 格式的媒体文件为例，我们需要一路视频流、一路音频流。因此需要创建一路流，FFMpeg 提供的创建流的函数为<code>avformat_new_stream()</code>，该函数完成向 AVFormatContext 结构体中所代码的媒体文件中添加数据流，函数声明如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVStream</span> <span class="o">*</span><span class="nf">avformat_new_stream</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">c</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中：</p>

<ul>
  <li>s:AVFormatContext 结构，表示要封装生成的视频文件。</li>
  <li>c：视频或音频流的编码器的指针。</li>
  <li>返回值：指向生成的 stream 对象的指针；失败则返回 NULL。</li>
</ul>

<p>注意：对于 Muxer，该函数必须在调用<code>avformat_write_header()</code>前调用。使用完成后，需要调用<code>avcodec_close()</code>和<code>avformat_free_context()</code>来清理由它分配的内容。</p>

<p>该函数调用完成后，一个新的 AVStream 便已经加入到输出文件中，下面就需要设置 stream 的 id 和 codec 等参数。以视频流为例，代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">OutputStream</span> <span class="o">*</span><span class="n">ost</span><span class="p">;</span>
</span><span class="line"><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">oc</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodec</span> <span class="o">**</span><span class="n">codec</span><span class="p">;</span>
</span><span class="line"><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="n">AVStream</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="n">st</span> <span class="o">=</span> <span class="n">avformat_new_stream</span><span class="p">(</span><span class="n">oc</span><span class="p">,</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not allocate stream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="n">st</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">oc</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="n">c</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>参数设置完成后，就可以打开编码器并为编码器分配必要的内存。步骤跟之前的类似，以视频为例，示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="c1">//open the codec</span>
</span><span class="line"><span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_open</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not open video codec: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">av_err2str</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="c1">//allocate and init a re-usable frame</span>
</span><span class="line"><span class="n">ost</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">alloc_picture</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>接下来进行真正的封装：首先，为媒体文件添加头部信息,FFMpeg 为此提供的函数为<code>avformat_write_header()</code>。其次，将编码好的音视频 AVPacket 包添加到媒体文件中去，FFMpeg 为此提供的函数为<code>av_interleaved_write_frame()</code>。最后，写入文件尾的数据，FFMpeg 为此提供的函数为<code>av_write_trailer()</code>。</p>

<p>封装的大致流程已经完成了，剩余的是一些收尾工作，比如释放分配的内存、结构体等等。</p>

<p>完整实现请移步<a href="https://github.com/lazybing/ffmpeg-study-recording/blob/master/muxer.c">封装实现</a>。</p>

<video width="640" height="320" preload="metadata" controls=""><source src="https://github.com/lazybing/lazybing.github.io/blob/source/images/ffmpeg.mp4" type="video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;" /></video>

<h2 id="ffmpeg--3">FFMpeg 解封装实现</h2>

<h2 id="ffmpeg--4">FFMpeg 转码的实现</h2>

<h2 id="ffmpeg--5">FFMpeg 视频缩放实现</h2>

<h2 id="ffmpeg--6">FFMpeg 添加水印实现</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avformat_find_stream_info]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info/"/>
    <updated>2016-12-25T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/25/avformat_find_stream_info</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">调用关系</a></li>
</ul>

<p><code>avformat_find_stream_info</code>主要是读媒体文件的包(packets)，然后从中提取出流的信息。
对于没有头部信息的文件格式尤其有用，比如<code>MPEG</code>。文件的逻辑位置不会被改变，读取出来
的包会被缓存起来供以后处理。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);</span></code></pre></td></tr></table></div></figure>
<p>返回值：&gt;=0–&gt;OK,或出错返回AVERROR_xxx</p>

<p>注意，该函数并不保证能够打开所有的 codec，因此将options 设置为非NULL用于返回一些信息是非常好的行为。</p>

<h2 id="section-1">调用关系</h2>

<p><img src="http://lazybing.github.io/images/avformat_find_stream_info/avformat_find_stream_info.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Addr2line 的介绍与使用]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/22/addr2line-use/"/>
    <updated>2016-12-22T07:26:02-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/22/addr2line-use</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#addr2line-" id="markdown-toc-addr2line-">addr2line 简介</a></li>
  <li><a href="#addr2line--1" id="markdown-toc-addr2line--1">addr2line 的使用示例</a></li>
  <li><a href="#addr2line--2" id="markdown-toc-addr2line--2">addr2line 的原理</a></li>
</ul>

<p><code>addr2line</code>的作用是将地址转化为文件名和行号。<br />
<!--more--></p>

<h2 id="addr2line-">addr2line 简介</h2>
<p>在编写程序时，经常会遇到出现程序 crah 的情况，此时如果有 core stack 打印出来还好，但如果没有 core stack 的话，debug 就会比较困难。addr2line 可以很好地解决这个问题。</p>

<p><code>addr2line</code>能够将地址转换为文件名和行号。给定一个可执行文件的地址或者一个可重定位目标的目标偏移，addr2line 就会利用 debug 信息来计算出与该地址关联的文件名和行号。</p>

<p>使用的可执行文件或可重定位目标使用<code>-e</code>选项来指定、可重定位目标的部分使用<code>-j</code>选项来指定。</p>

<p><code>addr2line</code>有两种操作模式：<br />
1. 在命令行下，直接指定十六进制的地址，addr2line 为每个地址显示文件名和行号。<br />
2. addr2line 从标准输入中读取十六进制地址，并且为每个地址输出文件名和行号到标准输出中。</p>

<p>输出格式为<code>FILENAME:LINENO</code>，默认情况下，每个输入地址对应一行输出。</p>

<h2 id="addr2line--1">addr2line 的使用示例</h2>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">div</span><span class="p">(</span><span class="kt">int</span> <span class="n">numerator</span><span class="p">,</span> <span class="kt">int</span> <span class="n">denominator</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">numerator</span>   <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">div</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译：gcc -o div -g div.c
生成可执行文件<code>div</code>后，执行该文件：./div 得到如下error:</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Floating point exception (core dumped)</span></code></pre></td></tr></table></div></figure>

<p>此时并没有任何其他提示信息，我们可以通过<code>dmesg</code>查看信息：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">[ 4709.210137] traps: div[2500] trap divide error ip:400524 sp:7ffcd27fd630 error:0 in div[400000+1000]</span></code></pre></td></tr></table></div></figure>
<p>通过该信息可以看出，ip 指向的地址为<code>400524</code>，得到该地址后，我们就可以使用 addr2line 来定位出错的位置。 
<code>addr2line -e div 400524</code> 得到结果如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">/home/bing/work/study/div.c:5</span></code></pre></td></tr></table></div></figure>

<p>可以很直观的显示，该 core  dump 信息是在<code>div.c</code>的 line 5。</p>

<h2 id="addr2line--2">addr2line 的原理</h2>
<p><code>addr2line</code>之所以能够利用可执行文件将地址信息转换为行号，是因为在可执行 ELF 文件中存有这些对应的信息。可以使用<code>readelf</code>来查看这些信息。例如上面的<code>div</code>文件，通过readelf div 可以看到如下信息：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> Line Number Statements:
</span><span class="line">  [0x00000026]  Extended opcode 2: set Address to 0x400516
</span><span class="line">  [0x00000031]  Special opcode 8: advance Address by 0 to 0x400516 and Line by 3 to 4
</span><span class="line">  [0x00000032]  Special opcode 146: advance Address by 10 to 0x400520 and Line by 1 to 5
</span><span class="line">  [0x00000033]  Special opcode 104: advance Address by 7 to 0x400527 and Line by 1 to 6
</span><span class="line">  [0x00000034]  Special opcode 36: advance Address by 2 to 0x400529 and Line by 3 to 9
</span><span class="line">  [0x00000035]  Special opcode 216: advance Address by 15 to 0x400538 and Line by 1 to 10
</span><span class="line">  [0x00000036]  Special opcode 104: advance Address by 7 to 0x40053f and Line by 1 to 11
</span><span class="line">  [0x00000037]  Special opcode 105: advance Address by 7 to 0x400546 and Line by 2 to 13
</span><span class="line">  [0x00000038]  Special opcode 216: advance Address by 15 to 0x400555 and Line by 1 to 14
</span><span class="line">  [0x00000039]  Advance PC by 2 to 0x400557
</span><span class="line">  [0x0000003b]  Extended opcode 1: End of Sequence</span></code></pre></td></tr></table></div></figure>
<p>从上面可以看出到 addr 在 0x400520-0x400527之间时，行号为5.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_decode_video2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video/"/>
    <updated>2016-12-20T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/20/avcodec_decode_video</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a></li>
</ul>

<p><code>avcodec_decode_video</code>函数的作用是解码<code>AVPacket</code>中的压缩数据，解码为图像数据。
某些解码器支持在一个<code>AVPacket</code>中包含多帧，这类的解码器只解码第一帧。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
</span><span class="line">                         int *got_picture_ptr,
</span><span class="line">                         const AVPacket *avpkt);</span></code></pre></td></tr></table></div></figure>

<p>注意，输入内存的对齐字节(AV_INPUT_BUFFER_PADDING_SIZE)比实际读取字节要大，因为某些
最优流可能会读取 32 或 64 bits 每次。</p>

<p>在将压缩数据packets给到解码器之前，<code>AVCodecContext</code>必须用<code>avcodec_open2</code>设置过。</p>

<p>函数参数：</p>

<ul>
  <li><code>AVCodecContext *</code>。</li>
  <li><code>AVFrame *</code>存放解码的视频数据，它使用<code>av_frame_alloc</code>获得一个<code>AVFrame</code>。解码器会调用
<code>AVCodecContext.get_buffer2</code>回调函数为实际的位图分配内存。</li>
  <li><code>got_picture_ptr</code>,如果没有帧可以解码，该值被设为0。否则，它是非零值。</li>
  <li><code>AVPacket *</code>包含输入缓存。该结构体使用<code>av_init_packet</code>创建后会设置<code>data</code>和<code>size</code>，某些
解码器可能需要更多的字段,如<code>flags &amp; AV_PKT_FLAG_KEY</code>。解码器被设置为使用最少的字段。</li>
</ul>

<p>返回值：如果解码出错，返回负值；否则返回使用的字节数。</p>

<h2 id="section-1">源码分析</h2>

<p><code>avcodec_decode_video2</code>函数比较简单，主要做了以下几个工作：</p>

<ol>
  <li>对输入的字段进行一些列的检查工作，比如宽高是否正确，输入是否为视频等等。</li>
  <li>真正的解码，通过<code>avctx-&gt;codec-&gt;decode</code>实现，它会调用相应的<code>AVCodec</code>的 decode 函数，完成解码。</li>
  <li>对得到的<code>AVFrame</code>进行一些字段进行赋值，例如宽高、像素格式等等。</li>
</ol>

<figure class="code"><figcaption><span>avcodec_decode_video2 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">attribute_align_arg</span> <span class="nf">avcodec_decode_video2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">picture</span><span class="p">,</span>
</span><span class="line">                                              <span class="kt">int</span> <span class="o">*</span><span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class="line">                                              <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="c1">//检测输入参数</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span> <span class="s">&quot;Invalid media type for video</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">got_picture_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">((</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">coded_width</span> <span class="o">||</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">coded_height</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">av_image_check_size</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">coded_width</span><span class="p">,</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">coded_height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">avctx</span><span class="p">))</span>
</span><span class="line">        <span class="k">return</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="c1">//真正的解码</span>
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">decode</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">picture</span><span class="p">,</span> <span class="n">got_picture_ptr</span><span class="p">,</span>
</span><span class="line">            <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="c1">//设置参数</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">AV_CODEC_CAP_DR1</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&gt;</span><span class="n">sample_aspect_ratio</span><span class="p">.</span><span class="n">num</span><span class="p">)</span>    <span class="n">picture</span><span class="o">-&gt;</span><span class="n">sample_aspect_ratio</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">sample_aspect_ratio</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span>                      <span class="n">picture</span><span class="o">-&gt;</span><span class="n">width</span>               <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">picture</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">)</span>                     <span class="n">picture</span><span class="o">-&gt;</span><span class="n">height</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">picture</span><span class="o">-&gt;</span><span class="n">format</span> <span class="o">==</span> <span class="n">AV_PIX_FMT_NONE</span><span class="p">)</span>   <span class="n">picture</span><span class="o">-&gt;</span><span class="n">format</span>              <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>以H.265解码器为例，解码示例如下：</p>

<figure class="code"><figcaption><span>ff_hevc_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="s">&quot;hevc&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="s">&quot;HEVC (High Efficiency Video Coding)&quot;</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中<code>hevc_decode_frame</code>是解码器的真正的解码函数，定义如下：</p>
<figure class="code"><figcaption><span>hevc_decode_frame </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="nf">hevc_decode_frame</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">got_output</span><span class="p">,</span>
</span><span class="line">                             <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">    <span class="n">HEVCContext</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avpkt</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">ff_hevc_output_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ret</span>    <span class="o">=</span> <span class="n">decode_nal_units</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">avpkt</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">hwaccel</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">hwaccel</span><span class="o">-&gt;</span><span class="n">end_frame</span><span class="p">(</span><span class="n">avctx</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_ERROR</span><span class="p">,</span>
</span><span class="line">                   <span class="s">&quot;hardware accelerator failed to decode picture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">            <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="cm">/* verify the SEI checksum */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">err_recognition</span> <span class="o">&amp;</span> <span class="n">AV_EF_CRCCHECK</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">is_decoded</span> <span class="o">&amp;&amp;</span>
</span><span class="line">            <span class="n">s</span><span class="o">-&gt;</span><span class="n">is_md5</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">ret</span> <span class="o">=</span> <span class="n">verify_md5</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">frame</span><span class="p">);</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">err_recognition</span> <span class="o">&amp;</span> <span class="n">AV_EF_EXPLODE</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">ff_hevc_unref_frame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">~</span><span class="mi">0</span><span class="p">);</span>
</span><span class="line">                <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">is_md5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">is_decoded</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">av_log</span><span class="p">(</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AV_LOG_DEBUG</span><span class="p">,</span> <span class="s">&quot;Decoded frame with POC %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">poc</span><span class="p">);</span>
</span><span class="line">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">is_decoded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">output_frame</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">        <span class="n">av_frame_move_ref</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">output_frame</span><span class="p">);</span>
</span><span class="line">        <span class="o">*</span><span class="n">got_output</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">avpkt</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：av_read_frame]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/15/av_read_frame/"/>
    <updated>2016-12-15T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/15/av_read_frame</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数调用关系</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">源码分析</a></li>
</ul>

<p><code>av_read_frame</code>函数的作用是返回文件中保存的数据。它会文件中保存的数据分成不同的帧，
每次调用都会返回一帧。注意，该函数不会忽略帧与帧之间无效数据(非帧数据)，目的是给解码器
最多的信息用于解码。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int av_read_frame(AVFormatContext *s, AVPacket *pkt);</span></code></pre></td></tr></table></div></figure>

<p>如果<code>pkt-&gt;buf</code>是 NULL,包直到下一次调用<code>av_read_frame</code>或<code>avformat_close_input</code>时都是有效的。
不需要时，包必须通过<code>av_free_packet</code>释放。对于视频，<code>packet</code>只包含一帧；对于音频，如果每帧有固定大小(如 PCM 或 ADPCM 数据)，
<code>packet</code>可以包含多个音频帧（必须是整数帧）,如果音频帧大小可变(如MPEG 音频)，它只能包含一帧数据。</p>

<p><code>pkt-&gt;pts</code><code>pkt-&gt;dts</code><code>pkt-&gt;duration</code>都是以<code>AVStream.time_base_units</code>为单位的。
如果视频格式里包含 B 帧，<code>pkt-&gt;pts</code>可以是<code>AV_NOPTS_VALUE</code>,因此如果不解压缩数据，最好
查看<code>pkt-&gt;dts</code>。</p>

<p>如果函数返回0，正确；小于0，则为到文件尾或出错。</p>

<h2 id="section-1">函数调用关系</h2>

<p><img src="http://lazybing.github.io/images/av_read_frame/av_read_frame.png" /></p>

<h2 id="section-2">源码分析</h2>

<p><code>av_read_frame</code>函数会判断在未解码缓存中是否有数据，如果有数据则调用<code>read_from_packet_buffer</code>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_open2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/10/avcodec-open2/"/>
    <updated>2016-12-10T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/10/avcodec-open2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">函数声明</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">函数使用示例</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">函数源码分析</a></li>
</ul>

<p><code>avcodec_open2</code>函数实现的功能为利用给定的<code>AVCodec</code>结构初始化<code>AVCodecContext</code>结构。</p>

<!--more-->

<h2 id="section">函数声明</h2>

<p><code>avcodec_open2</code>的声明如下:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);</span></code></pre></td></tr></table></div></figure>

<p>函数参数说明：</p>

<ul>
  <li>avctx:需要初始化的context.</li>
  <li>codec:</li>
  <li>options:</li>
  <li>返回值：如果返回0，正确。失败则返回负数。</li>
</ul>

<p>该函数利用给定的<code>AVCodec</code>结构初始化<code>AVCodecContext</code>结构，在使用该函数之前，<code>AVCodecContext</code>
必须已经用<code>avcodec_alloc_context3()</code>函数分配出来。</p>

<p><code>AVCodec</code>结构在使用该函数之前，由<code>avcodec_find_decoder_by_name</code><code>avcodec_find_encoder_by_name</code>
<code>avcodec_find_decoder</code>或<code>avcodec_find_encoder</code>提前得到。</p>

<p>注意，在正式解码之前(比如使用<code>avcodec_decode_video2()</code>之前)，必须调用<code>avcodec_open2</code>函数。</p>

<h2 id="section-1">函数使用示例</h2>

<p>示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line"><span class="n">av_dict_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;2.5M&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">AV_CODEC_ID_H264</span><span class="p">);</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="n">context</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-2">函数源码分析</h2>

<p><code>avcodec_open2</code>的逻辑非常简单，首先是进行一些参数检测、之后调动<code>AVCodec</code>的init函数。大概步骤如下：</p>

<ul>
  <li>各种函数参数检测。</li>
  <li>各种结构体分配内存。</li>
  <li>将输入的<code>AVDictionary</code>形式的选项设置到<code>AVCodecContext</code>。</li>
  <li>其他一些零散的查，检查输入参数是否符合编码器的要求。</li>
  <li>调用<code>AVCodec</code>的init函数初始化具体的解码器。</li>
</ul>

<p>此处重点分析调用<code>AVCodec</code>的init函数处。 以 HEVC 解码器为例。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="s">&quot;hevc&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="s">&quot;HEVC (High Efficiency Video Coding)&quot;</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">update_thread_context</span> <span class="o">=</span> <span class="n">hevc_update_thread_context</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">init_thread_copy</span>      <span class="o">=</span> <span class="n">hevc_init_thread_copy</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">capabilities</span>          <span class="o">=</span> <span class="n">AV_CODEC_CAP_DR1</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_DELAY</span> <span class="o">|</span>
</span><span class="line">                             <span class="n">AV_CODEC_CAP_SLICE_THREADS</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_FRAME_THREADS</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">profiles</span>              <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="n">profiles</span><span class="p">),</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中 init 函数定义如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="n">av_cold</span> <span class="kt">int</span> <span class="nf">hevc_decode_init</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">HEVCContext</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">ff_init_cabac_states</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">internal</span><span class="o">-&gt;</span><span class="n">allocate_progress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="n">hevc_init_context</span><span class="p">(</span><span class="n">avctx</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">enable_parallel_tiles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">s</span><span class="o">-&gt;</span><span class="n">picture_struct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">active_thread_type</span> <span class="o">&amp;</span> <span class="n">FF_THREAD_SLICE</span><span class="p">)</span>
</span><span class="line">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">threads_number</span> <span class="o">=</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">thread_count</span><span class="p">;</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">        <span class="n">s</span><span class="o">-&gt;</span><span class="n">threads_number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">extradata_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">extradata</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">=</span> <span class="n">hevc_decode_extradata</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="n">hevc_decode_free</span><span class="p">(</span><span class="n">avctx</span><span class="p">);</span>
</span><span class="line">            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">((</span><span class="n">avctx</span><span class="o">-&gt;</span><span class="n">active_thread_type</span> <span class="o">&amp;</span> <span class="n">FF_THREAD_FRAME</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">avctx</span><span class="o">-&gt;</span><span class="n">thread_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">            <span class="n">s</span><span class="o">-&gt;</span><span class="n">threads_type</span> <span class="o">=</span> <span class="n">FF_THREAD_FRAME</span><span class="p">;</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">            <span class="n">s</span><span class="o">-&gt;</span><span class="n">threads_type</span> <span class="o">=</span> <span class="n">FF_THREAD_SLICE</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG源码分析：avio_open2]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/07/avio-open2/"/>
    <updated>2016-12-07T04:21:48-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/07/avio-open2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#avioopen2-" id="markdown-toc-avioopen2-">avio_open2 声明和定义</a></li>
  <li><a href="#avioopen2--1" id="markdown-toc-avioopen2--1">avio_open2 调动关系</a></li>
  <li><a href="#avioopen2--2" id="markdown-toc-avioopen2--2">avio_open2 源码分析</a>    <ul>
      <li><a href="#ffurlopen-" id="markdown-toc-ffurlopen-">ffurl_open 函数</a>        <ul>
          <li><a href="#ffurlalloc-" id="markdown-toc-ffurlalloc-">ffurl_alloc 函数</a></li>
          <li><a href="#ffurlconnect-" id="markdown-toc-ffurlconnect-">ffurl_connect 函数</a></li>
        </ul>
      </li>
      <li><a href="#ffiofdopen-" id="markdown-toc-ffiofdopen-">ffio_fdopen 函数</a></li>
    </ul>
  </li>
</ul>

<p>avio_open2 主要实现创建并初始化一个 AVIOContext，用于访问由 url 指定文件。
<!--more--></p>

<h2 id="avioopen2-">avio_open2 声明和定义</h2>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int avio_open2(AVIOContext **s, const char *url, int flags,
</span><span class="line">               const  AVIOInterruptCB *int_cb, AVDictionary **options);</span></code></pre></td></tr></table></div></figure>

<p>各个参数的含义如下：</p>

<ul>
  <li><code>AVIOContext **s</code>:函数调用成功后，创建并初始化该<code>AVIOContext</code>结构体。</li>
  <li><code>const char *url</code>:输入输出协议的地址。</li>
  <li><code>int flags</code>:打开地址的方式(只读、只写、读写)。AVIO_FLAG_READ/AVIO_FLAG_WRITE/AVIO_FLAG_READ_WRITE.</li>
  <li><code>const AVIOInterruptCB *int_cb</code>: 调用函数。</li>
  <li><code>AVDictionary **options</code>: 一般为NULL。</li>
</ul>

<p>与<code>avio_open2</code>相似的还有<code>avio_open</code>函数，<code>avio_open</code>会调用<code>avio_open2</code>,并将 int_cb 和 options 设置为 NULL。</p>

<h2 id="avioopen2--1">avio_open2 调动关系</h2>

<p><code>avio_open2</code>的调用函数关系如下：</p>

<p><img src="http://lazybing.github.io/images/avio_open2/avio_open2.png" /></p>

<h2 id="avioopen2--2">avio_open2 源码分析</h2>

<p><code>avio_open2</code>函数的定义如下：</p>

<figure class="code"><figcaption><span>avio_open2 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">avio_open2</span><span class="p">(</span><span class="n">AVIOContext</span> <span class="o">**</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
</span><span class="line">               <span class="k">const</span> <span class="n">AVIOInterruptCB</span> <span class="o">*</span><span class="n">int_cb</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">URLContext</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">err</span> <span class="o">=</span> <span class="n">ffurl_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">int_cb</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">er</span> <span class="o">=</span> <span class="n">ffio_fdopen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">        <span class="n">ffurl_close</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>avio_open2</code>调用的两个函数，<code>ffurl_open</code>和<code>ffio_fdopen</code>。<code>ffurl_open</code>用于初始化<code>URLContext</code>,<code>ffio_fdopen</code>用于根据<code>URLContext</code>初始化<code>AVIOContext</code>。</p>

<h3 id="ffurlopen-">ffurl_open 函数</h3>

<p>其中的<code>ffurl_open</code>函数定义如下：</p>

<figure class="code"><figcaption><span>ffurl_open </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">ffurl_open</span><span class="p">(</span><span class="n">URLContext</span> <span class="o">**</span><span class="n">puc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
</span><span class="line">               <span class="k">const</span> <span class="n">AVIOInterruptCB</span> <span class="o">*</span><span class="n">int_cb</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ffurl_alloc</span><span class="p">(</span><span class="n">puc</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">int_cb</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">options</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">puc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">priv_data_class</span> <span class="o">&amp;&amp;</span>
</span><span class="line">       <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">av_opt_set_dict</span><span class="p">((</span><span class="o">*</span><span class="n">puc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">priv_data</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">av_opt_set_dict</span><span class="p">(</span><span class="o">*</span><span class="n">puc</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">        <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="n">ffurl_connect</span><span class="p">(</span><span class="o">*</span><span class="n">puc</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="nl">fail</span><span class="p">:</span>
</span><span class="line">    <span class="n">ffurl_close</span><span class="p">(</span><span class="o">*</span><span class="n">puc</span><span class="p">);</span>
</span><span class="line">    <span class="o">*</span><span class="n">puc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>ffurl_open</code>主要调用两个函数<code>ffurl_alloc</code>和<code>ffurl_connect</code>。</p>

<h4 id="ffurlalloc-">ffurl_alloc 函数</h4>

<p><code>ffurl_alloc</code>用于查找合适的<code>URLProtocol</code>,并创建一个<code>URLContext</code>;</p>

<figure class="code"><figcaption><span>ffurl_alloc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">ffurl_alloc</span><span class="p">(</span><span class="n">URLContext</span> <span class="o">**</span><span class="n">puc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVIOInterruptCB</span> <span class="o">*</span><span class="n">int_cb</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">URLProtocol</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="err">……</span>
</span><span class="line">    <span class="n">p</span> <span class="o">=</span> <span class="n">url_find_protocol</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">url_alloc_for_protocol</span><span class="p">(</span><span class="n">puc</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">int_cb</span><span class="p">);</span>
</span><span class="line">    <span class="err">……</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>ffurl_alloc</code>调用两个函数：<code>url_find_protocol</code>根据文件路径查找合适的<code>URLProtocol</code>,<code>url_alloc_for_protocol</code>为查找到的<code>URLProtocol</code>创建<code>URLContext</code>。</p>

<figure class="code"><figcaption><span>ffurl_connect </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">ffurl_connect</span><span class="p">(</span><span class="n">URLContext</span> <span class="o">*</span><span class="n">uc</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">url_open2</span> <span class="o">?</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">url_open2</span><span class="p">(</span><span class="n">uc</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span><span class="o">:</span>
</span><span class="line">        <span class="n">uc</span><span class="o">-&gt;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">url_open</span><span class="p">(</span><span class="n">uc</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h4 id="ffurlconnect-">ffurl_connect 函数</h4>

<p><code>ffurl_connect</code>用于打开获得的<code>URLProtocol</code>.如果以<code>UDP</code>为例的话，它的<code>URLProtocol</code>定义如下,打开<code>URLProtocol</code>时，会调用到<code>udp_open</code>函数。</p>

<figure class="code"><figcaption><span>ff_udp_protocol </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">URLProtocol</span> <span class="n">ff_udp_protocol</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">name</span>                <span class="o">=</span> <span class="s">&quot;udp&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">url_open</span>            <span class="o">=</span> <span class="n">udp_open</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">url_read</span>            <span class="o">=</span> <span class="n">udp_read</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">url_write</span>           <span class="o">=</span> <span class="n">udp_write</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">url_close</span>           <span class="o">=</span> <span class="n">udp_close</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">url_get_file_handle</span> <span class="o">=</span> <span class="n">udp_get_file_handle</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_size</span>      <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UDPContext</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_class</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">udp_class</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">flags</span>               <span class="o">=</span> <span class="n">URL_PROTOCOL_FLAG_NETWORK</span><span class="p">,</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="ffiofdopen-">ffio_fdopen 函数</h3>

<p><code>ffio_fdopen</code>函数定义如下：</p>
<figure class="code"><figcaption><span>ffio_fdopen </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">ffio_fdopen</span><span class="p">(</span><span class="n">AVIOContext</span> <span class="o">**</span><span class="n">s</span><span class="p">,</span> <span class="n">URLContext</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
</span><span class="line">    <span class="err">……</span>
</span><span class="line">    <span class="n">buffer</span> <span class="o">=</span> <span class="n">av_malloc</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">avio_alloc_context</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AVIO_FLAG_WRITE</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
</span><span class="line">                            <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">ffurl_read</span><span class="p">,</span>
</span><span class="line">                            <span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">ffurl_write</span><span class="p">,</span>
</span><span class="line">                            <span class="p">(</span><span class="kt">int64_t</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">ffurl_ffurl_seek</span><span class="p">).</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>ffio_fdopen</code>会调用<code>avio_alloc_context</code>初始化一个<code>AVIOContext</code>, <code>avio_alloc_context</code>函数成功执行后会返回一个创建好的<code>AVIOContext</code>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_find_decoder和avcodec_find_encoder]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/06/av-find-encdec/"/>
    <updated>2016-12-06T06:18:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/06/av-find-encdec</id>
    <content type="html"><![CDATA[<p><code>avcodec_find_decoder</code>和<code>avcodec_find_encoder</code> 主要是查找 FFmpeg 的解码器和编码器。<br />
<!--more--></p>

<p>avcodec_find_decoder 和 avcodec_find_encoder 主要是利用 AVCodecID 来查找编解码器。<br />
其实质是遍历AVCodec 链表并且获得符合AVCodecID的元素。</p>

<p>avcodec_find_decoder 定义如下：</p>

<figure class="code"><figcaption><span>avcodec_find_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="o">*</span><span class="nf">avcodec_find_decoder</span><span class="p">(</span><span class="k">enum</span> <span class="n">AVCodecID</span> <span class="n">id</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">find_encdec</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>由定义可以看出，该函数利用 AVCodecID 查找 AVCodec，并将找到的 AVCodec 返回。
<code>find_encdec</code>定义如下：</p>

<figure class="code"><figcaption><span>find_encdec </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="nf">find_encdec</span><span class="p">(</span><span class="k">enum</span> <span class="n">AVCodecID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">encoder</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVCodec</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">experimental</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">p</span> <span class="o">=</span> <span class="n">first_avcodec</span><span class="p">;</span>
</span><span class="line">    <span class="n">id</span><span class="o">=</span> <span class="n">remap_deprecated_codec_id</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">((</span><span class="n">encoder</span> <span class="o">?</span> <span class="n">av_codec_is_encoder</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">av_codec_is_decoder</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span><span class="line">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">AV_CODEC_CAP_EXPERIMENTAL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">experimental</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">experimental</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">            <span class="p">}</span> <span class="k">else</span>
</span><span class="line">                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">experimental</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>其中<code>av_codec_is_decoder</code>定义如下：</p>

<figure class="code"><figcaption><span>av_codec_is_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">av_codec_is_decoder</span><span class="p">(</span><span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">codec</span> <span class="o">&amp;&amp;</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">decode</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>av_codec_is_encoder</code>定义如下：</p>

<figure class="code"><figcaption><span>av_codec_is_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">av_codec_is_encoder</span><span class="p">(</span><span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="n">codec</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">encode_sub</span> <span class="o">||</span> <span class="n">codec</span><span class="o">-&gt;</span><span class="n">encode2</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>查找编解码器除了上述的<code>avcodec_find_decoder</code>和<code>avcodec_find_encoder</code>外，还可以利用编解码器名字来查找函数为：avcodec_find_encoder_by_name 和 avcodec_find_decoder_by_name，在此不再赘述。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：avcodec_register_all]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/"/>
    <updated>2016-12-05T08:42:17-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/05/avcodec-register-all</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#avcodecregisterall-" id="markdown-toc-avcodecregisterall-">avcodec_register_all 框架</a></li>
  <li><a href="#section" id="markdown-toc-section">调用关系</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">注册一次</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">注册硬件加速器</a></li>
      <li><a href="#codec" id="markdown-toc-codec">注册codec</a></li>
      <li><a href="#parser" id="markdown-toc-parser">注册parser</a></li>
      <li><a href="#bitstream-filters" id="markdown-toc-bitstream-filters">注册bitstream filters</a></li>
    </ul>
  </li>
</ul>

<p>avcodec_register_all 提供注册<code>codec</code><code>parsers</code><code>filters</code>的功能。</p>

<!--more-->

<h2 id="avcodecregisterall-">avcodec_register_all 框架</h2>

<figure class="code"><figcaption><span>avcodec_register_all </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">avcodec_register_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span><span class="p">;</span>
</span><span class="line">    <span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* hardwar accelerators */</span>
</span><span class="line">    <span class="n">REGISTER_HWACCEL</span><span class="p">(</span><span class="n">H264_MMAL</span><span class="p">,</span><span class="n">h264_mmal</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/* video codecs */</span>
</span><span class="line">    <span class="n">REGISTER_DECODER</span><span class="p">(</span><span class="n">HEVC</span><span class="p">,</span><span class="n">hevc</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">    <span class="n">REGISTER_ENCDEC</span> <span class="p">(</span><span class="n">MPEG4</span><span class="p">,</span><span class="n">mpeg4</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">    <span class="cm">/* audio codecs */</span>
</span><span class="line">    <span class="n">REGISTER_ENCDEC</span> <span class="p">(</span><span class="n">AAC</span><span class="p">,</span><span class="n">aac</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">    <span class="cm">/* parsers */</span>
</span><span class="line">    <span class="n">REGISTER_PARSER</span><span class="p">(</span><span class="n">HEVC</span><span class="p">,</span><span class="n">hevc</span><span class="p">);</span>
</span><span class="line">    <span class="cm">/* bitstream filters */</span>
</span><span class="line">    <span class="n">REGISTER_BSF</span><span class="p">(</span><span class="n">HEVC_MP4TOANNEXB</span><span class="p">,</span><span class="n">hevc_mp4toannexb</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section">调用关系</h2>

<p><img src="http://lazybing.github.io/images/avcodec_register_all/avcodec_register_all.png" /></p>

<p>从<code>avcodec_register_all</code>的框架和调用关系图可以看出，该函数主要注册硬件加速器、codec、parsers、比特流过滤器等。</p>

<h2 id="section-1">源码分析</h2>

<h3 id="section-2">注册一次</h3>

<figure class="code"><figcaption><span>initialized_once </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>该段代码可以看出，当调用过该函数一次后，再次调用时，该函数直接返回。<br />
注意，这种方法在 FFMEPG 源码中非常常见。</p>

<h3 id="section-3">注册硬件加速器</h3>

<figure class="code"><figcaption><span>REGISTER_HWACCEL </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_HWACCEL(X, x)                                          \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVHWAccel ff_##x##_hwaccel;                              \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_HWACCEL)                                       \</span>
</span><span class="line"><span class="cp">            av_register_hwaccel(&amp;ff_##x##_hwaccel);                     \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>H264</code>为例，<code>REGISTER_HWACCEL(H264_MMAL, h264_mmal)</code>展开如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern AVHWAccel ff_h264_mmal_hwaccel;
</span><span class="line">if(CONFIG_H264_MMAL_HWACCEL)
</span><span class="line">    av_register_hwaccel(&amp;ff_h264_mmal_hwaccel);</span></code></pre></td></tr></table></div></figure>

<p><code>av_register_hwaccel(&amp;ff_h264_mmal_hwaccel)</code> 展开如下：</p>

<figure class="code"><figcaption><span>av_register_hwaccel </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_hwaccel</span><span class="p">(</span><span class="n">AVHWAccel</span> <span class="o">*</span><span class="n">hwaccel</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVHWAccel</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">last_hwaccel</span><span class="p">;</span>
</span><span class="line">    <span class="n">hwaccel</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">hwaccel</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_hwaccel</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hwaccel</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="codec">注册codec</h3>

<figure class="code"><figcaption><span>REGISTER_DECODER </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_DECODER(X, x)                                          \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVCodec ff_##x##_decoder;                                \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_DECODER)                                       \</span>
</span><span class="line"><span class="cp">            avcodec_register(&amp;ff_##x##_decoder);                        \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>HEVC</code>为例，<code>REGISTER_DECODER(HEVC, hevc)</code>展开如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern AVCodec ff_hevc_decoder;
</span><span class="line">if(CONFIG_HEVC_DECODER)
</span><span class="line">    avcodec_register(&amp;ff_hevc_decoder);</span></code></pre></td></tr></table></div></figure>

<p><code>avcodec_register(&amp;ff_hevc_decoder)</code>展开如下：</p>

<figure class="code"><figcaption><span>avcodec_register </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">av_cold</span> <span class="kt">void</span> <span class="nf">avcodec_register</span><span class="p">(</span><span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVCodec</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="n">avcodec_init</span><span class="p">();</span>
</span><span class="line">    <span class="n">p</span> <span class="o">=</span> <span class="n">last_avcodec</span><span class="p">;</span>
</span><span class="line">    <span class="n">codec</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">codec</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_avcodec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_static_data</span><span class="p">)</span>
</span><span class="line">        <span class="n">codec</span><span class="o">-&gt;</span><span class="n">init_static_data</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>ff_hevc_decoder 定义如下：</p>

<figure class="code"><figcaption><span>ff_hevc_decoder </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodec</span> <span class="n">ff_hevc_decoder</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">name</span>                  <span class="o">=</span> <span class="s">&quot;hevc&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">long_name</span>             <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="s">&quot;HEVC (High Efficiency Video Coding)&quot;</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">type</span>                  <span class="o">=</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">id</span>                    <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_size</span>        <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCContext</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_class</span>            <span class="o">=</span> <span class="o">&amp;</span><span class="n">hevc_decoder_class</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">init</span>                  <span class="o">=</span> <span class="n">hevc_decode_init</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">close</span>                 <span class="o">=</span> <span class="n">hevc_decode_free</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">decode</span>                <span class="o">=</span> <span class="n">hevc_decode_frame</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">flush</span>                 <span class="o">=</span> <span class="n">hevc_decode_flush</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">update_thread_context</span> <span class="o">=</span> <span class="n">hevc_update_thread_context</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">init_thread_copy</span>      <span class="o">=</span> <span class="n">hevc_init_thread_copy</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">capabilities</span>          <span class="o">=</span> <span class="n">AV_CODEC_CAP_DR1</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_DELAY</span> <span class="o">|</span>
</span><span class="line">                             <span class="n">AV_CODEC_CAP_SLICE_THREADS</span> <span class="o">|</span> <span class="n">AV_CODEC_CAP_FRAME_THREADS</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">profiles</span>              <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="n">profiles</span><span class="p">),</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="parser">注册parser</h3>

<figure class="code"><figcaption><span>REGISTER_PARSER </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_PARSER(X, x)                                           \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVCodecParser ff_##x##_parser;                           \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_PARSER)                                        \</span>
</span><span class="line"><span class="cp">            av_register_codec_parser(&amp;ff_##x##_parser);                 \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>HEVC</code>为例，<code>REGISTER_PARSER(HEVC, hevc)</code>展开如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern AVCoderParser ff_hevc_parser;
</span><span class="line">if(CONFIG_HEVC_PARSER)
</span><span class="line">    av_register_codec_parser(&amp;ff_hevc_parser);</span></code></pre></td></tr></table></div></figure>

<p><code>av_register_codec_parser(&amp;ff_hevc_parser)</code> 展开如下：</p>

<figure class="code"><figcaption><span>av_register_codec_parser </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_codec_parser</span><span class="p">(</span><span class="n">AVCodecParser</span> <span class="o">*</span><span class="n">parser</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">do</span> <span class="p">{</span>
</span><span class="line">        <span class="n">parser</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">av_first_parser</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">parser</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">av_first_parser</span><span class="p">,</span> <span class="n">parser</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">parser</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>ff_hevc_parser 定义如下：</p>

<figure class="code"><figcaption><span>ff_hevc_parser </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVCodecParser</span> <span class="n">ff_hevc_parser</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">codec_ids</span>      <span class="o">=</span> <span class="p">{</span> <span class="n">AV_CODEC_ID_HEVC</span> <span class="p">},</span>
</span><span class="line">    <span class="p">.</span><span class="n">priv_data_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCParserContext</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">parser_parse</span>   <span class="o">=</span> <span class="n">hevc_parse</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">parser_close</span>   <span class="o">=</span> <span class="n">hevc_parser_close</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">split</span>          <span class="o">=</span> <span class="n">hevc_split</span><span class="p">,</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="bitstream-filters">注册bitstream filters</h3>

<figure class="code"><figcaption><span>REGISTER_BSF </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_BSF(X, x)                                              \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVBitStreamFilter ff_##x##_bsf;                          \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_BSF)                                           \</span>
</span><span class="line"><span class="cp">            av_register_bitstream_filter(&amp;ff_##x##_bsf);                \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>HEVC</code>为例，<code>REGISTER_BSF(HEVC_MP4TOANNEXB, hevc_mp4toannexb)</code> 展开如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern AVBitStreamFilter ff_hevc_mp4toannexb_bsf;
</span><span class="line">if(CONFIG_HEVC_MP4TOANNEXB_BSF)
</span><span class="line">    av_register_bitstream_filter(&amp;ff_hevc_mp4toannexb_bsf);</span></code></pre></td></tr></table></div></figure>

<p><code>av_register_bitstream_filter(&amp;&amp;ff_hevc_mp4toannexb_bsf)</code> 展开如下：</p>

<figure class="code"><figcaption><span>av_register_bitstream_filter </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_bitstream_filter</span><span class="p">(</span><span class="n">AVBitStreamFilter</span> <span class="o">*</span><span class="n">bsf</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">do</span> <span class="p">{</span>
</span><span class="line">        <span class="n">bsf</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first_bitstream_filter</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">bsf</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">first_bitstream_filter</span><span class="p">,</span> <span class="n">bsf</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">bsf</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>ff_hevc_mp4toannexb_bsf 定义如下：</p>

<figure class="code"><figcaption><span>ff_hevc_mp4toannexb_bsf </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVBitStreamFilter</span> <span class="n">ff_hevc_mp4toannexb_bsf</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="s">&quot;hevc_mp4toannexb&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="k">sizeof</span><span class="p">(</span><span class="n">HEVCBSFContext</span><span class="p">),</span>
</span><span class="line">    <span class="n">hevc_mp4toannexb_filter</span><span class="p">,</span>
</span><span class="line">    <span class="n">hevc_mp4toannexb_close</span><span class="p">,</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFMPEG 源码分析：av_register_all]]></title>
    <link href="http://lazybing.github.io/blog/2016/12/05/av-register-all/"/>
    <updated>2016-12-05T04:45:48-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/12/05/av-register-all</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#avregisterall-" id="markdown-toc-avregisterall-">av_register_all 框架</a></li>
  <li><a href="#section" id="markdown-toc-section">调用关系</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">源码分析</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">注册一次</a></li>
      <li><a href="#codec" id="markdown-toc-codec">注册 codec</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">注册复用器</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">注册解复用器</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">注册协议</a></li>
    </ul>
  </li>
</ul>

<p><code>av_register_all()</code>几乎是所有使用 FFMPEG 编程调用的第一个函数。<code>av_register_all()</code>的主要功能是注册所有的 formats 和 protocols。</p>

<!--more-->

<h2 id="avregisterall-">av_register_all 框架</h2>

<p>首先列一下该函数的大体框架：</p>
<figure class="code"><figcaption><span>av_register_all </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span><span class="p">;</span>
</span><span class="line">    <span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">avcodec_register_all</span><span class="p">();</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/*(de)muxers*/</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">    <span class="n">REGISTER_MUXER</span>   <span class="p">(</span><span class="n">F4V</span><span class="p">,</span>              <span class="n">f4v</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line">    <span class="n">REGISTER_MUXDEMUX</span><span class="p">(</span><span class="n">FLV</span><span class="p">,</span>              <span class="n">flv</span><span class="p">);</span>
</span><span class="line">    <span class="n">REGISTER_MUXDEMUX</span><span class="p">(</span><span class="n">H264</span><span class="p">,</span>             <span class="n">h264</span><span class="p">);</span>
</span><span class="line">    <span class="n">REGISTER_MUXDEMUX</span><span class="p">(</span><span class="n">HEVC</span><span class="p">,</span>             <span class="n">hevc</span><span class="p">);</span>
</span><span class="line">    <span class="n">REGISTER_MUXER</span>   <span class="p">(</span><span class="n">MP4</span><span class="p">,</span>              <span class="n">mp4</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/*protocols*/</span>
</span><span class="line">    <span class="n">REGISTER_PROTOCOL</span><span class="p">(</span><span class="n">RTMP</span><span class="p">,</span>             <span class="n">rtmp</span><span class="p">);</span>
</span><span class="line">    <span class="n">REGISTER_PROTOCOL</span><span class="p">(</span><span class="n">TCP</span><span class="p">,</span>              <span class="n">tcp</span><span class="p">);</span>
</span><span class="line">    <span class="n">REGISTER_PROTOCOL</span><span class="p">(</span><span class="n">UDP</span><span class="p">,</span>              <span class="n">udp</span><span class="p">);</span>
</span><span class="line">    <span class="p">......</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section">调用关系</h2>
<p><img src="http://lazybing.github.io/images/av_register_all/av_register_all.png" /></p>

<p>从调用关系图可以看出，通过调用<a href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/">avcodec_register_all</a>注册了和编解码器有关的组件；硬件加速器、解码器、编码器、Parser、Bistream Filter等，以及复用器、解复用器、协议处理。</p>

<h2 id="section-1">源码分析</h2>

<h3 id="section-2">注册一次</h3>

<figure class="code"><figcaption><span>initialized_once </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">initialized</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="n">initialized</span><span class="p">)</span>
</span><span class="line">    <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="n">initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<p>该段代码可以看出，当调用过该函数一次后，再次调用时，该函数直接返回。<br />
注意，这种方法在 FFMEPG 源码中非常常见。</p>

<h3 id="codec">注册 codec</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">avcodec_register_all();</span></code></pre></td></tr></table></div></figure>
<p>该函数的作用为注册<code>codecs</code><code>parsers</code>和<code>filters</code>。<br />
该函数的源码，还请访问<a href="http://lazybing.github.io/blog/2016/12/05/avcodec-register-all/">avcodec_register_all</a>函数。</p>

<h3 id="section-3">注册复用器</h3>

<figure class="code"><figcaption><span>REGISTER_MUXER </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_MUXER(X, x)                                            \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVOutputFormat ff_##x##_muxer;                           \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_MUXER)                                         \</span>
</span><span class="line"><span class="cp">            av_register_output_format(&amp;ff_##x##_muxer);                 \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>MP4</code>为例，<code>REGISTER_MUXER(MP4, mp4)</code>展开如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern AVOutpusFormat ff_mp4_muxer;
</span><span class="line">if(CONFIG_MP4_MUXER)
</span><span class="line">    av_register_output_format(&amp;ff_mp4_muxer);</span></code></pre></td></tr></table></div></figure>

<p><code>av_register_output_format(&amp;ff_mp4_muxer)</code>展开如下：</p>

<figure class="code"><figcaption><span>av_register_output_format </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_output_format</span><span class="p">(</span><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVOutputFormat</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">last_oformat</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">format</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_oformat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-4">注册解复用器</h3>

<figure class="code"><figcaption><span>REGISTER_MUXER </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_DEMUXER(X, x)                                          \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVInputFormat ff_##x##_demuxer;                          \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_DEMUXER)                                       \</span>
</span><span class="line"><span class="cp">            av_register_input_format(&amp;ff_##x##_demuxer);                \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p><code>av_register_input_format(&amp;ff_mp4_muxer)</code>展开如下：</p>

<figure class="code"><figcaption><span>av_register_output_format </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_input_format</span><span class="p">(</span><span class="n">AVInputFormat</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVInputFormat</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">last_iformat</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">format</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_iformat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><figcaption><span>avpriv_atomic_ptr_cas </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="o">*</span><span class="nf">avpriv_atomic_ptr_cas</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">oldval</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">newval</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
</span><span class="line">    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atomic_lock</span><span class="p">);</span>
</span><span class="line">    <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">oldval</span><span class="p">)</span>
</span><span class="line">        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">newval</span><span class="p">;</span>
</span><span class="line">    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atomic_lock</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><figcaption><span>REGISTER_MUXDEMUX </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_MUXDEMUX(X, x) REGISTER_MUXER(X, x); REGISTER_DEMUXER(X, x)</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-5">注册协议</h3>

<figure class="code"><figcaption><span>REGISTER_PROTOCOL </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_PROTOCOL(X, x)                                         \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern URLProtocol ff_##x##_protocol;                           \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_PROTOCOL)                                      \</span>
</span><span class="line"><span class="cp">            ffurl_register_protocol(&amp;ff_##x##_protocol);                \</span>
</span><span class="line"><span class="cp">    }</span>
</span></code></pre></td></tr></table></div></figure>

<p>以<code>TCP</code>为例，<code>REGISTER_PROTOCOL(TCP,tcp)</code>展开如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">extern URLProtocol ff_tcp_protocol;
</span><span class="line">if(CONFIG_TCP_PROTOCOL)
</span><span class="line">    ffurl_register_protocol(&amp;ff_tcp_protocol);</span></code></pre></td></tr></table></div></figure>

<p><code>ffurl_register_protocol(&amp;ff_tcp_protocol)</code>展开如下：</p>

<figure class="code"><figcaption><span>ffurl_register_protocol </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="nf">ffurl_register_protocol</span><span class="p">(</span><span class="n">URLProtocol</span> <span class="o">*</span><span class="n">protocol</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">URLProtocol</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">first_protocol</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span>             <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
</span><span class="line">    <span class="n">protocol</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAR、DAR、SAR分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse/"/>
    <updated>2016-11-16T08:11:53-08:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/16/par-sar-dar-analyse</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)">Aspect Ratio</a> 是图片的宽高比。<br />
<!--more--></p>

<p>主要有 3 种<code>aspect ratio</code>：PAR(Pixel Aspect Ratio)、DAR(Display Aspect Ratio)、SAR(Sample Aspect Ratio)。</p>

<p>PAR(Pixel Aspect Ratio): 像素纵横比；<br />
DAR(Display Aspect Ratio):显示纵横比；<br />
SAR(Sample Aspect Ratio):采样纵横比；</p>

<p>三者的关系为PAR x SAR = DAR 或者 PAR = DAR / SAR。</p>

<p>PAR 示例如下：</p>

<p><img src="http://lazybing.github.io/images/PAR_DAR_SAR/220px-PAR-1to1.svg.png" title="'1to1_PAR'" /></p>

<p><img src="http://lazybing.github.io/images/PAR_DAR_SAR/220px-PAR-2to1.svg.png" title="'2to1_PAR'" /></p>

<p>DAR 示例如下：</p>

<p><img src="http://lazybing.github.io/images/PAR_DAR_SAR/Aspect_ratio_16_9_example3.jpg" title="'16to9_DAR'" /></p>

<p><img src="http://lazybing.github.io/images/PAR_DAR_SAR/Aspect_ratio_4_3_example.jpg" title="'4to3_DAR'" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FFmpeg 学习之 FFplay 源码分析]]></title>
    <link href="http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay/"/>
    <updated>2016-11-05T21:03:58-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/11/05/ffmpeg-learning-of-ffplay</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#ffplay-" id="markdown-toc-ffplay-">FFplay 的使用</a></li>
  <li><a href="#ffplay--1" id="markdown-toc-ffplay--1">FFplay 源码分析</a>    <ul>
      <li><a href="#avregisterall" id="markdown-toc-avregisterall">av_register_all()</a></li>
    </ul>
  </li>
</ul>

<p>FFplay 是一个简单便携的媒体播放器，它使用了 FFmpeg 和 SDL 库。<br />
<!--more--></p>

<h3 id="ffplay-">FFplay 的使用</h3>
<p>首先看一下 FFplay 的使用：安装完 FFmpeg 后，直接在命令行中输入</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ffplay [options] bitstream_file</span></code></pre></td></tr></table></div></figure>
<p>其中更详细的使用说明，可以使用<code>man ffplay</code>来查看。</p>

<p>其次我们可以通过使用<code>Esc</code><code>q</code>来推出播放，可以使用空格来暂停播放，可以使用<code>s</code>来执行逐帧播放视频等等操作。</p>

<h3 id="ffplay--1">FFplay 源码分析</h3>

<p>ffplay 里面最主要的函数时:<code>av_register_all()</code><code>SDL_Init(flags)</code><code>av_init_packet</code><code>stream_open</code><code>event_loop</code>。下面逐个分析这几个函数主要完成的功能。</p>

<h4 id="avregisterall">av_register_all()</h4>

<p><code>av_register_all</code>实现注册<code>codecs</code><code>demux</code>和<code>protocols</code>。其中注册的<code>codecs</code>时通过<code>avcodec_reigster_all()</code>函数来实现的；注册<code>demux</code>的方法，以 HEVC 为例。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define REGISTER_MUXER(X, x)                                            \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVOutputFormat ff_##x##_muxer;                           \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_MUXER)                                         \</span>
</span><span class="line"><span class="cp">            av_register_output_format(&amp;ff_##x##_muxer);                 \</span>
</span><span class="line"><span class="cp">    }</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define REGISTER_DEMUXER(X, x)                                          \</span>
</span><span class="line"><span class="cp">    {                                                                   \</span>
</span><span class="line"><span class="cp">        extern AVInputFormat ff_##x##_demuxer;                          \</span>
</span><span class="line"><span class="cp">        if (CONFIG_##X##_DEMUXER)                                       \</span>
</span><span class="line"><span class="cp">            av_register_input_format(&amp;ff_##x##_demuxer);                \</span>
</span><span class="line"><span class="cp">    }</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define REGISTER_MUXDEMUX(X, x) REGISTER_MUXER(X, x); REGISTER_DEMUXER(X, x)</span>
</span><span class="line">
</span><span class="line"><span class="n">REGISTER_MUXDEMUX</span><span class="p">(</span><span class="n">HEVC</span><span class="p">,</span><span class="n">hevc</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

<p>将上面的宏展开即为：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">av_register_input_format</span><span class="p">(</span><span class="n">AVInputFormat</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVInputFormat</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">last_iformat</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">format</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_iformat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">av_register_output_format</span><span class="p">(</span><span class="n">AVOutputFormat</span> <span class="o">*</span><span class="n">format</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">AVOutputFormat</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="n">last_oformat</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">||</span> <span class="n">avpriv_atomic_ptr_cas</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">format</span><span class="p">))</span>
</span><span class="line">        <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="n">last_oformat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">format</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">AVOutputFormat</span> <span class="n">ff_hevc_muxer</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="line">    <span class="p">.</span><span class="n">name</span>              <span class="o">=</span> <span class="s">&quot;hevc&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">long_name</span>         <span class="o">=</span> <span class="n">NULL_IF_CONFIG_SMALL</span><span class="p">(</span><span class="s">&quot;raw HEVC video&quot;</span><span class="p">),</span>
</span><span class="line">    <span class="p">.</span><span class="n">extensions</span>        <span class="o">=</span> <span class="s">&quot;hevc&quot;</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">audio_codec</span>       <span class="o">=</span> <span class="n">AV_CODEC_ID_NONE</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">video_codec</span>       <span class="o">=</span> <span class="n">AV_CODEC_ID_HEVC</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">write_packet</span>      <span class="o">=</span> <span class="n">ff_raw_write_packet</span><span class="p">,</span>
</span><span class="line">    <span class="p">.</span><span class="n">flags</span>             <span class="o">=</span> <span class="n">AVFMT_NOTIMESTAMPS</span><span class="p">,</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用gprof]]></title>
    <link href="http://lazybing.github.io/blog/2016/09/22/how-to-use-gprof/"/>
    <updated>2016-09-22T09:52:06-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/09/22/how-to-use-gprof</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Gprof">Gprof</a> 是一个 Unix 应用程序性能分析工具。
<!--more--></p>

<p><a href="https://sourceware.org/binutils/docs/gprof/index.html">Profiling</a> 可以使我们看到程序运行时程序的调用关系、函数的消耗时长等。这些信息可以使我们了解程序中那块代码耗时高于预期。</p>

<p>使用 Profiling 主要包括如下三步：</p>

<ul>
  <li>
    <p>编译链接程序时要使能 profiling 。</p>
  </li>
  <li>
    <p>执行编译处的可执行文件，产生 profile 数据文件。</p>
  </li>
  <li>
    <p>使用 gpro 分析 profile 数据。</p>
  </li>
</ul>

<p>根据产生的 profile ，可以产生各种不同实行的分析输出。如 The Flat Profile、The Call Graph、The Annotated Source Listing。</p>

<p>示例分析：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun2</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">fun1</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">fun2</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">fun1</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译，注意要添加<code>-pg</code>选项，这样才能与后面的 gprof 结合使用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -pg -o test test.c</span></code></pre></td></tr></table></div></figure>

<p>执行, 执行完毕后，会生成 gmon.out 文件，用于性能分析的文件。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">./test</span></code></pre></td></tr></table></div></figure>

<p>分析, 使用 gprof 分析。</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gprof test gmon.out &gt; analysis.txt</span></code></pre></td></tr></table></div></figure>

<p>此时生成的分析文件 analysis.txt 中有两种形式的分析数据。</p>

<p>Flat Profile 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Flat_profile.png" /></p>

<p>Call Graph 如图：</p>

<p><img src="http://lazybing.github.io/images/gprof/Call_graph.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之MP4]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/26/mp4-parse-format/"/>
    <updated>2016-07-26T04:31:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/26/mp4-parse-format</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#box" id="markdown-toc-box">最小组单元 BOX</a></li>
  <li><a href="#mp4-" id="markdown-toc-mp4-">MP4 文件整体结构</a>    <ul>
      <li><a href="#file-type-box" id="markdown-toc-file-type-box">File Type Box</a></li>
      <li><a href="#movie-box" id="markdown-toc-movie-box">Movie Box</a>        <ul>
          <li><a href="#movie-header-box" id="markdown-toc-movie-header-box">Movie Header Box</a></li>
        </ul>
      </li>
      <li><a href="#track-box" id="markdown-toc-track-box">Track Box</a>        <ul>
          <li><a href="#track-header-box" id="markdown-toc-track-header-box">Track Header Box</a></li>
        </ul>
      </li>
      <li><a href="#media-box" id="markdown-toc-media-box">Media Box</a>        <ul>
          <li><a href="#media-header-box" id="markdown-toc-media-header-box">Media Header Box</a></li>
          <li><a href="#handler-reference-box" id="markdown-toc-handler-reference-box">Handler Reference Box</a></li>
          <li><a href="#media-informatino-box" id="markdown-toc-media-informatino-box">Media Informatino Box</a></li>
          <li><a href="#data-informatino-boxdinf" id="markdown-toc-data-informatino-boxdinf">Data Informatino Box(dinf)</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MP4</a>是由许多 Box 和 FullBox 组成的，每个 Box 是由 Header 和 Data 组成的，FullBox 是 Box 的扩展，Box 结构的基础上在 Header 中增加 8bits version 和 24bits flags。
<!--more--></p>

<h2 id="box">最小组单元 BOX</h2>

<p>MP4 是由一些列的 box 组成，它的最小组成单元是 box。MP4 文件中的所有数据都装在 box 中，即 MP4 文件由若干个 box 组成，每个
 box 有类型和长度，可以将 box 理解为一个数据对象块。box 中可以包含另一个 box，这种 box 称为 container box。一个 MP4 文件首先会有且仅有
 一个<code>ftype</code>类型的 box,作为 MP4 格式的标志并包含关于文件的一些信息，之后会有且只有一个<code>moov</code>类型的box(Movie Box)，她是一种 container box,
 可以有多个，也可以没有，媒体数据的结构由 metadata 进行描述。</p>

<p><img src="http://lazybing.github.io/images/MP4/mp4_box.png" /></p>

<ul>
  <li>size：指明了 box 所占用的大小，包括 header 部分。</li>
  <li>type: 表示这个 box 的类型。</li>
  <li>largesize: 如果 box 很大超过 uint32 的最大数值,size 就被设置为 1,并用接下来的 largesize 来存放大小。</li>
</ul>

<p>一些基本概念：</p>

<ul>
  <li>track 表示一些 sample 的集合，对于媒体数据来说， track 表示一个视频或音频序列。</li>
  <li>hint track 这个特殊的 track 并不包含媒体数据，而是包含了一些将其他数据 track 打包成流媒体的指示信息。</li>
  <li>sample 对于非 hint track 来说， video  sample 即为一帧视频，或一组连续视频帧，audio sample 即为一段连续的压缩音频，统称为 sample。对于 hint track，sample 定义一个或多个流媒体包的格式。</li>
  <li>sample table 指明 sample 时序和物理布局的表。</li>
  <li>chunk 一个track的几个 sample 组成的单元。</li>
</ul>

<h2 id="mp4-">MP4 文件整体结构</h2>

<p><img src="http://lazybing.github.io/images/MP4/box.png" /></p>

<h3 id="file-type-box">File Type Box</h3>

<p><code>ftyp</code>类型会出现在 MP4 文件的开头，作为 MP4 容器格式的可表示信息。<code>ftyp box</code>内容结构如下：</p>

<p><img src="http://lazybing.github.io/images/MP4/filetypebox.png" /></p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class FileTypeBox
</span><span class="line">extends Box('ftyp'){
</span><span class="line">unsigned int(32) major_brand;
</span><span class="line">unsigned int(32) minor_version;
</span><span class="line">unsigned int(32) compatible_brands[];
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<h3 id="movie-box">Movie Box</h3>

<p><code>moov</code>里面包含了很多个 box,一般情况下 moov 会紧跟着 ftype。moov 里面包含着 MP4 文件中的 metedata。音视频相关
的基础信息。</p>

<h4 id="movie-header-box">Movie Header Box</h4>

<p><img src="http://lazybing.github.io/images/MP4/movie_header.png" /></p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class MovieHeader extends FullBox('mvhd', version, 0)
</span><span class="line">{
</span><span class="line">    if(version == 1)
</span><span class="line">    {
</span><span class="line">        unsinged int(64) creation_time;
</span><span class="line">        unsinged int(64) modification_time;
</span><span class="line">        unsinged int(64) timescale;
</span><span class="line">        unsinged int(64) duration;
</span><span class="line">    }else{
</span><span class="line">        unsinged int(32) creation_time;
</span><span class="line">        unsinged int(32) modification_time;
</span><span class="line">        unsinged int(32) timescale;
</span><span class="line">        unsinged int(32) duration;
</span><span class="line">    }
</span><span class="line">
</span><span class="line">    template int(32) rate = 0x00010000;
</span><span class="line">    template int(16) volume = 0x0100;
</span><span class="line">    const bit(16) reserved = 0;
</span><span class="line">    const ungigned int(32)[2] reserved = 0;
</span><span class="line">    template int(32)[9] matrix = 
</span><span class="line">    { 0x0001000, 0, 0, 0, 0x0001000, 0, 0, 0, 0x40000000};
</span><span class="line">    bit(32)[6] pre_defined = 0;
</span><span class="line">    unsigned int(32) next_track_ID;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>各个 Field 含义表格：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Field</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">box size</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">box 大小</td>
    </tr>
    <tr>
      <td style="text-align: center">box type</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">box 类型</td>
    </tr>
    <tr>
      <td style="text-align: center">version</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">box 版本</td>
    </tr>
    <tr>
      <td style="text-align: center">flags</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">flags</td>
    </tr>
    <tr>
      <td style="text-align: center">creation time</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">创建时间</td>
    </tr>
    <tr>
      <td style="text-align: center">modification time</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">修改时间</td>
    </tr>
    <tr>
      <td style="text-align: center">time scale</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">文件媒体在 1s 时间内的刻度值，可以理解为 1s 长度的时间单元数，一般情况下视频都是90000</td>
    </tr>
    <tr>
      <td style="text-align: center">duration</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">该 track 的时间长度，用 duration 和 time scale 值可以计算 track 时长</td>
    </tr>
    <tr>
      <td style="text-align: center">rate</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">推荐播放速率</td>
    </tr>
    <tr>
      <td style="text-align: center">volume</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">与 rate 类似</td>
    </tr>
    <tr>
      <td style="text-align: center">reserved</td>
      <td style="text-align: center">10</td>
      <td style="text-align: center">保留位</td>
    </tr>
    <tr>
      <td style="text-align: center">matrix</td>
      <td style="text-align: center">36</td>
      <td style="text-align: center">视频变化矩阵</td>
    </tr>
    <tr>
      <td style="text-align: center">pre-defined</td>
      <td style="text-align: center">24</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">nex track id</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">下一个 track 使用过的id 号</td>
    </tr>
  </tbody>
</table>

<h3 id="track-box">Track Box</h3>

<p>在<code>moov</code>这个box中会含有若干个track box每个track都是相对独立，track box里面会包含很多别的box，有2个很关键
<code>Track Header Box</code><code>Media Box</code>。</p>

<h4 id="track-header-box">Track Header Box</h4>

<p><img src="http://lazybing.github.io/images/MP4/movie_header.png" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Field</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">box size</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">box大小</td>
    </tr>
    <tr>
      <td style="text-align: center">box type</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">box类型</td>
    </tr>
    <tr>
      <td style="text-align: center">version</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">box版本</td>
    </tr>
    <tr>
      <td style="text-align: center">flags</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">按位或操作结果值，预定义如下：0x000001 track_enabled,否则该track不被播放；0x000002 track_in_movie，表示该track在播放中被引用。</td>
    </tr>
    <tr>
      <td style="text-align: center">track id</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">id号</td>
    </tr>
    <tr>
      <td style="text-align: center">reserved</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">保留位</td>
    </tr>
    <tr>
      <td style="text-align: center">duration</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">track的时间长度</td>
    </tr>
    <tr>
      <td style="text-align: center">reserved</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">保留位</td>
    </tr>
    <tr>
      <td style="text-align: center">layer</td>
      <td style="text-align: center">2 视频层，默认为0， 值小的在上层</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">alternate group</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">track 分组信息，默认为0表示该track未与其他track组有关系</td>
    </tr>
    <tr>
      <td style="text-align: center">volume</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">[8.8]格式，如果为音频track,1.0表示最大音量，否则为0</td>
    </tr>
    <tr>
      <td style="text-align: center">reserved</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">保留位</td>
    </tr>
    <tr>
      <td style="text-align: center">matrix</td>
      <td style="text-align: center">36</td>
      <td style="text-align: center">视频变化矩阵</td>
    </tr>
    <tr>
      <td style="text-align: center">width</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">宽</td>
    </tr>
    <tr>
      <td style="text-align: center">height</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">高</td>
    </tr>
  </tbody>
</table>

<h3 id="media-box">Media Box</h3>

<h4 id="media-header-box">Media Header Box</h4>

<p><img src="http://lazybing.github.io/images/MP4/media_header_box.png" /></p>

<table>
  <tbody>
    <tr>
      <td>Field</td>
      <td>Type</td>
      <td>Comment</td>
    </tr>
    <tr>
      <td>box size</td>
      <td>4</td>
      <td>box 大小</td>
    </tr>
    <tr>
      <td>box type</td>
      <td>4</td>
      <td>box 类型</td>
    </tr>
    <tr>
      <td>version</td>
      <td>1</td>
      <td>box 版本</td>
    </tr>
    <tr>
      <td>creation_time</td>
      <td>4</td>
      <td>创建时间</td>
    </tr>
    <tr>
      <td>modification_time</td>
      <td>4</td>
      <td>修改时间</td>
    </tr>
    <tr>
      <td>time scale</td>
      <td>4</td>
      <td>文件媒体在1s内的刻度值</td>
    </tr>
    <tr>
      <td>duration</td>
      <td>4</td>
      <td>该 track 的时间长度</td>
    </tr>
    <tr>
      <td>langurage</td>
      <td>2</td>
      <td>媒体语言码</td>
    </tr>
    <tr>
      <td>pre_defined</td>
      <td>2</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="handler-reference-box">Handler Reference Box</h4>

<p><img src="http://lazybing.github.io/images/MP4/media_header_box.png" /></p>

<table>
  <tbody>
    <tr>
      <td>Field</td>
      <td>Type</td>
      <td>Comment</td>
    </tr>
    <tr>
      <td>box size</td>
      <td>4</td>
      <td>box 大小</td>
    </tr>
    <tr>
      <td>box type</td>
      <td>4</td>
      <td>box 类型</td>
    </tr>
    <tr>
      <td>flags</td>
      <td>3</td>
      <td> </td>
    </tr>
    <tr>
      <td>pre_defined</td>
      <td>4</td>
      <td> </td>
    </tr>
    <tr>
      <td>handler_type</td>
      <td>4</td>
      <td>Video track(vide)/Audio track(soun)/Hint track(hint)a</td>
    </tr>
    <tr>
      <td>reserved</td>
      <td>12</td>
      <td>0</td>
    </tr>
    <tr>
      <td>name</td>
      <td>string</td>
      <td>字符串 tracke type name</td>
    </tr>
  </tbody>
</table>

<h4 id="media-informatino-box">Media Informatino Box</h4>

<p><code>minf</code>里面包含着一系列的box，里面是track相关的特征信息。一般
情况minf包含:Media Information Header Boxes、Data Information Box(dinf)、Sample Table Box。</p>

<p>Media Information Header Boxes 根据类型分为 vmhd、smhd、hmhd、nmhd。</p>

<p>其中 vmhd 格式如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Field</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">box size</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 大小</td>
    </tr>
    <tr>
      <td style="text-align: center">box type</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 类型</td>
    </tr>
    <tr>
      <td style="text-align: center">version</td>
      <td style="text-align: center">1 byte</td>
      <td style="text-align: center">box版本，通常为0</td>
    </tr>
    <tr>
      <td style="text-align: center">flags</td>
      <td style="text-align: center">3 bytes</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">graphics mode</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">视频合成模式，为0时拷贝原图像，否则与opcolor进行合成</td>
    </tr>
    <tr>
      <td style="text-align: center">opcolor</td>
      <td style="text-align: center">2x3</td>
      <td style="text-align: center">{red, green, blue}</td>
    </tr>
  </tbody>
</table>

<p>smhd 格式如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Field</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">box size</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 大小</td>
    </tr>
    <tr>
      <td style="text-align: center">box type</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 类型</td>
    </tr>
    <tr>
      <td style="text-align: center">version</td>
      <td style="text-align: center">1 byte</td>
      <td style="text-align: center">box版本，通常为0</td>
    </tr>
    <tr>
      <td style="text-align: center">flags</td>
      <td style="text-align: center">3 bytes</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">balance</td>
      <td style="text-align: center">2 bytes</td>
      <td style="text-align: center">立体声平衡，[8.8]格式</td>
    </tr>
    <tr>
      <td style="text-align: center">reserved</td>
      <td style="text-align: center">2 bytes</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<h4 id="data-informatino-boxdinf">Data Informatino Box(dinf)</h4>

<p><code>dinf</code>解释如何定位媒体信息，是一个container box。<code>dinf</code>一般包含一个<code>dref</code>，即 data reference box；
<code>dref</code>下会包含若干个<code>url</code>或<code>urn</code>，这些box组成一个表，用来定位track数据。</p>

<p><code>dref</code>的结构如下表。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Field</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">box size</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 大小</td>
    </tr>
    <tr>
      <td style="text-align: center">box type</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">box 类型</td>
    </tr>
    <tr>
      <td style="text-align: center">version</td>
      <td style="text-align: center">1 byte</td>
      <td style="text-align: center">box版本，通常为0</td>
    </tr>
    <tr>
      <td style="text-align: center">flags</td>
      <td style="text-align: center">3 bytes</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">entry count</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center"><code>url</code>或<code>urn</code>表的元素个数</td>
    </tr>
  </tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[媒体文件格式分析之AVI]]></title>
    <link href="http://lazybing.github.io/blog/2016/07/24/avi-parse-format/"/>
    <updated>2016-07-24T01:04:52-07:00</updated>
    <id>http://lazybing.github.io/blog/2016/07/24/avi-parse-format</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">基本数据结构</a></li>
  <li><a href="#avi-" id="markdown-toc-avi-">AVI 文件类型</a></li>
  <li><a href="#avi--1" id="markdown-toc-avi--1">AVI 文件布局</a>    <ul>
      <li><a href="#mainaviheaderavih" id="markdown-toc-mainaviheaderavih">MainAVIHeader(avih)</a></li>
      <li><a href="#stream-header-list" id="markdown-toc-stream-header-list">Stream Header List</a></li>
      <li><a href="#stream-header-list-elementstrh" id="markdown-toc-stream-header-list-elementstrh">Stream Header List Element(strh)</a></li>
      <li><a href="#stream-header-list-elementstrf" id="markdown-toc-stream-header-list-elementstrf">Stream Header List Element(strf)</a></li>
      <li><a href="#stream-header-list-elementindx" id="markdown-toc-stream-header-list-elementindx">Stream Header List Element(indx)</a></li>
      <li><a href="#stream-header-list-elementstrn" id="markdown-toc-stream-header-list-elementstrn">Stream Header List Element(strn)</a></li>
    </ul>
  </li>
  <li><a href="#avi-indexes" id="markdown-toc-avi-indexes">AVI Indexes</a>    <ul>
      <li><a href="#old-style-index" id="markdown-toc-old-style-index">old style index</a></li>
      <li><a href="#open-dml-index" id="markdown-toc-open-dml-index">Open-DML Index</a></li>
      <li><a href="#using-the-open-dml-index" id="markdown-toc-using-the-open-dml-index">Using the Open-DML index</a></li>
    </ul>
  </li>
  <li><a href="#the-movi---lists" id="markdown-toc-the-movi---lists">The movi - Lists</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">参考文献</a></li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">AVI</a> 是音视频交错(Audio Video Interleaved)的缩写，它是 Microsoft 公司开发的一种符合 RIFF 文件规范的数字音频与视频文件格式。
<!--more--></p>

<h2 id="section">基本数据结构</h2>

<p>AVI 文件中有两种类型结构:Chunks 和 Lists。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//Chunks
</span><span class="line">typedef struct {
</span><span class="line">    DWORD dwFourCC;
</span><span class="line">    DWORD dwSize;
</span><span class="line">    BYTE  data[dwSize];
</span><span class="line">}CHUNK;
</span><span class="line">//Lists
</span><span class="line">typedef struct{
</span><span class="line">    DWORD dwList;
</span><span class="line">    DWORD dwSize;
</span><span class="line">    DWORD dwFourCC;
</span><span class="line">    BYTE  data[dwSize - 4];
</span><span class="line">}LIST;</span></code></pre></td></tr></table></div></figure>

<p>一个包含了<code>video</code>、<code>audio</code>或<code>subtitle</code>数据的<code>chunk</code>使用一个<code>dwFourCC</code>，
<code>dwFourCC</code>包含 2 个十六进制数字表示 stream number，2 个字母表示数据类型( dc 表示 video， wb 表示 audio, tx 表示 text)。
<code>dwFourCC</code>和<code>dwSize</code>在<code>Chunks</code>和<code>Lists</code>中有相同的含义。</p>

<p><code>dwFourCC</code>描述chunk 的类型（如<code>hdrl</code>表示 <code>header list</code>），<code>dwSize</code>表示该 chunk 或 list 的大小，
包含<code>dwSize</code>后的所有 byte。在 List 中，<code>dwSize</code>包含了<code>dwFourCC</code>所占有的4 bytes.</p>

<p><code>dwList</code>的值可以是<code>RIFF（RIFF-List</code>或<code>LIST(List)</code>。</p>

<h2 id="avi-">AVI 文件类型</h2>

<p>通常来讲，有 3 种类型的 AVI 文件：</p>

<ul>
  <li>AVI 1.0, 最初始的 AVI 文件类型。</li>
  <li>Open-DML, AVI 文件格式的扩展。1.02版本相对于1.0版本有两个提高：基本没有文件大小的限制、负载降低了33%。</li>
  <li>Hybride-Files，Open-DML 文件因为兼容的原因有个额外的限制，Hybride-Files 虽然不是官方致命的文件类型，但确实是一个不错的类型。</li>
</ul>

<h2 id="avi--1">AVI 文件布局</h2>
<p>一个<code>dwFourCC=AVI</code>的<code>RIFF-List</code>称为<code>RIFF-AVI-List</code>，
一个<code>dwFourCC=AVIX</code>的<code>RIFF-List</code>称为<code>RIFF-AVIX-List</code>。</p>

<p>每个 AVI 文件都有如下布局：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">RIFF AVI    //mandatory
</span><span class="line">{RIFF AVIX} //only for Open-DML files</span></code></pre></td></tr></table></div></figure>

<p>并非之受限于 uint32 的限制，文件大小的极限并非 4G,而是</p>

<ul>
  <li>对于 AVI 1.0: sizeof(RIFF-AVI) &lt; 2G</li>
  <li>对于 Open-DML, sizeof(RIFF-AVI) &lt; 1G(!!), sizeof(RIFF-AVIX) &lt; 2G</li>
</ul>

<p>一般来讲，RIFF-AVI-Lists被创建的越小越好。</p>

<h3 id="mainaviheaderavih">MainAVIHeader(avih)</h3>

<p><code>avih</code>结构定义如下：</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct
</span><span class="line">{
</span><span class="line">    DWORD dwMicroSecPerFrame;   //frame display rate(or 0)
</span><span class="line">    DWORD dwMaxBytesPerSec;     //max transfer rate
</span><span class="line">    DWORD dwPaddingGranularity; //pad to multiples of this size
</span><span class="line">    DWORD dwFlags               //the ever-present flags
</span><span class="line">    DWORD dwTotalFrames;        //frames in file
</span><span class="line">    DWORD dwInitialFrames;
</span><span class="line">    DWORD dwStreams;
</span><span class="line">    DWORD dwSuggestedBufferSize;
</span><span class="line">
</span><span class="line">    DWORD dwWidth;
</span><span class="line">    DWORD dwHeight;
</span><span class="line">
</span><span class="line">    DWORD dwReserved[4];
</span><span class="line">}MainAVIHeader;</span></code></pre></td></tr></table></div></figure>
<ul>
  <li>dwMicroSecPerFrame 以微妙为单位，包含了一个视频帧的持续时间。该值可以被忽略。注意，某些程序中可能会把它写成 framerate 值，因此 dwMicroSecPerFrame 并不可靠。</li>
  <li>dwMaxBytesPerSec 文件中最大的数据率，该值同样的不是特别重要。</li>
  <li>dwPaddingGranularity 填充的数据。</li>
  <li>dwFlags <code>AVIF_HASINDEX</code>（该文件有index）、<code>AVIF_MUSTUSEINDEX</code>（）、<code>AVIF_ISINTERLEAVED</code> <code>AVIF_WASCAPTUREFILE</code> <code>AVIF_COPYRIGHTED</code> <code>AVIF_TRUSTCKTYPE</code>。</li>
  <li>dwTotalFrames 包含了<code>RIFF-AVI list</code>中视频帧数。如果文件中包含<code>RIFF-AVIX-Lists</code>，它不会包含其中的视频帧。因为某些<code>muxer</code>会写一些错误的值，因此该值同样的不可靠。</li>
  <li>dwInitialFrames 忽略</li>
  <li>dwStreams 文件中<code>streams</code>的数量。</li>
  <li>dwSuggestedBufferSize 文件chunks 所需要的内存大小。同样不要高估它的可靠性。</li>
  <li>dwWidth 视频的宽。</li>
  <li>dwHeight 视频的高。</li>
</ul>

<h3 id="stream-header-list">Stream Header List</h3>

<p>针对每个<code>stream</code>都有一个<code>strl</code>，如果<code>strl</code>的数量与<code>MainAVIHeader::dwStreams</code>不同，就需要发出一个<code>fatal error report</code>。</p>

<h3 id="stream-header-list-elementstrh">Stream Header List Element(strh)</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct{
</span><span class="line">    FOURCC fccType;
</span><span class="line">    FOURCC fccHandler;
</span><span class="line">    DWORD  dwFlags;
</span><span class="line">    WORD   wPriority;
</span><span class="line">    WORD   wLanguage;
</span><span class="line">    DWORD  dwInitialFrames;
</span><span class="line">    DWORD  dwScale;
</span><span class="line">    DWORD  dwRate;  // dwRate / dwScale == samples /second
</span><span class="line">    DWORD  dwStart;
</span><span class="line">    DWORD  dwLength;  //In units above
</span><span class="line">    DWORD  dwSuggestedBufferSize;
</span><span class="line">    DWORD  dwQuality;
</span><span class="line">    DWORD  dwSampleSize;
</span><span class="line">    RECT   rcFrame;
</span><span class="line">}AVIStreamHeader;</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>fccType <code>vids</code>代表 video, <code>auds</code>代表 audio, <code>txts</code>代表 subtitle。</li>
  <li>fccHandler</li>
  <li>dwFlags <code>AVISF_DISABLED</code> <code>AVISF_VIDEO_PALCHANGES</code></li>
  <li>dwInitialFrames</li>
  <li>dwRate / dwScale = samples / second(audio) or frames / second(video)</li>
  <li>dwStart</li>
  <li>dwLength</li>
  <li>dwSuggestedBufferSize</li>
  <li>dwQuality</li>
  <li>dwSampleSize</li>
</ul>

<h3 id="stream-header-list-elementstrf">Stream Header List Element(strf)</h3>

<p><code>strf</code>的结构依据媒体类型。对于 video，使用<code>BITMAPINFOHEADER</code>结构，而 audion，使用<code>WAVEFORMATEX</code>结构。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct tagBITMAPINFOHEADER{
</span><span class="line">    DWORD biSize;
</span><span class="line">    LONG  biWidth;
</span><span class="line">    LONG  biHeight;
</span><span class="line">    WORD  biPlanes;
</span><span class="line">    WORD  biBitCount;
</span><span class="line">    DWORD biCompression;
</span><span class="line">    DWORD biSizeImage;
</span><span class="line">    LONG  biXPelsPerMeter;
</span><span class="line">    LONG  biYPelsPerMeter;
</span><span class="line">    DWORD biClrUsed;
</span><span class="line">    DWORD biClrImportant;
</span><span class="line">}BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span></code></pre></td></tr></table></div></figure>

<ul>
  <li>biSize  该结构体所需要的 byte 大小。</li>
  <li>biWidth 图像的宽度。如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，<code>biWidth</code>成员相应的指解压缩后的<code>JPEG</code>或<code>PNG</code>图像文件的宽。</li>
  <li>biHeight 位图的高度。如果<code>biHeight</code>是正数，位图是自底向上的<code>DIB</code>,它的原点是右下角地点；。如果<code>biHeight</code>是正数，位图是自顶向下的<code>DIB</code>,它的原点是右上角地点；
如果<code>biHeight</code>是负数，<code>biCompression</code>要么是<code>BI_RGB</code>或<code>BI_BITFIELDS</code>，自顶向下的<code>DIB</code>不能被压缩。
如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，则<code>biHeight</code>程序分别指解压缩后的<code>JPEG</code>或<code>PNG</code>图像的高。</li>
  <li>biPlanes 目标设备的<code>planes</code>的数量，该值必须是1。</li>
  <li>biBitCount 每个像素所用的 bit 数，<code>BITMAPINFOHEADER</code>的成员<code>biBitCount</code>决定了每个 pixel 所占的 bit 数、以及位图中表示颜色所能用到的最大数。该值可以是<code>0/1/4/8/16/24/32</code>。</li>
  <li>biCompression 压缩的自底向上的位图的压缩类型，可以是<code>BI_RGB</code><code>BI_RLE8</code><code>BI_RLE4</code><code>BI_BITFIELDS</code><code>BI_JPEG</code><code>BI_PNG</code>.</li>
  <li>biSizeImage 图像的大小，单位 byte。如果是<code>BI_RGB</code>位图，该值被设置为0。如果<code>biCompression</code>是<code>BI_JPEG</code>或<code>BI_PNG</code>，该值分别指示 JPEG 或 PNG 图像的大小。</li>
  <li>biXPelsPerMeter 水平分辨率。</li>
  <li>biYPelsPerMeter 垂直分辨率。</li>
  <li>biClrUsed 颜色表中该位图实际使用的颜色指针。</li>
  <li>biClrImportant</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct{
</span><span class="line">    WORD  wFormatTag;
</span><span class="line">    WORD  nChannels;
</span><span class="line">    DWORD nSamplesPerSec;
</span><span class="line">    DWORD nAvgBytesPerSec;
</span><span class="line">    WORD  nBlocAlign;
</span><span class="line">    WORD  wBitsPerSample;
</span><span class="line">    WORD  cbSize;
</span><span class="line">}WAVEFORMATEX;</span></code></pre></td></tr></table></div></figure>
<p>(待续…)</p>

<h3 id="stream-header-list-elementindx">Stream Header List Element(indx)</h3>

<p>该结构请看下面的<code>AVI index</code>小结。</p>

<h3 id="stream-header-list-elementstrn">Stream Header List Element(strn)</h3>

<p>该部分包含了<code>stream</code>的的名字。该名字只能使用标准的<code>ASCII</code>，尤其不能使用<code>UTF-8</code>。</p>

<h2 id="avi-indexes">AVI Indexes</h2>

<h3 id="old-style-index">old style index</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AVIINDEXENTRY index_entry[n]  
</span><span class="line">typedef struct{
</span><span class="line">    DWORD ckid;
</span><span class="line">    DWORD dwFlags;
</span><span class="line">    DWORD dwChunkOffset;
</span><span class="line">    DWORD dwChunkLength;
</span><span class="line">}AVIINDEXENTRY;</span></code></pre></td></tr></table></div></figure>

<h3 id="open-dml-index">Open-DML Index</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">typedef struct _aviindex_chunk{
</span><span class="line">    FOURCC fcc;
</span><span class="line">    DWORD  cb;
</span><span class="line">    WORD   wLongsPerEntry;
</span><span class="line">    BYTE   bIndexSubType;
</span><span class="line">    BYTE   bIndexType;
</span><span class="line">    DWORD  nEntriesInUse;
</span><span class="line">    DWORD  dwChunkId;
</span><span class="line">    DWORD  dwReserved[3];
</span><span class="line">    struct _aviindex_entry{
</span><span class="line">        DWORD adw[wLongsPerEntry];
</span><span class="line">    }aIndex[];
</span><span class="line">}AVIINDEXCHUNK;</span></code></pre></td></tr></table></div></figure>

<h3 id="using-the-open-dml-index">Using the Open-DML index</h3>

<h2 id="the-movi---lists">The movi - Lists</h2>

<p><code>Movi-List</code>包含<code>Video</code><code>Audio</code><code>Subtitle</code>和<code>index data</code>。它们可以打包进<code>rec-List</code>。如：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">LIST movi
</span><span class="line">    LIST rec
</span><span class="line">        01wb
</span><span class="line">        02wb
</span><span class="line">        03dc
</span><span class="line">    LIST rec
</span><span class="line">        01wb
</span><span class="line">        02wb
</span><span class="line">    LIST rec
</span><span class="line">        ...
</span><span class="line">        ...
</span><span class="line">        ix01
</span><span class="line">        ix02
</span><span class="line">        ...</span></code></pre></td></tr></table></div></figure>
<p>其中的<code>chunks</code> ID 分别定义如下：</p>

<ul>
  <li>..wb : audio chunk</li>
  <li>..dc : video chunk</li>
  <li>..tx : subtitle chunk</li>
  <li>ix.. : standard index block</li>
</ul>

<h2 id="section-1">参考文献</h2>

<ol>
  <li><a href="http://www.ezr8.com/avi.html">What is avi?</a></li>
  <li><a href="http://pvdtools.sourceforge.net/aviformat.txt">BETA DOCUMENTATION OF RIFF-AVI FILE FORMAT</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">Audio Video Interleave</a></li>
  <li><a href="http://blog.csdn.net/jszj/article/category/614875">AVI 文件格式</a></li>
  <li><a href="http://blog.csdn.net/njuitjf/article/details/5680632">AVI 文件解析</a></li>
  <li><a href="https://www.ffmpeg.org/doxygen/0.6/avidec_8c-source.html">FFmpeg AVI</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
