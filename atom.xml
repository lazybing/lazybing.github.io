<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[懒人李冰]]></title>
  <link href="http://lazybing.github.io/atom.xml" rel="self"/>
  <link href="http://lazybing.github.io/"/>
  <updated>2019-04-19T10:04:10-07:00</updated>
  <id>http://lazybing.github.io/</id>
  <author>
    <name><![CDATA[李冰]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[性能优化之减少调用]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call/"/>
    <updated>2019-04-19T09:59:18-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/19/reducing-procedure-call</id>
    <content type="html"><![CDATA[
<p>函数调用会带来相当大的开销，而且它会阻碍其他形式的程序优化。单独的较少调用次数可能对性能提升并不明显，但考虑到减少调用后，可以进一步进行其他形式的优化，因此，减少函数调用还是很有必要的。</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能优化之循环展开]]></title>
    <link href="http://lazybing.github.io/blog/2019/04/17/loop-unroll/"/>
    <updated>2019-04-17T07:36:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2019/04/17/loop-unroll</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例分析</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">循环展开扩展</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结论总结</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">参考资料</a></li>
</ul>

<p>循环展开是通过增加每次迭代计算的元素的数量，减少循环的迭代次数。循环展开只能针对整形加法和乘法的性能改进。</p>

<!--more-->

<p>循环展开从两个方面改变程序的性能：</p>

<ul>
  <li>分支预测失败减少。</li>
  <li>减少不直接有助于程序结果的操作的数量，如循环索引计算和条件分支。</li>
  <li>提供了一种方法，可以进一步变换代码，减少整个计算中关键路径上的操作数量。</li>
</ul>

<h2 id="section">示例分析</h2>

<figure class="code"><figcaption><span>loop_unrolling.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">loop_unroll3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="mi">1000000</span><span class="p">];</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">time_start</span><span class="p">,</span> <span class="n">time_end</span><span class="p">;</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll1</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll2</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">loop_unroll3</span><span class="p">();</span>
</span><span class="line">    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;used time us_sec %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">time_end</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>运行上面的程序：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gcc -funroll-loops -pg loop_unrolling.c -o loop_unrolling</span></code></pre></td></tr></table></div></figure>

<p>执行三次后，结果如下:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Executions</th>
      <th style="text-align: center">loop_unroll1</th>
      <th style="text-align: center">loop_unroll2</th>
      <th style="text-align: center">loop_unroll3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">12618</td>
      <td style="text-align: center">1890</td>
      <td style="text-align: center">3162</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7456</td>
      <td style="text-align: center">1987</td>
      <td style="text-align: center">1629</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">9868</td>
      <td style="text-align: center">2446</td>
      <td style="text-align: center">2388</td>
    </tr>
  </tbody>
</table>

<p>上面的结果可以看出，产开次数为2相对于未展开时，性能有明显提升，但展开次数为4时，性能相对于展开次数为2并没有多少提升。另外，编译器选项<code>-funroll-loops</code>好像并没有起到什么作用。但是如果添加编译选项<code>-O1</code>或<code>-O2/-O3</code>时，编译器会自动优化该函数。</p>

<p>关于展开次数和性能之间的关系，CSAPP 这本书里有介绍一个实验结果，如图所示：</p>

<p><img src="http://lazybing.github.io/images/loop_unroll/loop_unrolling.png" /></p>

<p>从图中可以看出，当循环展开到6次时的CPE(Cycles Per Element,每元素的周期数)测量值，对于展开2次或3次时观察到的趋势还在继续——循环展开对浮点数运算没有帮助，但对整数加法和乘法，CPE降至1.00.</p>

<p>实验过程中发现，CSAPP中描述的结论与我自己测试的结果有几点需要注意：</p>

<ol>
  <li>测试中，循环展开对于浮点数的加法和乘法是有效的。</li>
  <li>编译器选项<code>-funroll-loops</code>并没有起到循环展开的作用。</li>
  <li>循环展开对于性能的提升确实是都有帮助的。</li>
</ol>

<h2 id="section-1">循环展开扩展</h2>

<p>循环展开的本质是降低循环开销、增加并行运行的可能性。网上找到的大部分讲解循环展开的都是针对<strong>for</strong>循环的，既然是循环展开，那么对于<strong>while</strong>循环，理论上也是适用的，最后找到了<a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling</a>。关于<strong>while</strong>循环展开的方法，可以用下面的描述语言表示：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">while B do S; &lt;==&gt; while B ^ wp(S, B) do begin S;S end; while B do S;</span></code></pre></td></tr></table></div></figure>
<p>按照论文的讲解，手动写了两个替换的等价循环</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</span><span class="line">    <span class="n">q</span><span class="o">++</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>遗憾的是，运行后，两者的时间并没有太大的差别，有时第二段代码方法甚至更慢。猜测可能原因有两点：现代编译器对此类优化方法已经完成的很好；不同运行环境运行效果不同；所以，循环展开这类方法，最好是实际操作运行看结果，理论与实际可能有出入。</p>

<h2 id="section-2">结论总结</h2>

<p>循环展开对于性能的提升是由帮助的，但这种帮助并不是无限的，随着展开次数的增多，性能并不会继续增加，相反，循环展开次数过多，会使得程序代码膨胀、代码可读性降低。另外，编译器优化选项<code>-O1</code>或<code>-O2</code>等，会使得编译器自身会对代码进行优化，此时手动循环展开并不是一个好的方法。再者，受运行环境的影响（我的测试用例都是在Ubuntu虚拟机下完成），其测试结果可能有不同。</p>

<h2 id="section-3">参考资料</h2>
<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80">循环展开</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop Unrolling</a></li>
  <li><a href="http://www2.cs.uh.edu/~jhuang/JCH/JC/loop.pdf">Generalized Loop-Unrolling: a Method for Program Speed-Up</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/37582101">C++性能榨汁机之循环展开</a></li>
  <li><a href="https://github.com/shihyu/CSAPP2e/blob/master/Computer%20Systems%20-%20A%20Programmer's%20Perspective%20(2nd).pdf">Computer Systems - A Programmer’s Perspective</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1 解码详解(四)之LOOP RESTORATION(待总结)]]></title>
    <link href="http://lazybing.github.io/blog/2019/03/02/loop-restoration/"/>
    <updated>2019-03-02T18:02:55-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/03/02/loop-restoration</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#wiener-filter-" id="markdown-toc-wiener-filter-">Wiener Filter 维纳滤波器</a></li>
  <li><a href="#selfguided-filter-" id="markdown-toc-selfguided-filter-">Selfguided Filter 自导向投影滤波器</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p>LOOP RESTORATION，环内重建滤波器，是一个重要的增强图像质量处理方法。它包含了两种滤波器，编码器会从两者中选择其一。Wiener Filter(维纳滤波器)采用可分离的对称设计。SelfGuided(自导向投影滤波器)使用两个重建信号的线性组合来近似真实信号。编码器通过比较滤波结果，选择合适的参数，并传输给解码器。</p>

<!--more-->

<p>图像重建是一个比较成熟的领域，它包含了很多专业技术可用，比如 deblocking、deblurring、deringring、debanding、denoising、constrast enhancement、sharpening 和 resolution enhancement。</p>

<h2 id="wiener-filter-">Wiener Filter 维纳滤波器</h2>

<p>Degraded 帧的每个像素都</p>

<h2 id="selfguided-filter-">Selfguided Filter 自导向投影滤波器</h2>

<h2 id="section">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="https://static1.squarespace.com/static/56ac12221f40397fbfd21993/t/59cf3d9a2278e777855714bb/1506753947391/0000265.pdf">A SWITCHABLE LOOP-RESTORATION WITH SIDE-INFORMATION FRAMEWORK FOR THE EMERGING AV1 VIDEO CODEC</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AV1 解码详解(三)之CDEF]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter/"/>
    <updated>2019-01-28T06:32:04-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/28/av1-cdef-filter</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#cdef-" id="markdown-toc-cdef-">CDEF 介绍</a></li>
  <li><a href="#section" id="markdown-toc-section">方向查找</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">非线性低通滤波器</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">定向滤波器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">代码实现分析</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">方向查找实现</a></li>
          <li><a href="#cdef--1" id="markdown-toc-cdef--1">CDEF 方向滤波</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">参考文档</a></li>
</ul>

<p>CDEF(constrained directional enhancement)约束方向增强滤波器是 AV1 里的几种滤波器之一， SPEC 中定义的该部分在 7.15 CDEF process 中。AOM 代码中在 cdef.c 相关的文件中。除此外，还可以参考 <code>The AV1 CONSTRAINED DIRECTIONAL ENHANCEMENT FILTER</code>论文，本文就是基于上面三个部分分析的结果。</p>

<!--more-->

<p>环路滤波器基于非线性低通滤波器，专为矢量化效率设计的。该滤波器考虑边缘方向和滤波模式，它通过确定每个 block 块的方向，然后自适应的用沿方向的滤波强度进行滤波。增强滤波目的是提高 AOM 的质量，尤其是低复杂性的配置中。</p>

<h2 id="cdef-">CDEF 介绍</h2>

<p>CDEF 的主要目的是过滤掉编码杂音，同时保留图像的详细内容。AV1 中采用的方法是非线性空间滤波器，该滤波器的设计非常适用于矢量化，即可以使用 SIMD 操作，而其他非线性滤波器（如中值滤波器和双边滤波器）并非如此。</p>

<p>CDEF 滤波器的设计基于以下观察：编码图像中杂音的数量通常与量化步长大致成比例，图像详细内容的数量是输入图像的一个属性，保留在量化过的图像中的最小的实际信息量也与量化成一定的比例。对于给定的步长，杂音的幅度要比细节的幅度小很多。</p>

<p>CDEF 首先判断每个块的方向，之后沿着判断的方向自适应的滤波，并沿着判断的方向小幅度旋转 45 度，滤波强度明确表示，对模糊的高度控制。</p>

<p>CDEF 是基于之前提到的两个环路滤波器，结合的滤波器用在了 AV1 Codec 中。</p>

<p>从 SPEC 中的7.15 节可以看出，CDEF 可以理解为，输入为重建像素的当前帧数组，输出为包含了 Deringed 像素的数组 CDEF 帧。CDEF 的作用就是在侦测到的块方向上执行 DEringing， 码流中 CDEF 参数存放到每个64x64块(luma像素)中。可以将 CDEF 模块大致分为3步：</p>

<ul>
  <li>CDEF Block 处理</li>
  <li>CDEF Direction 处理</li>
  <li>CDEF Filter 处理</li>
</ul>

<h2 id="section">方向查找</h2>

<p>方块滤波后，方向查找就作用在重建像素上。因为重建像素对解码器是可获取的，因此滤波方向不需要特定的给出。查找作用在 8x8 块上，当应用到量化过后的图像时，该大小对于充分处理非直接边缘已经足够小，而对可靠地估计出方向又已经足够大了,有一个固定方向作用在8x8区域上，使得矢量化滤波更容易。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/av1_cdef_find_dir.png" /></p>

<p>对每个方向d，每行k的平均像素是: $ u_{d,k} = \frac{1}{N_{d,k}} \sum_{p \in P_{d,k}} x_p$ 其中：</p>

<ul>
  <li>$x_p$ 是像素$p$的值</li>
  <li>$P_{d,k}$是在方向$d$上第$k$行的一组像素值</li>
  <li>$N_{d,k}$是相对$P_{d,k}$对应的基数，如$N_{1,0}=2, N_{1,4}=8$</li>
</ul>

<p><code>SSD</code>的计算公式如下：$E_{d}^2 = \sum_{k} \big[\sum_{p \in P_{d,k}} \big( x_{p} - u_{d,k}\big)^2 \big]$</p>

<p>将上面的两个公式整合后，结果如下：$E_{d}^2 = \sum_{p}x_{p}^2 - \sum_{k}\frac{1}{N_{d,k}} \big(\sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>我们可以通过计算上面公式中第二部分的最大值来寻找最佳方向 $d_{opt}$, $d_opt = max_d s_d$, 其中 $s_{d} = \sum_{k}\frac{1}{N_{d,k}} \big(sum_{p \in P_{d,k}} x_p \big)^2$</p>

<p>可以用 840 乘以$S_d$来避免除以$N_{d,k}$,840 是所有$N_{d,k}$的最小公倍数。对于 8bit 数据，数据值为$[-128, 127]$，所有$840S_d$和所有的其他计算都适用于 32位 signed 整数类型。对于更高的bit，如10bit或12bit，在查找方向时，缩放像素到 8bit。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/direction_search.png" /></p>

<p>上图展示了一个针对 8x8 块，寻找方向的例子，寻找的算法如下。为了节省解码器的复杂度，我们假定亮度和色度方向是相关的，因此我们只寻找亮度原件的方向，该方向与色度方向相同。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/algorithm_find_direction.png" /></p>

<h2 id="section-1">非线性低通滤波器</h2>

<p>CDEF 使用非线性低通滤波器，去除编码杂音的同时不会模糊块的边缘。AV1 根据特定方向寻找滤波器抽头位置，同时当滤波器运用到块边界时，要防止过度模糊。使用非线性低通滤波器，在滤波像素偏差过大时，就不再对该像素过度强调。</p>

<h3 id="section-2">定向滤波器</h3>

<p>确认方向是为了统一特定方向上滤波器抽头，来降低振铃，同时不会模糊特定的边缘。但是单纯的定向滤波器有时无法高效的降低振铃效应，因此同时需要对像素数据使用滤波器抽头，该抽头并不是直接沿着主要方向。为了降低模糊块的风险，这些额外的抽头会被更保守的处理。因此，CDEF 定义了 primary taps 和 secondary taps。</p>

<p>primary taps 沿着方向 d，它的系数如上面图 4 所示。对 primary taps，对不同的 strength，会有不同的系数，对于1/3/5的strength，与2/4/6的strength，系数是不同的。secondary tpas 会形成一个十字架，是方向 d 旋转 45° 后得到，系数如图 5。</p>

<p><img src="http://lazybing.github.io/images/av1_cdef/primary_filter.png" />
<img src="http://lazybing.github.io/images/av1_cdef/secondary_filter.png" /></p>

<p>2-D CDEF 滤波器公式如下：</p>

<p>$y(i,j) = x(i,j) + round( \sum_{m,n} w_{d,m,n}^{(p)} f(x(m,n) -x(i, j), S^{(p)}, D) + \sum_{m,n} w_{d,m,n}^{(s)} f(x(m,n) -x(i,j), S^{(s)}, D))$</p>

<ul>
  <li>$S_{p}$和$S_{s}$是 primary 和 secondary 抽头的 strength。</li>
</ul>

<p>每个要滤波的 8x8 块，方向、strength 和 damping 参数是固定的。当处理位置(i, j)处的像素时，滤波器允许使用 x(i+m, j+m)处的像素，该像素可能超出 8x8 块的边界。如果处理像素超出了帧范围，像素会被忽略(f(d, S, D) = 0)。为最大化并行，CDEF 总是作用在输入(post-deblocking)像素 x(i,j)上，这样在滤波其他像素时，不会用的之前已经滤波王城的像素。</p>

<h3 id="section-3">代码实现分析</h3>

<p>此处以 DAV1D 工程里的 CDEF 模块作为例子，主要介绍两部分，<code>cdef_find_dir</code>和<code>cdef_filter_block</code>，并把 10bit 汇编优化完成。完成后，在 pixel2 手机上测试，效率提升大概 30% 左右。</p>

<h4 id="section-4">方向查找实现</h4>

<p>DAV1D 工程里，对 CDEF 方向查找，完成了 C 代码实现和对 8bit 码流的汇编优化，对10bit优化并没有完成。</p>

<figure class="code"><figcaption><span>cdef_find_dir.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c"><span class="line">
</span></code></pre></td></tr></table></div></figure>

<h4 id="cdef--1">CDEF 方向滤波</h4>

<p>滤波主要由两步完成，</p>

<h2 id="section-5">参考文档</h2>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">AV1 Bitstream and Decoding Process</a></li>
  <li><a href="https://jmvalin.ca/papers/AV1_tools.pdf">An Overview of Core Coding Tools in the AV1 Video Codec</a></li>
  <li><a href="http://www.mirlab.org/conference_papers/international_conference/ICASSP%202018/pdfs/0001193.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
  <li><a href="https://jmvalin.ca/misc_stuff/icassp2018_slides.pdf">The AV1 Constrained Directional Enhancement Filter</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARM64 汇编指令总结]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/24/neon-of-coding/"/>
    <updated>2019-01-24T06:35:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/24/neon-of-coding</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#sqdmulhvectorby-element" id="markdown-toc-sqdmulhvectorby-element">SQDMULH(vector/by element)</a></li>
  <li><a href="#sqrdmulhvectorby-element" id="markdown-toc-sqrdmulhvectorby-element">SQRDMULH(vector/by element)</a></li>
  <li><a href="#sqrshrun-sqrshrun2" id="markdown-toc-sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</a></li>
  <li><a href="#sqshrun-sqshrun2" id="markdown-toc-sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</a></li>
  <li><a href="#shl" id="markdown-toc-shl">SHL</a></li>
  <li><a href="#shll-shll2" id="markdown-toc-shll-shll2">SHLL, SHLL2</a></li>
  <li><a href="#sshll-sshll2" id="markdown-toc-sshll-sshll2">SSHLL, SSHLL2</a></li>
  <li><a href="#ushll-ushll2" id="markdown-toc-ushll-ushll2">USHLL, USHLL2</a></li>
  <li><a href="#trn1--trn2" id="markdown-toc-trn1--trn2">TRN1 &amp; TRN2</a></li>
  <li><a href="#sxtl-sxtl2" id="markdown-toc-sxtl-sxtl2">SXTL, SXTL2</a></li>
  <li><a href="#uxtl-uxtl2" id="markdown-toc-uxtl-uxtl2">UXTL, UXTL2</a></li>
  <li><a href="#ext" id="markdown-toc-ext">EXT</a></li>
  <li><a href="#bfm-ubfm-sbfmbitfield-move" id="markdown-toc-bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</a></li>
  <li><a href="#srshr" id="markdown-toc-srshr">SRSHR</a></li>
</ul>

<p>ARMv8 指令集可以大致分为三类:A64 指令集、A32&amp;T32 指令集。</p>

<p>ARM 汇编真的太痛苦了。。。一个命令一个命令的学习记录吧</p>

<!--more-->

<p>指令格式：</p>

<p><code>&lt;Opcode&gt;[&lt;Cond&gt;]&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; [.&lt;Opcode2&gt;]</code></p>

<ul>
  <li>其中尖括号的选项是必须的，花括号是可选的。</li>
  <li>A32 : Rd==&gt;{R0-R14}</li>
  <li>A64 : Rd==&gt;Xt==&gt;{X0-X30}</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">标识符</th>
      <th style="text-align: center">备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Opcode</td>
      <td style="text-align: center">操作码，也就是助记符，说明指令需要执行的操作类型</td>
    </tr>
    <tr>
      <td style="text-align: center">Cond</td>
      <td style="text-align: center">指令执行条件码，在编码中占4bit, 0b000-0b1110</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">条件码设置项，决定本次指令是否影响 PSTATE 寄存器响应状态位值</td>
    </tr>
    <tr>
      <td style="text-align: center">Rd/Xt</td>
      <td style="text-align: center">目标寄存器，A32 指令可以选择 R0-R14，T32指令大部分只能选择R0-R7,A64指令可以选择X0-X30 或 W0-W30</td>
    </tr>
    <tr>
      <td style="text-align: center">Rn/Xn</td>
      <td style="text-align: center">第一个操作数的寄存器，和 Rd 一样，不同指令有不同要求</td>
    </tr>
    <tr>
      <td style="text-align: center">Opcode2</td>
      <td style="text-align: center">第二个操作数，可以是立即数，寄存器Rm 和寄存器移位方式(Rm, #shift)</td>
    </tr>
  </tbody>
</table>

<h2 id="sqdmulhvectorby-element">SQDMULH(vector/by element)</h2>

<p>Signed saturating Doubling Multiply return High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP</li>
  <li><code>&lt;T&gt;</code>:4H/8H/2S/4S 中的一个</li>
</ul>

<p>示例</p>

<ul>
  <li>sqdmulh v0.8h, v0.8h, v30.8h</li>
</ul>

<p>Signed saturation Doubling Multiply return High half(by element).该指令将第一个源寄存器的每个矢量元素乘以第二个源寄存器的某个特定矢量元素，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrdmulhvectorby-element">SQRDMULH(vector/by element)</h2>

<p>Signed saturating Rounding Doubling Multiply returning High half.该指令会将两个源寄存器中对应的元素相乘，将结果加倍，并把结果的高半部分放到矢量中，最后把矢量放到目的寄存器 SIMD&amp;FP 中。</p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;V&gt;&lt;m&gt;</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<p>Scalar:</p>

<p><code>SQRDMULH &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<p>Vector:</p>

<p><code>SQRDMULH &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;Ts&gt;[&lt;index&gt;]</code></p>

<h2 id="sqrshrun-sqrshrun2">SQRSHRUN, SQRSHRUN2</h2>

<p>Signed saturating Rounded Shift Right Unsigned Narrow(immediate).</p>

<p>Scalar:</p>

<p><code>SQRSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>sqrshrun v0.8b, v1.8h, #5</li>
</ul>

<p>Vector:</p>

<p><code>SQRSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="sqshrun-sqshrun2">SQSHRUN, SQSHRUN2</h2>

<p>Signed saturating Shift Right Unsigned Narror(immediate).</p>

<p>Scalar:</p>

<p><code>SQSHRUN &lt;Vb&gt;&lt;d&gt;, &lt;Va&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SQSHRUN{2} &lt;Vd&gt;.&lt;Tb&gt;, &lt;Vn&gt;.&lt;Ta&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
</ul>

<p>示例：</p>

<ul>
  <li>sqrshrun2 v0.16b, v1.8h, #5</li>
</ul>

<h2 id="shl">SHL</h2>

<p>Shift Left(immediate)。</p>

<p>Scalar:</p>

<p><code>SHL &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SHL &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<h2 id="shll-shll2">SHLL, SHLL2</h2>

<p>Shift Left Long(by element size)。</p>

<p>Vector:</p>

<p><code>SHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li>
    <p><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</p>
  </li>
  <li>shll  v28.8h, v30.8b,  #8</li>
  <li>shll2 v29.8h, v30.16b, #8</li>
</ul>

<h2 id="sshll-sshll2">SSHLL, SSHLL2</h2>

<p>Signed Shift Left Long(immediate)。</p>

<p><code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="ushll-ushll2">USHLL, USHLL2</h2>

<p>Unsigned Shift Left Long(immediate)。</p>

<p><code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #&lt;shift&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 的名字。</li>
  <li><code>&lt;Ta&gt;</code>:8H/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Tb&gt;</code>:8B/16B/4H/8H/2S/4S。</li>
</ul>

<h2 id="trn1--trn2">TRN1 &amp; TRN2</h2>

<p>TRN1:转置向量 Transpose vector(primary), 该指令从零开始读取两个源寄存器 SIMD&amp;FP 的相应偶数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN1 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;T&gt;</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn1 v4.2d, v4.2d, v5.2d</li>
</ul>

<p>TRN2:转置向量 Transpose vectors(secondary)。该指令读取两个源寄存器 SIMD&amp;FP 的相应奇数向量元素，并将每个结果放到向量的连续元素，并将向量写到目的寄存器中。第一个源寄存器中的向量元素被放到目的寄存器的偶数元素位置，第二个源寄存器中的向量元素放到目的寄存器的奇数元素位置。</p>

<p>Advanced SIMD variant</p>

<p><code>TRN2 &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;</code></p>

<ul>
  <li><code>&lt;Vd&gt;</code>:目的寄存器 SIMD&amp;FP 名字。</li>
  <li><code>T</code>:8B/16B/4H/8H/2S/4S/2D。</li>
  <li><code>&lt;Vn&gt;</code>:第一个源寄存器 SIMD&amp;FP 名字。</li>
  <li><code>&lt;Vm&gt;</code>:第二个源寄存器 SIMD&amp;FP 名字。</li>
</ul>

<p>示例：</p>

<ul>
  <li>trn2 v7.2s, v5.2s, v7.2s</li>
</ul>

<p><img src="http://lazybing.github.io/images/neon_coding/trn.png" /></p>

<h2 id="sxtl-sxtl2">SXTL, SXTL2</h2>

<p>SXTL:Signed extend Long,该指令</p>

<p>Vector:</p>

<p><code>SXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>SSHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>sxtl v0.8h, v0.8b</li>
</ul>

<h2 id="uxtl-uxtl2">UXTL, UXTL2</h2>

<p>UXTL:Unsigned extend Long.</p>

<p>Vector:</p>

<p><code>UXTL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;</code> 等同于 <code>USHLL{2} &lt;Vd&gt;.&lt;Ta&gt;, &lt;Vn&gt;.&lt;Tb&gt;, #0</code></p>

<p>示例：</p>

<ul>
  <li>uxtl v4.8h, v4.8b</li>
</ul>

<h2 id="ext">EXT</h2>

<p>EXT:Extract vector from pair of vectors.</p>

<p>Advanced SIMD variant</p>

<p><code>EXT &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, &lt;Vm&gt;.&lt;T&gt;, #&lt;index&gt;</code></p>

<p><img src="http://lazybing.github.io/images/neon_coding/ext.png" /></p>

<p>示例：</p>

<ul>
  <li>ext v5.16b, v4.16b, v4.16b, #2</li>
</ul>

<h2 id="bfm-ubfm-sbfmbitfield-move">BFM, UBFM, SBFM(Bitfield move指令)</h2>

<p>BFM:</p>

<p>32-bit variant</p>

<p><code>BFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>BFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>SBFM:</p>

<p>32-bit variant</p>

<p><code>SBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>SBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>UBFM:</p>

<p>32-bit variant</p>

<p><code>UBFM &lt;Wd&gt;, &lt;Wn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>64-bit variant</p>

<p><code>UBFM &lt;Xd&gt;, &lt;Xn&gt;, #&lt;immr&gt;, #&lt;imms&gt;</code></p>

<p>示例：</p>

<ul>
  <li>ubfm w9, w5, #7, #13</li>
</ul>

<h2 id="srshr">SRSHR</h2>

<p>SRSHR:Signed Rounding Shift Right(immediate)。</p>

<p>Scalar variant:</p>

<p><code>SRSHR &lt;V&gt;&lt;d&gt;, &lt;V&gt;&lt;n&gt;, #&lt;shift&gt;</code></p>

<p>Vector:</p>

<p><code>SRSHR &lt;Vd&gt;.&lt;T&gt;, &lt;Vn&gt;.&lt;T&gt;, #&lt;shift&gt;</code></p>

<p>示例：</p>

<ul>
  <li>srshr v24.8h, v24.8h, #2</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程5——重排矢量]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/23/neon-rearranging-vector/"/>
    <updated>2019-01-23T06:35:06-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/23/neon-rearranging-vector</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">开始之前</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">可替换的</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">指令</a>    <ul>
      <li><a href="#vmov--vswapmove--swap" id="markdown-toc-vmov--vswapmove--swap">VMOV 和 VSWAP：Move 和 Swap</a></li>
      <li><a href="#vrevreverse" id="markdown-toc-vrevreverse">VREV:Reverse</a></li>
      <li><a href="#vextextract" id="markdown-toc-vextextract">VEXT:Extract</a></li>
      <li><a href="#vrtntranspose" id="markdown-toc-vrtntranspose">VRTN:Transpose</a></li>
      <li><a href="#vzip--vuzpzip--unzip" id="markdown-toc-vzip--vuzpzip--unzip">VZIP 和 VUZP:Zip 和 Unzip</a></li>
      <li><a href="#vtbl-vtbxtable--table-extend" id="markdown-toc-vtbl-vtbxtable--table-extend">VTBL, VTBX:Table 和 Table Extend</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">其他</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">结论</a></li>
</ul>

<p>本文描述了用于重置矢量寄存器数据的NEON指令。</p>

<!--more-->

<h2 id="section">介绍</h2>

<p>当写 NEON 代码时，你或许会发现某些时候，寄存器中的数据格式并不适用于你的算法。可能需要重排矢量中的元素，从而让后续的算术可以。</p>

<p>重新排序操作称为<strong>permutation</strong>，<strong>permutation</strong>指令重置单独像素、选择从单个或多个寄存器来组织一个新的矢量。</p>

<h2 id="section-1">开始之前</h2>

<p>在使用 NEON 提供的<strong>permutation</strong>指令之前，一定要想清楚是否真的需要使用它们。<strong>permutation</strong>指令与 move 指令相似，因为它们通常代表用于准备数据而不是处理数据的 CPU 周期。</p>

<h2 id="section-2">可替换的</h2>

<p>如何避免不必要的<em>permutes</em>？有如下方法选项：</p>

<ul>
  <li>
    <p><strong>重排输入数据</strong>.</p>
  </li>
  <li>
    <p><strong>重新设计算法</strong></p>
  </li>
  <li>
    <p><strong>修改上一个处理阶段</strong></p>
  </li>
  <li>
    <p><strong>使用交错负载和存储</strong></p>
  </li>
  <li>
    <p><strong>综合方法</strong></p>
  </li>
</ul>

<h2 id="section-3">指令</h2>

<h3 id="vmov--vswapmove--swap">VMOV 和 VSWAP：Move 和 Swap</h3>

<h3 id="vrevreverse">VREV:Reverse</h3>

<h3 id="vextextract">VEXT:Extract</h3>

<h3 id="vrtntranspose">VRTN:Transpose</h3>

<h3 id="vzip--vuzpzip--unzip">VZIP 和 VUZP:Zip 和 Unzip</h3>

<h3 id="vtbl-vtbxtable--table-extend">VTBL, VTBX:Table 和 Table Extend</h3>

<h3 id="section-4">其他</h3>

<h2 id="section-5">结论</h2>

<p>仔细考虑你的代码是否真的需要重置你的数据是明智的。然而，当你的算法需要它时，permute 指令提供了一个高效的方法来使得你的数据存放到正确的格式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程4——左右移位]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right/"/>
    <updated>2019-01-22T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/22/neon-shifting-left-and-right</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">向量移位</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">移位与插入</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">移位与计算</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">指令修改器</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可用移位表</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">示例：转换颜色深度</a>    <ul>
      <li><a href="#section-6" id="markdown-toc-section-6">从 565 到 888</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">从888到565</a></li>
    </ul>
  </li>
  <li><a href="#section-8" id="markdown-toc-section-8">结论</a></li>
</ul>

<p>本文将介绍 NEON 提供的移位运算，并介绍如何利用移位运算在常用颜色深度之间转换影像数据。本系列前期已发布的文章包括：第一部分：加载与存储，第二部分：余数的处理，第三部分：矩阵乘法。</p>

<!--more-->

<h2 id="section">向量移位</h2>

<p>NEON 上的移位与标量 ARM 编码中可能用到的移位非常相似，即每个向量元素的位数均向左或向右移位，出现在每个元素左侧与右侧的位将被删除；它们不能移位至相连的元素。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_vector.png" /></p>

<p>带符号元素的向量上发生的右移位由指令附加的类型指定，并会将符号扩展至每一个元素。这与 ARM 编码中可能用到的算术移位相同。应用到无符号向量的移位不会发生符号扩展。</p>

<h2 id="section-1">移位与插入</h2>

<p>NEON 也支持通过插入产生移位，使两个不同向量的位相结合。例如，左移位与插入（VSLI）可使源向量的每一个元素均向左移位。每个元素右侧新插入的位就是目标向量中的对应为。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_insert.png" /></p>

<h2 id="section-2">移位与计算</h2>

<p>最后，NEON 还支持向量元素向右移位，并将结果计入到另一个向量中。这种方法对于先在高精度条件下进行临时计算，然后再将结果与低精度计算器相结合的情况非常有用。</p>

<h2 id="section-3">指令修改器</h2>

<p>每个移位指令都能拥有一个或多个修改器。这些修改器并不改变移位运算本身，而是通过调整输入值与输出值，消除偏差或饱和状态，保持一定的范围。共有五种移位修改器：</p>

<ul>
  <li>舍位修改器(Rounding)，以 R 前缀表示，可以纠正右移时舍位导致的偏差。</li>
  <li>窄修改器(Narrow)，以 N 后缀表示，可以让结果中每个元素的位数减半。它代表Q(128位)源和D(64位)目标寄存器。</li>
  <li>长修改器(Long),以 L 后缀表示，可以让结果中每个元素的位数加倍。它代表D源和Q目标寄存器。饱和修改器(Saturating)，以Q前缀表示，可以在最大和最小可表示范围内设置每个结果元素，前提是结果未超出该范围。向量的位数和符号类型可用于确定饱和范围。</li>
  <li>无符号饱和修改器(Unsigned Saturationg)，以Q前缀和U后缀表示，与饱和修改器类似，但在进行带符号与无符号输入时，结果将在无符号范围内表示为饱和。</li>
</ul>

<p>这些修改器的部分组合并未表现出有用的运算，因此 NEON 也没有提供相应指令。例如，饱和右移位（应称为 VQSHR）其实就毫无必要，因为右移位只会让结果变得更小，因而值根本无法超出有效范围。</p>

<h2 id="section-4">可用移位表</h2>

<p>NEON 提供的所有移位指令均在下表中列出。它们根据先前提到的修改器进行排列。如果你还是不太确定修改器各个字母代表的含义，请利用下表选择需要的指令。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/shift_table_avaliable.png" /></p>

<h2 id="section-5">示例：转换颜色深度</h2>

<p>颜色深度之间的转换是图形处理中经常需要的运算。通常，输入或输出数据都是 RGB565 16 位颜色格式，但 RGB888 格式的数据处理起来更为方便。对于 NEON 而言尤其如此，因为它无法为 RGB565 这样的数据类型提供本机支持。</p>

<p><img src="http://lazybing.github.io/images/neon_shift_left_right/color_format.png" /></p>

<p>但是，NEON 仍然可以有效地处理 RGB565 数据，上文中介绍的向量移位便提供了处理方法。</p>

<h3 id="section-6">从 565 到 888</h3>

<p>首先，我们来看如何将 RGB565 转换为 RGB888。假设寄存器 q0 中有 8 个 16 位像素，我们想要在 d2、d3和d4这三个寄存器中将红色、绿色和蓝色分离成 8 位的元素。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vshr.u8</span>     <span class="no">q1</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift red elements right by three bits,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">at</span> <span class="no">the</span> <span class="no">bottom</span> <span class="no">of</span> <span class="no">the</span> <span class="no">red</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vshrn.i16</span>   <span class="no">d2</span><span class="p">,</span> <span class="no">q1</span><span class="p">,</span> <span class="c">#5  @shift red element right and narrow,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits.</span>
</span><span class="line"><span class="nf">vshrn.i16</span>   <span class="no">d3</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#5  @shift green elements right and narrow,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">discarding</span> <span class="no">the</span> <span class="no">blue</span> <span class="no">bits</span> <span class="no">and</span> <span class="no">some</span> <span class="no">red</span> <span class="no">bits</span> <span class="no">due</span> <span class="no">to</span> <span class="no">narrowing.</span>
</span><span class="line"><span class="nf">vshl.i8</span>     <span class="no">d3</span><span class="p">,</span> <span class="no">d3</span><span class="p">,</span> <span class="c">#2  @shift green elements left, discarding the remaining red bits,</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">and</span> <span class="no">placing</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">in</span> <span class="no">the</span> <span class="no">correct</span> <span class="no">place.</span>
</span><span class="line"><span class="nf">vshl.i16</span>    <span class="no">q0</span><span class="p">,</span> <span class="no">q0</span><span class="p">,</span> <span class="c">#3  @shift blue elements left to most-significant </span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="mi">8</span><span class="p">-</span><span class="no">bit</span> <span class="no">color</span> <span class="no">channel.</span>
</span><span class="line"><span class="nf">vmovn.i16</span>   <span class="no">d4</span><span class="p">,</span> <span class="no">q0</span>      <span class="err">@</span><span class="no">remove</span> <span class="no">remaining</span> <span class="no">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">bits</span> <span class="no">by</span> <span class="no">narrowing</span> <span class="no">to</span> <span class="mi">8</span> <span class="no">bits</span>
</span></code></pre></td></tr></table></div></figure>

<p>每个指令的效果都在上面备注中做了描述，但总而言之，每个通道上执行的运算为：</p>

<ol>
  <li>利用移位推掉元素任意一端的位数，清除相邻通道的颜色数据。</li>
  <li>使用第二次移位将颜色数据放置到每个元素最重要的位上，并缩短位数将元素大小从 16 位减至 8 位。</li>
</ol>

<p>请注意在这个顺序中使用元素大小来确定 8 位和 16 位元素的位置，以进行部分掩码运算。</p>

<h3 id="section-7">从888到565</h3>

<p>现在，我们来看反向运算，即从 RGB888 转换为 RGB565。这里，我们假设 RGB888 数据为上述代码产生的格式；在d0、d1和d2这三个寄存器上，每个寄存器均包含每种颜色的 8 个元素。结果将存储为 q2 格式的 8 个 16 位 RGB565 元素。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vshll.u8</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">d0</span><span class="p">,</span> <span class="c">#8  @shift red element left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">ushll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d1</span><span class="p">,</span> <span class="c">#8  @shift green elements left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">fo</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements</span>
</span><span class="line"><span class="nf">vsri.16</span>    <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#5  @shift green elemnts right and insert into red</span>
</span><span class="line">                        <span class="err">@</span> <span class="nf">red</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vshll.u8</span>    <span class="no">q3</span><span class="p">,</span> <span class="no">d2</span><span class="p">,</span> <span class="c">#8  @shift blue elements left to most-significant</span>
</span><span class="line">                        <span class="err">@</span><span class="nf">bits</span> <span class="no">of</span> <span class="no">wider</span> <span class="mi">16</span><span class="p">-</span><span class="no">bit</span> <span class="no">elements.</span>
</span><span class="line"><span class="nf">vsri.16</span>     <span class="no">q2</span><span class="p">,</span> <span class="no">q3</span><span class="p">,</span> <span class="c">#11 @shift blue elements right and insert into</span>
</span><span class="line">                        <span class="err">@</span> <span class="nf">red</span> <span class="no">and</span> <span class="no">green</span> <span class="no">elements.</span>
</span></code></pre></td></tr></table></div></figure>

<p>同样，每个指令的详细说明在备注中列出，但总而言之，对于每个通道而言：</p>

<ol>
  <li>将每个元素的长度扩展到 16 位，并将颜色数据移至最重要的位上。</li>
  <li>使用插入右移位，将每个颜色通道放置到结果寄存器中。</li>
</ol>

<h2 id="section-8">结论</h2>

<p>NEON 提供的强大的移位指令范围让你能够：</p>

<ul>
  <li>利用舍入和饱和，通过二次幂快速进行向量的除法和乘法运算。</li>
  <li>通过移位将一个向量位复制到另一个向量位。</li>
  <li>在高精度条件下进行临时计算，并在低精度条件下计算结果。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程3——矩阵相乘]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication/"/>
    <updated>2019-01-21T06:44:07-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/21/neon-matrix-multiplication</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">矩阵</a></li>
  <li><a href="#algorithm" id="markdown-toc-algorithm">算法(Algorithm)</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">代码</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">浮点数运算</a></li>
      <li><a href="#d-and-q-" id="markdown-toc-d-and-q-">D and Q 寄存器</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">回到代码中</a></li>
    </ul>
  </li>
  <li><a href="#section-4" id="markdown-toc-section-4">定点运算</a>    <ul>
      <li><a href="#section-5" id="markdown-toc-section-5">宏定义：</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">如果考虑到调度的话</a></li>
</ul>

<p>前面两篇分别介绍了如何使用 NEON 来加载和存储数据，如何使用 NEON 处理多余的数据。这一篇介绍一点儿使用的数据处理——矩阵相乘。</p>

<!--more-->

<h2 id="section">矩阵</h2>

<p>本篇文章会分析如何有效的完成4x4矩阵相乘，这种操作在 3D 图形中经常会用到。假设矩阵存放到内存中，并且是列优先的顺序，该格式在 OpenGL-ES 中使用。</p>

<h2 id="algorithm">算法(Algorithm)</h2>

<p>先详细的检测一下矩阵相乘的操作，通过把计算扩展开，并确定哪些子操作可以使用 NEON 指令实现。</p>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/neon_matrix_multiply.png" /></p>

<p>在上图中，我们将第一个矩阵的每一列(红色标记)乘以在第二个矩阵中对应的数值(蓝色标记)，然后将结果加起来，得到结果中的一个列的数值。这个操作将被重复四次。</p>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/vector_by_scalar_multiply.png" /></p>

<p>如果每个列都是在 NEON 寄存器中的一个向量，我们能够用 vector-by-scalar multiplication 指令来计算每个列。即上图中显示的指令。我们可以用同样指令的累计版本来将结果都加起来组成每一列的结果。</p>

<p>当我们处理第一个矩阵的列，产生结果中的一列时，读取和写入数据到或者从内存中都是一个线性操作，不需要交错读取及存储指令。</p>

<h2 id="section-1">代码</h2>

<h3 id="section-2">浮点数运算</h3>

<p>首先，我们先关注乘以单精度浮点数矩阵的实现。</p>

<p>从内存中加载矩阵到 NEON 寄存器，该矩阵是使用列顺序进行存储，所以存储的列都是线性的存储在内存中。一个列能够用 VLD1 指令加载到 NEON 寄存器，用 VST1 写入到内存。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d20-d23</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span>   <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">vld1.32</span> <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span>   <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>    <span class="err">@</span><span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>

<p>NEON 有 32 个 64 位寄存器，我们可以从矩阵中加载所有的数据到寄存器，并且还有剩余的寄存器可以用来作为累加用。这里 d16 到 d23 保存第一个矩阵中的 16 个数据，而 d0 到 d7 保存第二个矩阵中的 16 个数据。</p>

<h3 id="d-and-q-">D and Q 寄存器</h3>

<p>大部分 NEON 指令能够用一下两种方式使用寄存器组：</p>

<ul>
  <li>32 个双字寄存器， 64bits 大小，从 d0 到 d31。</li>
  <li>16 个四字寄存器， 128bits 大小，从 q0 到 q15。</li>
</ul>

<p><img src="http://lazybing.github.io/images/neon_matrix_multiply/neon_register.png" /></p>

<p>这些寄存器用别名表示，因此，在 Q 寄存器，以及在相对应的两个 D 寄存器中，数据都是一样的。例如，q0 可被分为 d0 及 d1，数据可以在两种模式下进行访问。在 C 中，这种方式类似于 union。</p>

<p>对于浮点数矩阵乘法的例子，我们频繁的使用 Q 寄存器，因为我们处理 4 个 32-bit 浮点数的列，这将对应于一个 128 位的 Q 寄存器。</p>

<h3 id="section-3">回到代码中</h3>

<p>应用 NEON 乘法指令，我们能够计算矩阵相乘的一个列。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="nf">vmul.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>  <span class="err">@</span><span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>  <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q10</span><span class="p">,</span> <span class="no">d1</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span> <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line"><span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q11</span><span class="p">,</span> <span class="no">d1</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span> <span class="err">@</span><span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>

<p>第一个指令实现了在矩阵乘法分解图中的操作，x0、x1、x2 和 x3（在 q8 寄存器中）分别乘以 y0（d0 的第 0 个数据），结果保存在 q12。接下来的指令用于处理第一个矩阵中的其他列，乘以第二个矩阵第一列中对应的元素。结果将会累加到 q12，来构成最终结果的第一列。</p>

<p>需要注意的是，乘法指令中的标量是 D 寄存器，尽管q0[3]的数据与d1[1]相同，但是这里使用d1[1]更加说得过去，并且 GNU 汇编器并不支持这种格式。因此，我们不得不使用 D 寄存器。</p>

<p>宏：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="na">.macro</span> <span class="no">mul_col_f32</span> <span class="no">res_q</span><span class="p">,</span> <span class="no">col0_d</span><span class="p">,</span> <span class="no">col1_d</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="err">\</span><span class="no">col0_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>      <span class="err">@</span> <span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="err">\</span><span class="no">col0_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>      <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q10</span><span class="p">,</span> <span class="err">\</span><span class="no">col1_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>  <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="err">\</span><span class="no">res_q</span><span class="p">,</span> <span class="no">q11</span><span class="p">,</span> <span class="err">\</span><span class="no">col1_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>  <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">3</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line"><span class="na">.endm</span>
</span></code></pre></td></tr></table></div></figure>

<p>4x4 浮点矩阵相乘可以被这样实现：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d20-d23</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>              <span class="err">@</span> <span class="no">load</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vld1.32</span>  <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]!</span>              <span class="err">@</span> <span class="no">load</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q12</span><span class="p">,</span> <span class="no">d0</span><span class="p">,</span> <span class="no">d1</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q13</span><span class="p">,</span> <span class="no">d2</span><span class="p">,</span> <span class="no">d3</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q14</span><span class="p">,</span> <span class="no">d4</span><span class="p">,</span> <span class="no">d5</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">mul_col_f32</span> <span class="no">q15</span><span class="p">,</span> <span class="no">d6</span><span class="p">,</span> <span class="no">d7</span>           <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">
</span><span class="line">    <span class="nf">vst1.32</span>  <span class="err">{</span><span class="no">d24-d27</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">store</span> <span class="no">first</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span><span class="line">    <span class="nf">vst1.32</span>  <span class="err">{</span><span class="no">d28-d31</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]!</span>            <span class="err">@</span> <span class="no">store</span> <span class="no">second</span> <span class="no">eight</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-4">定点运算</h2>

<p>使用定点数运算通常比浮点数更快，因为它占用更小的内存带来读取及写入数值，并且整数的乘法通常来说更快。然而，在使用定点数运算时，当需要保证程序要求的计算精度时，你必须仔细选择表示方法来避免溢出或者饱和。</p>

<p>使用定点数进行矩阵乘法与浮点数非常类似。在这个例子中个，我们使用 Q1.14 定点数格式，但是操作上与其他格式类似，可能只需要最终左移的位数。</p>

<h3 id="section-5">宏定义：</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"><span class="na">.macro</span> <span class="no">mul_col_s16</span> <span class="no">res_d</span><span class="p">,</span> <span class="no">col_d</span>
</span><span class="line">    <span class="nf">vmull.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d16</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">0</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d17</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">1</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d18</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">2</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">2</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line">    <span class="nf">vmlal.s16</span>   <span class="no">q12</span><span class="p">,</span> <span class="no">d19</span><span class="p">,</span> <span class="err">\</span><span class="no">col_d</span><span class="err">[</span><span class="mi">3</span><span class="err">]</span>   <span class="err">@</span> <span class="no">multiply-acc</span> <span class="no">col</span> <span class="no">element</span> <span class="mi">3</span> <span class="no">by</span> <span class="no">matrix</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">    <span class="nf">vqrshrn.s32</span> <span class="err">\</span><span class="no">res_d</span><span class="p">,</span> <span class="no">q12</span><span class="p">,</span> <span class="c">#14            @ shift right and narrow accumulator into</span>
</span><span class="line">                                            <span class="err">@</span>  <span class="nf">Q1.14</span> <span class="no">fixed</span> <span class="no">point</span> <span class="no">format</span><span class="p">,</span> <span class="no">with</span> <span class="no">saturation</span>
</span><span class="line"><span class="na">.endm</span>
</span></code></pre></td></tr></table></div></figure>

<p>与浮点数版本的宏进行对比，你将会发现：</p>

<ul>
  <li>数值是16位而不是32为，我们可以使用D寄存器保存4个输入。</li>
  <li>两个16位数的相乘结果是一个32位数，我们使用VMULL及VMLAL，因为它们将保存结果至Q寄存器，使用两倍于数据的大小来保存所有的位数。</li>
  <li>最后的结果为16位，但是累加器是32位的。我们通过VQRSHRN获取16位结果，一个向量，饱和计算，四舍五入，右移窄运算。这将把所有正确的值加起来到各自的数据，右移并饱和计算到新的更窄的数据大小。</li>
</ul>

<p>32位数到16位数的减少对内存访问有所影响。数据会被加载和存储使用更少的指令，代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line"> <span class="nf">vld1.16</span>  <span class="err">{</span><span class="no">d16-d19</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r1</span><span class="err">]</span>       <span class="err">@</span> <span class="no">load</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">0</span>
</span><span class="line"> <span class="nf">vld1.16</span>  <span class="err">{</span><span class="no">d0-d3</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r2</span><span class="err">]</span>         <span class="err">@</span> <span class="no">load</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">matrix</span> <span class="mi">1</span>
</span><span class="line">
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d4</span><span class="p">,</span> <span class="no">d0</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">0</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d5</span><span class="p">,</span> <span class="no">d1</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">1</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d6</span><span class="p">,</span> <span class="no">d2</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">2</span>
</span><span class="line"> <span class="nf">mul_col_s16</span> <span class="no">d7</span><span class="p">,</span> <span class="no">d3</span>                      <span class="err">@</span> <span class="no">matrix</span> <span class="mi">0</span> <span class="p">*</span> <span class="no">matrix</span> <span class="mi">1</span> <span class="no">col</span> <span class="mi">3</span>
</span><span class="line">
</span><span class="line"> <span class="nf">vst1.16</span>  <span class="err">{</span><span class="no">d4-d7</span><span class="err">}</span><span class="p">,</span> <span class="err">[</span><span class="no">r0</span><span class="err">]</span>         <span class="err">@</span> <span class="no">store</span> <span class="no">sixteen</span> <span class="no">elements</span> <span class="no">of</span> <span class="no">result</span>
</span></code></pre></td></tr></table></div></figure>

<h2 id="section-6">如果考虑到调度的话</h2>

<p>我们会在以后的文章中讨论调度的细节，现在的话，可以看看在代码中查看改进指令调度的影响。</p>

<p>在宏中，临近的乘法指令写入到相同的寄存器，使得NEON流水线在开始下个指令执行时必须等待每个乘法完成。</p>

<p>如果我们把这些指令移出宏然后重新安排顺序，我们能够分离出那些依赖于其他指令的部分，这部分指令能够在其他指令在后台完成时也被执行。 
在这个实例中，我们重组代码来分离累加寄存器的使用。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="asm"><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col0</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col0</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q13</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d2</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col1</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col1</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q14</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d4</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col2</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col2</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmul.f32</span>    <span class="no">q15</span><span class="p">,</span> <span class="no">q8</span><span class="p">,</span> <span class="no">d6</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col3</span>  <span class="err">=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col0</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col3</span> <span class="no">elt0</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="no">q12</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d0</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col0</span> <span class="err">+=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col1</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col0</span> <span class="no">elt1</span><span class="p">)</span>
</span><span class="line">    <span class="nf">vmla.f32</span>    <span class="no">q13</span><span class="p">,</span> <span class="no">q9</span><span class="p">,</span> <span class="no">d2</span><span class="err">[</span><span class="mi">1</span><span class="err">]</span>              <span class="err">@</span> <span class="no">rslt</span> <span class="no">col1</span> <span class="err">+=</span> <span class="p">(</span><span class="no">mat0</span> <span class="no">col1</span><span class="p">)</span> <span class="p">*</span> <span class="p">(</span><span class="no">mat1</span> <span class="no">col1</span> <span class="no">elt1</span><span class="p">)</span>
</span><span class="line">    <span class="na">...</span>
</span><span class="line">    <span class="na">...</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程2——处理多余的数据]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers/"/>
    <updated>2019-01-20T00:56:44-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/20/neon-dealing-with-leftovers</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#fixing-up" id="markdown-toc-fixing-up">修复数据(Fixing Up)</a>    <ul>
      <li><a href="#larger-arrays" id="markdown-toc-larger-arrays">Larger Arrays</a>        <ul>
          <li><a href="#notes" id="markdown-toc-notes">Notes</a></li>
          <li><a href="#code-fragment" id="markdown-toc-code-fragment">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#overlapping" id="markdown-toc-overlapping">Overlapping</a>        <ul>
          <li><a href="#notes-1" id="markdown-toc-notes-1">Notes</a></li>
          <li><a href="#code-fragment-1" id="markdown-toc-code-fragment-1">Code Fragment</a></li>
        </ul>
      </li>
      <li><a href="#single-elements" id="markdown-toc-single-elements">Single Elements</a>        <ul>
          <li><a href="#notes-2" id="markdown-toc-notes-2">Notes</a></li>
        </ul>
      </li>
      <li><a href="#further-considerations" id="markdown-toc-further-considerations">Further Considerations</a>        <ul>
          <li><a href="#beginning-or-end" id="markdown-toc-beginning-or-end">Beginning or End</a></li>
          <li><a href="#alignment" id="markdown-toc-alignment">Alignment</a></li>
          <li><a href="#using-arm-to-fix-up" id="markdown-toc-using-arm-to-fix-up">Using Arm to Fix Up</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>上一篇关于NEON 加载和存储的文章中，在NEON 处理单元（寄存器）和内存之间进行数据传输。这篇文章中，我们会处理经常遇到的问题：输入数据并不对齐，也就是输入数据的长度并不是向量长度的整数倍。我们需要在数组开始或结束的位置处理剩余的元素。使用 NEON 哪种方式最有效呢？</p>

<!--more-->

<p>使用 NEON 处理数据时，通常处理的数据向量的长度从 4 个元素到 16 个元素。通常情况下，你会发现数据的实际长度并不是切好等于寄存器向量长度的倍数，你必须单独处理剩余的元素。</p>

<p>例如，你想要使用 NEON 每次加载、处理、存储 8 个元素，但你的数组有 21 个元素的长度。前面 2 组能够正常处理，但对第 3 个，还剩下 5 个元素没有处理。你要怎么做呢？</p>

<h2 id="fixing-up">修复数据(Fixing Up)</h2>

<p>有三种方法来处理剩余的数据，三种方法的需求、性能和代码大小都不相同，分别是<code>Larger Arrays</code>、<code>Overlapping</code>、<code>Single Elements</code>，第一种方法效率最高。</p>

<h3 id="larger-arrays">Larger Arrays</h3>

<p>如何可以改变处理数组的大小，使用填充元素增加数组的长度到下一个向量大小的倍数，就可以读写超出数据本身的边界而不会影响相邻的存储。下面的例子中，增加元素到 24 个元素是的第三组可以很好地完成而不会有数据损坏。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/larger_array.png" /></p>

<h4 id="notes">Notes</h4>

<ul>
  <li>分配更大的数组会消耗更大的内存。</li>
  <li>新的填充数据需要在初始化时给定一个值，该值不能够影响最后的计算结果。例如，如果是求和，填充数据就只能填充为 0.如果是要找到数组里面的最小值，可以设置填充数据为可以获取的最大值。</li>
  <li>某些情况下，没办法给定一个填充数据一个初始值，不影响最终结果，比如查找数据的范围时。</li>
</ul>

<h4 id="code-fragment">Code Fragment</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line">@ r1 = output array pointer
</span><span class="line">@ r2 = length of data in array
</span><span class="line">
</span><span class="line">@ We can assume that the array length is greater than zero, is an integer
</span><span class="line">@ number of vectors, and is greater than or equal to the length of data
</span><span class="line">@ in the array.
</span><span class="line">
</span><span class="line">    add r2, r2, #7      @ add (vector length - 1) to the data length
</span><span class="line">    lsr r2, r2, #3      @ divide the length of the array by the length
</span><span class="line">                        @ of a vector, 8, to find the number of
</span><span class="line">                        @ vectors of data to be processed
</span><span class="line">loop:
</span><span class="line">    subs r2, r2, #1     @ decrement the loop counter, and set flags
</span><span class="line">    vld1.8 {d0}, [r0]!  @ load eight elements from the array pointed to
</span><span class="line">                        @ by r0 into d0, and update r0 to point to the next vector
</span><span class="line">    ...
</span><span class="line">    ...                 @ process the input in d0
</span><span class="line">    ...
</span><span class="line">    vst1.8 {d0}, [r1]!  @ write eight elements to the output array, and 
</span><span class="line">                        @ update r1 to point to next vector
</span><span class="line">    bne loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>

<h3 id="overlapping">Overlapping</h3>

<p>如果操作合适，剩余元素可以使用重叠的方法来处理。这会对数组中的某些元素进行两次处理。</p>

<p>示例中，第一组处理元素从0-7，第二组处理元素从5-12，第三组处理元素是13-20。注意，第5-7个元素，在第一次和第二次处理的向量中有重合，它们处理了两次。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/neon_overlapping.png" /></p>

<h4 id="notes-1">Notes</h4>

<ul>
  <li>Overlapping 方法只有当输入数据的操作应用不会受操作次数的改变而改变时才能使用；例如，如果想要找到最大值可以使用该方法，而求和操作就不能使用该方法，因为 overlapping 会计算元素两次。</li>
  <li>数组中的元素数量至少能够填充一个完整的向量。</li>
</ul>

<h4 id="code-fragment-1">Code Fragment</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line">@ r1 = output array pointer
</span><span class="line">@ r2 = length of data in array
</span><span class="line">
</span><span class="line">@ We can assume that the operation is idempotent, and the array is greater
</span><span class="line">@ than or equal to one vector long.
</span><span class="line">
</span><span class="line">    ands r3, r2, #7     @ calculate number of elements left over after
</span><span class="line">                        @ processing complete vectors using
</span><span class="line">                        @ data length &amp; (vector length - 1)
</span><span class="line">    beq loopsetup       @ if the result of the ands is zero, the length
</span><span class="line">                        @ of the data is an integer number of vectors,
</span><span class="line">                        @ so there is no overlap, and processing can begin at the loop
</span><span class="line">                        @ handle the first vector separately
</span><span class="line">    vld1.8 {d0}, [r0], r3   @ load the first eight elements from the array,
</span><span class="line">                            @ and update the pointer by the number of elements left over
</span><span class="line">    ...
</span><span class="line">    ...                     @ process the input in d0
</span><span class="line">    ...
</span><span class="line">    vst1.8  {d0}, [r1], r3  @ wirte eight elements to the output array, and
</span><span class="line">                            @ update the pointer
</span><span class="line">                            @ now, set up the vector processing loop
</span><span class="line"> loopsetup:
</span><span class="line">     lsr  r2, r2, #3      @ divide the length of the array by the length
</span><span class="line">                             @  of a vector, 8, to find the number of
</span><span class="line">                             @  vectors of data to be processed
</span><span class="line"> 
</span><span class="line">                             @ the loop can now be executed as normal. the
</span><span class="line">                             @  first few elements of the first vector will
</span><span class="line">                             @  overlap with some of those processed above
</span><span class="line"> loop:
</span><span class="line">     subs    r2, r2, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0}, [r0]!  @ load eight elements from the array, and update
</span><span class="line">                             @  the pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class="line">                             @  update the pointer
</span><span class="line">     bne  loop            @ if r2 is not equal to 0, loop</span></code></pre></td></tr></table></div></figure>

<h3 id="single-elements">Single Elements</h3>

<p>NEON 提供的加载和存储指令可以对向量中的某个元素进行操作。使用这个操作，可以加载向量的单个元素，在上面执行操作，并把元素写会内存。</p>

<p>示例中的问题是，前面两组数据能够正常执行(0-7元素、8-15元素)。第三组需要处理剩余的 5 个元素，它们是单独的循环中处理的，每次都执行加载、处理和存储元素。</p>

<p><img src="http://lazybing.github.io/images/neon_deal_leftovers/neon_single_element.png" /></p>

<h4 id="notes-2">Notes</h4>

<ul>
  <li>该方法比上面提到的方法要效率低，因为每个元素都单独执行加载、处理和存储。</li>
  <li>处理剩余的元素需要两个循环——一个是向量、另一个是单个元素，这回增加函数中的代码量</li>
</ul>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">@ r0 = input array pointer
</span><span class="line"> @ r1 = output array pointer
</span><span class="line"> @ r2 = length of data in array
</span><span class="line"> 
</span><span class="line">     lsrs    r3, r2, #3      @ calculate the number of complete vectors to be
</span><span class="line">                             @  processed and set flags
</span><span class="line">     beq  singlesetup  @ if there are zero complete vectors, branch to
</span><span class="line">                             @  the single element handling code
</span><span class="line"> 
</span><span class="line">                             @ process vector loop
</span><span class="line"> vectors:
</span><span class="line">     subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0}, [r0]!  @ load eight elements from the array and update
</span><span class="line">                             @  the pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0}, [r1]!  @ write eight elements to the output array, and
</span><span class="line">                             @  update the pointer
</span><span class="line">     bne  vectors      @ if r3 is not equal to zero, loop
</span><span class="line"> 
</span><span class="line"> singlesetup:
</span><span class="line">     ands    r3, r2, #7      @ calculate the number of single elements to process
</span><span class="line">     beq  exit            @ if the number of single elements is zero, branch
</span><span class="line">                             @  to exit
</span><span class="line"> 
</span><span class="line">                             @ process single element loop
</span><span class="line"> singles:
</span><span class="line">     subs    r3, r3, #1      @ decrement the loop counter, and set flags
</span><span class="line">     vld1.8  {d0[0]}, [r0]!  @ load single element into d0, and update the
</span><span class="line">                             @  pointer
</span><span class="line">     ...
</span><span class="line">     ...                  @ process the input in d0[0]
</span><span class="line">     ...
</span><span class="line"> 
</span><span class="line">     vst1.8  {d0[0]}, [r1]!  @ write the single element to the output array,
</span><span class="line">                             @  and update the pointer
</span><span class="line">     bne  singles      @ if r3 is not equal to zero, loop
</span><span class="line"> 
</span><span class="line"> exit:</span></code></pre></td></tr></table></div></figure>

<h3 id="further-considerations">Further Considerations</h3>

<h4 id="beginning-or-end">Beginning or End</h4>

<p>Overlapping 和 single element 技术可以应用到处理数组的开始或结束位置。如何应用程序更适合处理结束端，上面的代码可以很容易的改成处理末端的元素。</p>

<h4 id="alignment">Alignment</h4>

<p>加载和存储地址应该与高速缓存线对齐，这样会使得内存访问更加高效。</p>

<p>对于 Cortex-A8，至少要 16 字节对齐，如果在输入或输出数组的开始位置没有对齐，就必须在数组的开始和结束位置处理元素。</p>

<p>当对齐内存来加速时，记得使用加载和存储指令时加上<code>:64</code>或<code>:128</code>或<code>:256</code>。</p>

<h4 id="using-arm-to-fix-up">Using Arm to Fix Up</h4>

<p>在使用<code>single elements</code>方法时，你可以使用 Arm 指令来对每个元素进行单独处理。然而，同时使用 Arm 指令和 NEON 指令来存储相同的内存会降低效率，因为通过 Arm 管道来写必须在 NEON 管道写完后才能进行。</p>

<p>一般情况下，应该避免同时使用 Arm 和 NEON 代码写到相同的内存区域，尤其是同一个高速缓存区域。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 编程1——加载和存储]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store/"/>
    <updated>2019-01-19T06:53:54-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-coding-load-and-store</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">示例</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">技术细节</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">概述</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">语法</a>        <ul>
          <li><a href="#section-4" id="markdown-toc-section-4">交错存取模式</a></li>
          <li><a href="#section-5" id="markdown-toc-section-5">元素类型</a></li>
          <li><a href="#sigle-or-multiple-elements" id="markdown-toc-sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</a></li>
          <li><a href="#addressing" id="markdown-toc-addressing">寻址(Addressing)</a></li>
        </ul>
      </li>
      <li><a href="#section-6" id="markdown-toc-section-6">其他存取指令</a></li>
    </ul>
  </li>
</ul>

<p>ARM NEON 技术是 64/128 位的混合 SIMD 架构，它的设计目的就是为了提高多媒体和信号处理应用的性能，包括视频编解码、音频编解码、3D 图像、声音和图像处理。</p>

<!--more-->

<p>针对如何利用汇编语言为 NEON 编写 SIMD，后面会出一系列文章，本篇为第一部分。该系列文章会包含如何开始 NEON，如何高效使用它，后面还会介绍编写更复杂代码的技巧。我们先从操作内存开始，以及如何利用序列指令，灵活的使用 load 和 store。</p>

<h2 id="section">示例</h2>

<p>我们从一个具体的示例开始。假设你有一个 24bit RGB 图像，像素在内存中的排列格式为 R,G,B,R,G,B…，假设你想要将其中的 R 和 B 进行交换，该如何利用 NEON，是的操作更加高效呢？</p>

<p>采用简单的线性 load 指令从内存中复制到寄存器里面，然后进行R/B 调换操作，会比较繁琐。示例如图</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/linear_load_rgb.png" /></p>

<p>基于上图中的输入，进行分割、移位、合并这种方法去交换通道会很麻烦，效率低下。</p>

<p>NEON 针对此种应用场景提供了结构化的加载和存储指令，它们会从内存中加载数据的同时将数据分发到不同的寄存器。如上面例子中，VLD3 指令可以分别将加载的 R/G/B数据分别放到三个不同的寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/structed_load_rgb.png" /></p>

<p>现在，只要交换R/B寄存器的内容(VSWP d0, d2),之后用类似的存储指令 VST3 将数据写会内存中即可。</p>

<h2 id="section-1">技术细节</h2>

<h3 id="section-2">概述</h3>

<p>NEON 结构化加载指令从内存中读取数据进入 64 位 NEON 寄存器，可以选择是否交错读取；同样的，存储指令将寄存器中的数据可以交错写回到内存中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/neon_structure_loads_stores.png" /></p>

<h3 id="section-3">语法</h3>

<p>结构化加载和存取指令的语法结构有 5 部分组成。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/neon_load_store_syntax.png" /></p>

<ul>
  <li>指令助记符，VLD 用于加载，VST 用于存储。</li>
  <li>交错存取的模式，此数字指定了相关元素之间的距离。</li>
  <li>访问的元素类型，该类型指定了元素的位宽。</li>
  <li>需要读取或者写入的寄存器集合，最大为4， 取决于交错存取的模式。</li>
  <li>ARM 地址寄存器，包含需要访问的内存地址。</li>
</ul>

<h4 id="section-4">交错存取模式</h4>

<p>NEON 指令能够加载和存储数据并以交错方式加载或存储1-4个相同位宽的元素，NEON 支持8、16、32bit的交错存取元素。</p>

<ul>
  <li>VLD1 是最简单的一种形式，该指令能从内存中线性加载数据到1-4个寄存器中，一般用于无交错存取的数据处理。</li>
  <li>VLD2 可以从内存中加载数据到 2 或 4 个寄存器中，将交错的奇数和偶数项的数据分别加载到不同的寄存器中，一般用于立体声的左右声道的分离。</li>
  <li>VLD3 加载交错距离为 3 的数据到 3 个寄存器中，一般用于图像中 RGB 通道的分离。</li>
  <li>VLD4 加载交错距离为 4 的数据到 4 个寄存器中，一般用于图像中 ARGB 通道的分离。</li>
</ul>

<p>存储指令类似加载指令，但是在写入到内存之前就已经完成了数据元素交错。</p>

<h4 id="section-5">元素类型</h4>

<p>交错元素的存取规则取决于指令本身。例如，使用 VLD2.16 加载数据，完成操作后，共加载 8 个 16bit 的元素，其中偶数项元素加载到第一个寄存器，奇数项元素加载到第二个寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/100310_MC_diag3-1.png" /></p>

<p>元素大小变成 32 之后，加载同样大小的数据(4x32),然而每个寄存器中只有2个元素(2x32)，与 VLD2.16 一样，VLD2.32 同样是偶数项元素加载到第一个寄存器中，奇数项元素加载到第二个寄存器中。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/100310_MC_diag3a-1.png" /></p>

<p>元素大小还会影响字节顺序，一般来讲，如果你是在存取指令中指定了正确的元素大小，从内存中读取的字节顺序将符合你的语气，并且相同的代码能在大端或者小端系统上运行良好。</p>

<p>最后，元素大小对于指针对齐也有一定的影响，指针地址对齐到元素大小将具有更好的性能，例如，当加载 32 位的元素时，内存首地址最小要对齐 32 位。</p>

<h4 id="sigle-or-multiple-elements">单个或多个元素(Sigle or Multiple Elements)</h4>

<p>除了一次加载多个元素外，结构化的加载指令还能够一次从内存中读取一个元素，并且交错的放到不同的寄存器中，或者是放到寄存器的所有通道中，或者是放到寄存器的单个通道，其他通道不受影响。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/deinterleaving_vector_lanes.png" /></p>

<p>后面的描述对于从散乱的内存中构造出一个 vector 比较有用。</p>

<p><img src="http://lazybing.github.io/images/neon_load_store/deinterleaving_single_vect.png" /></p>

<p>存储指令和读取指令类似。</p>

<h4 id="addressing">寻址(Addressing)</h4>

<p>结构化的加载和存取指令支持 3 种格式来指定地址。</p>

<ul>
  <li><code>Register:[{,:}]</code>,这是最简单的寻址方式，数据在指定地址中进行存取</li>
  <li><code>Register with increment after:[{,:}]!</code>, 这种寻址方式在完成数据加载后将更新指针使其指向之后待处理的元素，指针的增长大小与指令存取的字节数一致。</li>
  <li><code>Register with post-index:[{,:}]</code>，这种寻址方式在完成数据存取之后将改变指针，指针增加指定量（由寄存器 Rm 指定），这种方式在存取元素分散在固定距离的情况下比较方便，如读取图像的一列像素。</li>
</ul>

<p>同样的，也可以通过指定 Rn 来指定指针的对齐，使用 optional:parameter 这样同样能加快内存的读取。</p>

<h3 id="section-6">其他存取指令</h3>

<p>这里只介绍了结构化的存取指令，NEON 还提供了如下指令：</p>

<ul>
  <li>VLDR 和 VSTR，存取单个 64 位寄存器</li>
  <li>VLDM 和 VSTM，加载多个 64 位寄存器，方便从栈上存取数据。</li>
</ul>

<p>更多关于加载和存取操作的细节，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0406b/index.html&amp;_ga=2.76337745.535197283.1547875098-60705264.1529324001">Arm Architecture Reference Manual</a>, 关于每条指令所占用的时钟周期数，可以参考<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.set.cortexa/index.html&amp;_ga=2.41000550.535197283.1547875098-60705264.1529324001">Technical Reference Manual for each core</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NEON 技术概述]]></title>
    <link href="http://lazybing.github.io/blog/2019/01/19/neon-technology-overview/"/>
    <updated>2019-01-19T00:10:40-08:00</updated>
    <id>http://lazybing.github.io/blog/2019/01/19/neon-technology-overview</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#neon-" id="markdown-toc-neon-">NEON 概述</a></li>
  <li><a href="#neon" id="markdown-toc-neon">如何使用 NEON</a>    <ul>
      <li><a href="#neon--1" id="markdown-toc-neon--1">NEON 库</a>        <ul>
          <li><a href="#arm-" id="markdown-toc-arm-">用于机器学习和计算机视觉的 Arm 计算库</a></li>
        </ul>
      </li>
      <li><a href="#autovectorization" id="markdown-toc-autovectorization">AutoVectorization（自动向量化）</a></li>
      <li><a href="#compiler-intrinsics-" id="markdown-toc-compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</a></li>
      <li><a href="#assembly-code" id="markdown-toc-assembly-code">Assembly Code(汇编代码)</a></li>
    </ul>
  </li>
  <li><a href="#section" id="markdown-toc-section">开发工具</a></li>
  <li><a href="#neon--2" id="markdown-toc-neon--2">NEON 生态系统</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">参考资源:</a></li>
</ul>

<p>ARM NEON 技术是针对<code>Arm Cortex-A/R52</code>系列处理器的一种高级 SIMD 架构扩展。NEON 技术在 Armv7-A 和 Armv7-R 架构时开始引入，现在同样是 Armv8-A 和 Armv8-R 架构的扩展。</p>

<p>NEON 技术使用场景非常多，例如通过提高音视频编解码速度来提供更好的多媒体体验、加速数字信号处理算法和功能来加速音视频处理的应用、语音和面部识别、计算机视觉和深度学习。</p>

<!--more-->

<p><img src="http://lazybing.github.io/images/neon_overview/SIMDArchitecture-20.png" /></p>

<h2 id="neon-">NEON 概述</h2>

<p>NEON 技术是一个打包的 SIMD 架构。NEON 寄存器是相同数据类型的向量元素，它可以支持多种数据类型。下表描述了不同架构版本支持的数据类型：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Armv7-A/R</th>
      <th style="text-align: center">Armv8-A/R</th>
      <th style="text-align: center">Armv8-A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Floating point</td>
      <td style="text-align: center">32-bit</td>
      <td style="text-align: center">16-bit*/32-bit</td>
      <td style="text-align: center">16-bit*/32-bit/64-bit</td>
    </tr>
    <tr>
      <td style="text-align: center">Integer</td>
      <td style="text-align: center">8-bit/16-bit/32-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
      <td style="text-align: center">8-bit/16-bit/32-bit/64-bit</td>
    </tr>
  </tbody>
</table>

<p>NEON 指令针对向量中的所有通道执行相同的操作，操作的个数会根据不同数据类型而不同。NEON 指令允许下面的类型：</p>

<ul>
  <li>16x8-bit, 8x16-bit, 4x32-bit, 2x64-bit整形操作</li>
  <li>8x16-bit*, 4x32-bit, 2x64-bit** 浮点型操作</li>
</ul>

<p>其中<code>*</code>代表只存在于 Armv8.2-A 架构中，<code>**</code>代表只存在于 Armv8-A/R 架构中。</p>

<p>NEON 技术也能够支持多个指令并行发布。</p>

<h2 id="neon">如何使用 NEON</h2>

<p>NEON 的使用方式有多种，比如使用 NEON 库、编译器的 auto-vectorization 功能、NEON intrinsics（内联函数）、NEON 汇编代码。
关于 NEON 编程的详细信息可以参考<a href="https://static.docs.arm.com/den0018/a/DEN0018A_neon_programmers_guide_en.pdf?_ga=2.112843328.535197283.1547875098-60705264.1529324001">NEON 编程指南</a>.</p>

<h3 id="neon--1">NEON 库</h3>

<p>利用 NEON 的最简单的方式就是使用已经使用了 NEON 的开源库。</p>

<h4 id="arm-">用于机器学习和计算机视觉的 Arm 计算库</h4>

<p>Arm 计算库的目标是对于图像处理、计算机视觉和机器学习，它包含一些列针对 Arm CPU 和 GPU 架构的低级优化。更多信息可以访问<a href="https://developer.arm.com/technologies/compute-library">compue-library</a>.</p>

<p>Ne10 是一个开源的 C 库，由 arm 公司在 github 上维护，它包含了一组最常用的功能，这些功能都已经为 arm 做了专项优化。Ne10 是一个模块化结构，包含了很多小的库，目前包含的主要功能有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Math functions</th>
      <th style="text-align: center">Signal Processing functions</th>
      <th style="text-align: center">Image processing functions</th>
      <th style="text-align: center">Physics functions</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Vector Add</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center">Image Resize</td>
      <td style="text-align: center">Collision Detection</td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix-Add</td>
      <td style="text-align: center">Complex-to-Complex FFT</td>
      <td style="text-align: center">Image Rotate</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract</td>
      <td style="text-align: center">Floating &amp; Fixed Point</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Vector Subtract From</td>
      <td style="text-align: center">Real-to-Complex FFT</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">Matrix Subtract</td>
      <td style="text-align: center">FIR Filters</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>libyuv 是一个开源项目库，它包含了 YUV 缩放和转换功能。</p>

<p>skia 库是一个针对 2D 图像的开源库，用作 谷歌 Chrome 和 Chrome OS, Android、Mozilla Firefox 和 Firefox OS 以及其他许多产品的图形引擎。</p>

<h3 id="autovectorization">AutoVectorization（自动向量化）</h3>

<p>auto-vectorization 特性是由 arm 编译器支持的，编译器会自动利用 NEON 功能。支持该特性的编译器有:</p>

<ul>
  <li>Arm Compiler 5</li>
  <li>Arm LLVM-based Compiler 6</li>
  <li>GCC</li>
</ul>

<p>NEON 编程指南在 arm 编译器使用用户指导部分同样对于 NEON 选项提供了额外的指导。</p>

<h3 id="compiler-intrinsics-">Compiler Intrinsics (编译内联函数)</h3>

<p>使用内联函数，编译器会在编译时将内联函数替换成一条或几条对应的 NEON 指令。内联函数提供的功能与汇编语言差不多，但将寄存器的使用交给了编译器，
所以开发者可以专注在算法上。它同样可以执行指令调度从而移除指定目标处理器的流水线停顿。内联函数的可维护性比汇编语言更好，支持内联函数的编译器包括 ARM 编译器、GCC 编译器和 LLVM 编译器。</p>

<p>更多关于 Intrinsics 的信息，可以参考<a href="https://developer.arm.com/technologies/neon/intrinsics">Arm NEON Intrinsics Reference document</a>,该参考文档记录了 Armv7 和 Armv8 架构的 NEON Intrinsics 使用方法。示例代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;arm_neon.h&gt;</span>
</span><span class="line"><span class="kt">uint32x4_t</span> <span class="nf">double_elements</span><span class="p">(</span><span class="kt">uint32x4_t</span> <span class="n">input</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">vaddq_u32</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="assembly-code">Assembly Code(汇编代码)</h3>

<p>为例更高的性能，NEON 汇编代码是最好的方法，只要支持 NEON instructions 的编译器，GNU 编译器(gas) 和 ARM 编译器(armasm) 都支持汇编代码。</p>

<h2 id="section">开发工具</h2>

<p><code>Arm DS-5 Development Studio</code>为基于 Arm 平台提供了用于 C/C++ 软件开发的端到端的工具套件，DS-5 从编程到调试对 NEON 架构提供了全支持。DS-5 调试器提供 NEON 指令的完整调试功能和架构寄存器的可视化。DS-5 调试器支持所有 Arm 架构配置文件和处理器。</p>

<p><img src="http://lazybing.github.io/images/neon_overview/DS5.png" /></p>

<h2 id="neon--2">NEON 生态系统</h2>

<p>NEON 在如下表格所示的领域内有广泛的使用，其中包含了很多跨平台的开源项目：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Video Codecs</th>
      <th style="text-align: center">Audio Codecs</th>
      <th style="text-align: center">Voice and speech codecs</th>
      <th style="text-align: center">Audio enhancement algorithms</th>
      <th style="text-align: center">Computer Vision</th>
      <th style="text-align: center">Machine and deep leaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">VP9 OTT encoder, VP9 Consumer encoder/decoder</td>
      <td style="text-align: center">MP3 encoder/decoder</td>
      <td style="text-align: center">G.711</td>
      <td style="text-align: center">Echo cancellation</td>
      <td style="text-align: center">Canny Edge detection</td>
      <td style="text-align: center">On-device object recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">H.264(AVC) encoder/decoder</td>
      <td style="text-align: center">MPEG-2 layer I&amp;II encoder/decoder</td>
      <td style="text-align: center">G.722, G.722.1, G.722.2</td>
      <td style="text-align: center">Noise Reduction</td>
      <td style="text-align: center">Harris Corner</td>
      <td style="text-align: center">On-device scene recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG4 SP/ASP encoder/decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder</td>
      <td style="text-align: center">G.723.1</td>
      <td style="text-align: center">Beam Forming</td>
      <td style="text-align: center">ORB</td>
      <td style="text-align: center">Human pose recognition</td>
    </tr>
    <tr>
      <td style="text-align: center">MPEG2 decoder</td>
      <td style="text-align: center">MPEG-1 layer III audio encoder /decoder</td>
      <td style="text-align: center">G.726</td>
      <td style="text-align: center">Comfort Noise</td>
      <td style="text-align: center">Convolution filter</td>
      <td style="text-align: center">Defect detection</td>
    </tr>
    <tr>
      <td style="text-align: center">H.263 decoder</td>
      <td style="text-align: center">HE-AACv1, v2 encoder/decoder</td>
      <td style="text-align: center">G.727</td>
      <td style="text-align: center">AudioZoom</td>
      <td style="text-align: center">Erosion/Dilation</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Standart encoder/decoder</td>
      <td style="text-align: center">G.728</td>
      <td style="text-align: center">Equalization</td>
      <td style="text-align: center">Face detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">WMA Pro, WMA Lossless decoder</td>
      <td style="text-align: center">G.729, G.279A, G.729B</td>
      <td style="text-align: center">Wind noise reduction</td>
      <td style="text-align: center">Pedestrian detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">SBC Bluetooth encoder/decoder</td>
      <td style="text-align: center">G.729AB</td>
      <td style="text-align: center">Automatic Gain Control</td>
      <td style="text-align: center">Fast9/Fast12 corner detection</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">OggVorbis encoder/decoder</td>
      <td style="text-align: center">AMR Narrowband, Wideband, Wideband+</td>
      <td style="text-align: center">Voice Activity Detection</td>
      <td style="text-align: center">Object tracking</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
      <td style="text-align: center">…</td>
    </tr>
  </tbody>
</table>

<p>有关 NEON 生态系统的更多合作伙伴可以参考 <a href="https://developer.arm.com/technologies/dsp/arm-dsp-ecosystem-partners">DSP Ecosystem Partners page</a>。</p>

<h2 id="section-1">参考资源:</h2>

<ol>
  <li><a href="https://www.youtube.com/watch?v=ixuDntaSnHI">Taming Armv8 NEON:from theory to benchmark results</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores">Coding for NEON - Part 1: Load and Stores</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-2-dealing-with-leftovers">Coding for NEON - Part 2: Dealing With Leftovers</a>.</li>
  <li><a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-3-matrix-multiplication">Coding for NEON - Part 3: Matrix Multiplication</a>.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(二)之film_grain]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis/"/>
    <updated>2018-10-17T08:35:36-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/17/av1-film-grain-synthesis</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#film-grain-" id="markdown-toc-film-grain-">Film Grain 简介</a></li>
  <li><a href="#film-grain--1" id="markdown-toc-film-grain--1">Film Grain 流程</a></li>
  <li><a href="#section" id="markdown-toc-section">参考文档</a></li>
</ul>

<p><code>Film Grain</code>在电视和电影内容中广泛存在，它经常是创作内容的一部分，在编码过程中需要保留下来，因为<code>film grain</code>的随机性，导致很难用传统的压缩算法进行压缩。</p>

<!--more-->

<h1 id="film-grain-">Film Grain 简介</h1>

<p><code>film grain</code>模型和整体框架如图所示。</p>

<p><img src="http://lazybing.github.io/images/film_grain_av1/film_grain_framework.png" /></p>

<p><code>film grain</code>在去噪音过程中会从视频中去除掉，<code>grain</code>参数会通过噪音视频序列和去噪视频序列的差异中获得,这些参数会和压缩视频流一起传输到解码端。 解码后，<code>film grain</code>会被叠加到重建视频帧中。</p>

<h1 id="film-grain--1">Film Grain 流程</h1>

<p>从上面的框架图可以看出，<code>film grain</code>包括压缩前的去噪、编码参数、解码参数、噪音叠加到重建帧等几个过程，这里不讨论去噪的过程，主要讨论<code>film grain modeling synthesis</code>。
流程可以从<code>SPEC</code>中看到，也可以从源码中学习，<code>film grain</code>中在源码中主要集中在<code>aom/aom_dsp/grain_synthesis.c</code>中的<code>av1_add_film_grain_run</code>函数中，分析源码可知大致分为如下流程：</p>

<ul>
  <li>init_array. 为<code>film grain</code>准备后面用到的内存，大致分为三类<code>grain buffer(luma_grain_block/cb_grain_block/cr_grain_block)</code>、<code>line buf(y_line_buf/cb_line_buf/cr_line_buf)</code>、<code>column buf(y_col_buf/cb_col_buf/cr_col_buf)</code>。</li>
  <li>generate_luma_grain_block 和 generate_chroma_grain_blocks. 它会根据码流中 parse 出来的<code>grain_scale_shift/ar_coeff_lag</code>的值和<code>gaussian_sequence</code>表来填充<code>grain block</code>。</li>
  <li>init_scaling_function. 它是利用码流中 parse 出来的 <code>scaling_points_y</code>来填充<code>scaling_lut_y/scaling_lut_cb/scaling_lut_cr</code>数组。</li>
  <li>add_noise_to_block。它会根据上面生成的<code>grain block</code>叠加到重建帧上。</li>
</ul>

<h1 id="section">参考文档</h1>

<ol>
  <li><a href="https://aomediacodec.github.io/av1-spec/">AV1 Bitstream &amp; Decoding Process</a></li>
</ol>

<p>(未完待续…)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Av1解码详解(一)]]></title>
    <link href="http://lazybing.github.io/blog/2018/10/15/av1-startup/"/>
    <updated>2018-10-15T07:43:02-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/10/15/av1-startup</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#aom-" id="markdown-toc-aom-">AOM 工程</a>    <ul>
      <li><a href="#av1-" id="markdown-toc-av1-">AV1 前期准备</a></li>
      <li><a href="#section" id="markdown-toc-section">获取源码</a></li>
      <li><a href="#section-1" id="markdown-toc-section-1">编译</a>        <ul>
          <li><a href="#linux-" id="markdown-toc-linux-">Linux 下编译方法</a></li>
          <li><a href="#windows-" id="markdown-toc-windows-">Windows 下编译方法</a></li>
          <li><a href="#section-2" id="markdown-toc-section-2">交叉编译</a></li>
        </ul>
      </li>
      <li><a href="#section-3" id="markdown-toc-section-3">配置选项</a></li>
      <li><a href="#aom-vs-" id="markdown-toc-aom-vs-">AOM VS 工程</a></li>
    </ul>
  </li>
  <li><a href="#dav1d-" id="markdown-toc-dav1d-">DAV1D 工程</a>    <ul>
      <li><a href="#dav1d--1" id="markdown-toc-dav1d--1">DAV1D 下载</a></li>
      <li><a href="#dav1d--2" id="markdown-toc-dav1d--2">DAV1D 工程编译</a></li>
      <li><a href="#dav1d-vs-" id="markdown-toc-dav1d-vs-">DAV1D VS 工程</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
    </ul>
  </li>
</ul>

<p><a href="https://en.wikipedia.org/wiki/AV1">AV1</a>作为一个开放、免专利的视频编码格式，专为通过网络进行刘传书而设计。学习一个新的视频编解码标准除了看<a href="https://aomediacodec.github.io/av1-spec/av1-spec.pdf">SPEC</a>,最好的方法是看源码<code>aom</code>。本文主要记录官方工程 AOM 和 DAV1D 两个工程的建立。</p>

<!--more-->

<h2 id="aom-">AOM 工程</h2>

<h3 id="av1-">AV1 前期准备</h3>

<ul>
  <li>安装<code>CMake</code>，版本需求 3.5 以上。</li>
  <li>安装<code>Git</code>。</li>
  <li>安装<code>Perl</code>。</li>
  <li>对于<code>x86</code>,需要安装<code>yasm</code>或<code>nasm</code>。</li>
  <li>安装<code>python</code>。</li>
</ul>

<h3 id="section">获取源码</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ git clone https://aomedia.googlesource.com/aom</span></code></pre></td></tr></table></div></figure>

<h3 id="section-1">编译</h3>

<p><code>AV1</code>采用的配制方法不再是通常的<code>config</code>命令，而是<code>cmake</code>.<code>cmake</code>会生成配置文件和编译文件，大多数系统中，默认的编译文件是<code>Makefile</code>。
执行<code>cmake</code>会得到如下提示:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cmake [options] &lt;path-to-source&gt;
</span><span class="line">...
</span><span class="line">Options
</span><span class="line">    -G &lt;generator-name&gt; = Specify a build system generator.</span></code></pre></td></tr></table></div></figure>

<p>某些参数可以直接通过 cmake传递进去，如是否编译<code>encoder</code>。</p>

<blockquote>
  <p>其实不止 AV1 的官方代码，<code>DAV1D</code>工程，同样有类似的配置过程，只不过它使用的是<code>meson</code>而不是<code>cmake</code>，但效果是一样的。</p>
</blockquote>

<h4 id="linux-">Linux 下编译方法</h4>

<p>Linux 下的编译最简单了，只需要用<code>cmake</code>配置，然后<code>make</code>编译即可。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ cmake path/to/aom
</span><span class="line">$ make</span></code></pre></td></tr></table></div></figure>
<p>上面的方法就可以用到<code>Linux</code>平台下，生成<code>aomdec</code>可执行文件，进行解码。</p>

<h4 id="windows-">Windows 下编译方法</h4>

<p><code>Windows</code>下使用<code>Visual Studio</code>同样可以编译运行<code>av1</code>的代码。只需要在<code>cmake</code>时指定 VS 版本号即可,支持的工具可以通过<code>cmake --help</code>来查看。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ make aom_vs
</span><span class="line">$ cd aom_vs
</span><span class="line">$ cmake /path/to/aom -G "Visual Studio 12 2013 Win64" -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0 -DAOM_TARGET_CPU=generic</span></code></pre></td></tr></table></div></figure>
<p>此时在<code>aom_vs</code>路径下，会生成一个<code>AOM.sln</code>,用<code>VisualStudio 2013</code>打开该文件后，编译运行即可使用<code>VisualStudio</code>调试学习了。</p>

<h4 id="section-2">交叉编译</h4>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ mkdir aom_armv7
</span><span class="line">$ cd aom_armv7
</span><span class="line">$ CFLAGS="-pie -fPIE" LDFLAGS="-pie -fpIE" cmake /path/to/aom -DCROSS=/path/to/cross_build_tool_bin/ -DCMAKE_TOOLCHAIN_FILE=/path/to/tools -DCONFIG_AV1_ENCODER=0 -DCONFIG_LOWBITDEPTH=0
</span><span class="line">$ make</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">配置选项</h3>

<p>上面再编译的过程中，已经提到了很多配置选项，在此举几个例子：</p>

<ul>
  <li><code>-DCONFIG_AV1_ENCODER=0</code>表示不编译<code>av1 encoder</code>。</li>
  <li><code>-DAOM_TARGET_CPU=generic</code>表示不编译汇编。</li>
  <li><code>-G "Visual Studio 12 2013 Win64"</code>表示生成的配置文件，可以通过<code>VS2013</code>来打开编译运行。</li>
  <li><code>-DCMAKE_CONFIGURATION_TYPES=Debg</code>表示生成Debug 类型的可执行文件。</li>
</ul>

<h3 id="aom-vs-">AOM VS 工程</h3>

<p><img src="http://lazybing.github.io/images/av1_startup/aom_vs.png" /></p>

<h2 id="dav1d-">DAV1D 工程</h2>

<p>DAV1D 工程是一个跨平台的 AV1 解码器，该开源项目的目标是加速解码进度，解决目前还没有硬件支持 AV1 解码的问题。它包括了大多数 AOM 工程的特性。浏览该工程源码，该源码代码比较紧凑、很多函数甚至是宏定义完成的，调试非常困难……</p>

<h3 id="dav1d--1">DAV1D 下载</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$git clone git@code.videolan.org:videolan/dav1d.git
</span><span class="line">$git clont https://code.videolan.org/videolan/dav1d.git</span></code></pre></td></tr></table></div></figure>

<h3 id="dav1d--2">DAV1D 工程编译</h3>

<ol>
  <li>安装<code>Meson(0.47或更高版本)和 Ninja</code>，如果是 x86 平台，需要安装<code>nasm(2.13.02或更高版本)</code></li>
  <li>cd dav1d</li>
  <li><code>meson --buildtype debug --backend vs2017 ./ vs2017</code>，其中各个参数的含义，可以通过<code>meson --help</code>命令查看，注意，该命令的执行要在 Visual Studio 工程的 Native Tool Command 下执行。有时可能是安装时的配置的问题，即使在 Native Tool Command 下执行，仍然有问题，我是在<code>Developer Command Prompt for VS 2017</code>下执行成功的。</li>
  <li>安装完成后，就可以使用 Visual Studio 2017 打开 dav1d.sln 了。</li>
</ol>

<h3 id="dav1d-vs-">DAV1D VS 工程</h3>

<p><img src="http://lazybing.github.io/images/av1_startup/dav1d_vs.png" /></p>

<h3 id="section-4">参考文档</h3>

<p><a href="https://aomedia.googlesource.com/aom/+/master/README.md">AV1 Codec Library</a></p>

<p><strong><em>欢迎添加微信交流</em></strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C语言调用静态库和动态库简介]]></title>
    <link href="http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library/"/>
    <updated>2018-09-18T21:27:55-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/09/18/linux-c-static-dynamic-library</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">动态库和静态库简述</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">静态库使用示例</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">动态库使用示例</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">动态库和静态库整合</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">参考文档</a></li>
</ul>

<p>最近工作中遇到要把第三方静态库整合到自己的动态开里的问题，在此记录并整理一些关于静态库和动态库的知识，并用特定的例子。</p>

<!--more-->

<h3 id="section">动态库和静态库简述</h3>

<p>动态库和静态库本质上是一种可执行代码的二进制形式，它们可以被操作系统载入内存执行。两者的主要区别是，静态库是在编译过程中被载入可执行程序的，体积较大；动态库是在可执行程序在运行时被载入内存的，在编译过程中仅仅使用简单的引用，体积较小。</p>

<p>给出示例代码如下：</p>

<figure class="code"><figcaption><span>sayhello.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &quot;sayhello.h&quot;</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><figcaption><span>sayhello.h </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#ifndef _SAYHELLO_H_</span>
</span><span class="line"><span class="cp">#define _SAYHELLO_H_</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-1">静态库使用示例</h3>

<p>编译静态库：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -Wall -O2 -fPIC -I./ -c -o sayhello.o sayhello.c
</span><span class="line">$ ar crv libsayhello.a sayhello.o</span></code></pre></td></tr></table></div></figure>

<p><code>ar</code>命令会生成<code>libsayhello.a</code>的静态库。该命令的参数如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">参数</th>
      <th style="text-align: center">意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-r</td>
      <td style="text-align: center">将objectfile 文件插入静态库尾或替换静态库中同名文件</td>
    </tr>
    <tr>
      <td style="text-align: center">-x</td>
      <td style="text-align: center">从静态库文件中抽取文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-t</td>
      <td style="text-align: center">打印静态库的成员文件列表</td>
    </tr>
    <tr>
      <td style="text-align: center">-d</td>
      <td style="text-align: center">从静态库中删除文件objfile</td>
    </tr>
    <tr>
      <td style="text-align: center">-s</td>
      <td style="text-align: center">重置静态库文件索引</td>
    </tr>
    <tr>
      <td style="text-align: center">-v</td>
      <td style="text-align: center">创建文件冗余信息</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">创建静态库文件</td>
    </tr>
  </tbody>
</table>

<p>生成了静态库后，可以在可执行文件中调用静态库内的函数,示例代码：</p>

<figure class="code"><figcaption><span>lang: test_hello_stactic.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="k">extern</span> <span class="kt">void</span> <span class="nf">helloworld</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">helloworld</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<p>编译命令:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc test_hello_stactic.c -o test_hello_sta ./libsayhello.a</span></code></pre></td></tr></table></div></figure>

<h3 id="section-2">动态库使用示例</h3>

<p>编译动态库：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ gcc -O2 -fPIC -shared sayhello.c -o libsayhello.so
</span><span class="line">或
</span><span class="line">$ gcc -O2 -fPIC -c sayhello.c
</span><span class="line">$ gcc -shared -o libsayhello.so sayhello.o</span></code></pre></td></tr></table></div></figure>

<p>其中</p>

<ul>
  <li>fPIC:产生与位置无关码，全部使用相对地址</li>
  <li>shared:生成动态库</li>
</ul>

<p>调用动态库的示例代码：</p>

<figure class="code"><figcaption><span>lang: test_hello_shared.c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;dlfcn.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define LIB &quot;./libsayhello.so&quot;</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">void</span> <span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="n">LIB</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">dl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error:faile to load libary.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="s">&quot;helloworld&quot;</span><span class="p">);</span>
</span><span class="line">    <span class="n">func</span><span class="p">();</span>
</span><span class="line">    <span class="n">dlclose</span><span class="p">(</span><span class="n">dl</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-3">动态库和静态库整合</h3>

<h3 id="section-4">参考文档</h3>

<ol>
  <li><a href="http://answerywj.com/2016/10/10/Linux%E4%B8%8BC%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/">Linux下C调用静态库和动态库</a></li>
  <li><a href="https://liam0205.me/2017/04/03/not-to-link-libstdc-statically-and-why/">为什么不能再动态库里静态链接</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何理解内存对齐]]></title>
    <link href="http://lazybing.github.io/blog/2018/08/22/memory-alignment/"/>
    <updated>2018-08-22T08:23:49-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/08/22/memory-alignment</id>
    <content type="html"><![CDATA[<p>数据对齐会影响到计算机访问内存以及占用内存的空间大小。</p>

<!--more-->

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">对齐要求</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">填充</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">结构体的对齐和填充</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">结构体成员重排</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">可读性与缓存局部性</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">代码测试示例</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">参考文档</a></li>
</ul>

<h3 id="section">对齐要求</h3>

<p>在<code>X86</code>或<code>ARM</code>处理器中，基本 C 数据类型通常并不存储于内存中的随机字节地址。实际情况是，除<code>char</code>外，
所有其他类型都有对齐要求：<code>char</code>可起始于任意字节地址，2 字节的 short 必须从偶数字节地址开始，4 字节<code>int</code>或<code>float</code>必须
从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从能被 4 整除的地址开始，8 比特的<code>long</code>和<code>double</code>必须从
能被 8 整除的地址开始。无论<code>signed(有符号)</code>还是<code>unsigned(无符号)</code>都不受影响。</p>

<p>简言之，<code>X86</code>和<code>ARM</code>的基本 C 类型是<code>自对齐(self-aligned)</code>的。关于指针，无论 32 位还是 64 位也都是自对齐的。</p>

<p>自对齐可令访问速度更快，因为它有利于生成单指令(single-instruction)存取这些类型的数据。另一方面，如若没有对齐约束，可能
最终不得不通过两个或更多指令访问跨越机器字边界的数据。字符数据是种特殊情况，因其始终处在单一机器字中，所以无论存取何处的字符数据，
开销都是一致的。这也就是它不需要对齐的原因。</p>

<h3 id="section-1">填充</h3>

<p>假设我们有如下一段 C 代码：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">int function(void)
</span><span class="line">{
</span><span class="line">    char *pchar;
</span><span class="line">    char ch;
</span><span class="line">    int idx;
</span><span class="line">    ...
</span><span class="line">}</span></code></pre></td></tr></table></div></figure>

<p>这里的占用字节空间如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *pchar;    //4 or 8 bytes
</span><span class="line">char ch;        //1 byte
</span><span class="line">char pad[3];    //3 bytes, 3 个字节的空间被浪费掉了
</span><span class="line">int idx;        //4 bytes
</span><span class="line">...</span></code></pre></td></tr></table></div></figure>

<p>如果 <code>x </code>为 2 字节 short：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *p;
</span><span class="line">char c;
</span><span class="line">short x;</span></code></pre></td></tr></table></div></figure>

<p>时间分布为:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">char *p;    //4 or 8 bytes
</span><span class="line">char c;     //1 byte
</span><span class="line">char pad[1];    //1 byte, 1 字节的空间被浪费掉了
</span><span class="line">short x;        //2 bytes</span></code></pre></td></tr></table></div></figure>

<p>更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-2">结构体的对齐和填充</h3>

<p>通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。编译器之所以如此，是因为此乃确保所有成员自对齐，实现快速访问最简便的方法。</p>

<p>思考如下的结构体：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo1{
</span><span class="line">    char *p;
</span><span class="line">    char c;
</span><span class="line">    long x;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>64 位系统中，任何<code>struct foo1</code>的实例都采用 8 字节对齐，其内存分布如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo1{
</span><span class="line">    char *p;    //8 bytes
</span><span class="line">    char c;     //1 byte
</span><span class="line">    char pad[7];    // 7 bytes
</span><span class="line">    long x;         // 8 bytes
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>
<p>更多示例，请参照最后给出的程序示例。</p>

<h3 id="section-3">结构体成员重排</h3>

<p>理解了结构体成员的对齐后，可以看到，最简单的节省内存的方式，是按对齐递减重新对结构体成员排序。即让所有指针对齐成员排在最前面，因为
在 64 为系统中它们占用 8 字节；然后是 4 字节的 int；再然后是 2 字节的 short，最后是字符。</p>

<p>以简单的链表结构为例：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo7{
</span><span class="line">    char c;
</span><span class="line">    struct foo7 *p;
</span><span class="line">    short x;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>
<p><code>sizeof(foo7)</code>占用 24 字节。如果按照长度重排，可以得到:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct foo8{
</span><span class="line">    struct foo8 *p;
</span><span class="line">    short x;
</span><span class="line">    char c;
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>重新打包后，空间降低为 16 字节。</p>

<h3 id="section-4">可读性与缓存局部性</h3>

<p>笨拙地、机械地重排结构体可能有损可读性。最好重排成员：将语义相关的数据放在一起，形成连贯的组。最理想的情况是，结构体的设计应与程序的设计相通。</p>

<h3 id="section-5">代码测试示例</h3>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdbool.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo1</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo2</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="cm">/* 7 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="cm">/* 8 bytes */</span>
</span><span class="line">    <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>      <span class="cm">/* 8 bytes */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo3</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="cm">/* 8 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo4</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">s</span><span class="p">;</span>     <span class="cm">/* 2 bytes */</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="cm">/* 1 byte */</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo5</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo5_inner</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="n">inner</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo6</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">flip</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">nybble</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">septet</span><span class="p">:</span><span class="mi">7</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo7</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo8</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield1</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield1</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield2</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield2</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo9</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield1</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">bigfield2</span><span class="p">:</span><span class="mi">31</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield1</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="nl">littlefield2</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo10</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo10</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo11</span> <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo11</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">foo12</span> <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">foo12_inner</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">        <span class="kt">short</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="n">inner</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(char *)        = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(long)          = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(int)           = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(short)         = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(char)          = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(float)         = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(double)        = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo1)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo1</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo2)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo2</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo3)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo3</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo4)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo4</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo5)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo5</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo6)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo6</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo7)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo7</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo8)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo8</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo9)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo9</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo10)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo10</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo11)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo11</span><span class="p">));</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;sizeof(struct foo12)   = %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">foo12</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="section-6">参考文档</h3>

<ol>
  <li><a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">The Lost Art Of C Structure Packing</a></li>
  <li><a href="https://wr.informatik.uni-hamburg.de/_media/teaching/wintersemester_2013_2014/epc-14-haase-svenhendrik-alignmentinc-paper.pdf">Memory Alignment</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data Structure Alignment</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从FFMpeg中提取CODEC(以TTA Decoder为例)]]></title>
    <link href="http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg/"/>
    <updated>2018-05-06T07:55:35-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/05/06/how-to-extract-codecs-from-ffmpeg</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#tta-" id="markdown-toc-tta-">TTA 简介</a></li>
  <li><a href="#ffmpeg--tta-decoder" id="markdown-toc-ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</a></li>
  <li><a href="#tta-decoder-" id="markdown-toc-tta-decoder-">提取 TTA Decoder 中可能遇到的问题</a></li>
  <li><a href="#tta-decoder--1" id="markdown-toc-tta-decoder--1">提取 TTA Decoder 实现</a></li>
</ul>

<p><a href="https://ffmpeg.org/">FFMpeg</a> 作为音视频领域的开源工具，它几乎可以实现所有针对音视频的处理。最近一直做得工作是从 FFMpeg 中提取特定的编解码器，本位以最简单的 TTA Decoder 为例，介绍如何同 FFMpeg 中提取 CODEC。</p>

<!--more-->

<h2 id="tta-">TTA 简介</h2>

<p>TTA(The True Audio Codec) 是免费、简单、实时无损视频压缩。基于 Adaptive Prognostic Filters, TTA 同其他同类的开源项目有强竞争力。</p>

<h2 id="ffmpeg--tta-decoder">FFMpeg 中 TTA Decoder</h2>

<p>FFMpeg 中关于 TTA Decoder 的部分在<code>libavcodec/tta.c</code>中定义:</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class=""><span class="line">AVCodec ff_tta_decoder = {
</span><span class="line">    .name           = "tta",
</span><span class="line">    .long_name      = NULL_IF_CONFIG_SMALL("TTA (True Audio)"),
</span><span class="line">    .type           = AVMEDIA_TYPE_AUDIO,
</span><span class="line">    .id             = AV_CODEC_ID_TTA,
</span><span class="line">    .priv_data_size = sizeof(TTAContext),
</span><span class="line">    .init           = tta_decode_init,
</span><span class="line">    .close          = tta_decode_close,
</span><span class="line">    .decode         = tta_decode_frame,
</span><span class="line">    .init_thread_copy = ONLY_IF_THREADS_ENABLED(init_thread_copy),
</span><span class="line">    .capabilities     = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
</span><span class="line">    .priv_class       = &amp;tta_decoder_class,
</span><span class="line">};</span></code></pre></td></tr></table></div></figure>

<p>从 TTA AVCodec 的定义可以看出，Decoder 的主要函数只有三个<code>tta_decode_init</code>、<code>tta_decode_frame</code>、<code>tta_decode_close</code>三部分。其中 init 部分主要是解析 TTA Header 信息，decode 部分是真正解码部分，close 主要是释放内存。</p>

<p>不管是硬件解码还是软件解码，Decoder 部分一般都包含六部分：解码器初始化、解码器释放、设置压缩数据给解码器、从解码器获取解码后的数据、设置参数给解码器、从解码器获取参数信息。因此我们可以按照上面的思路，将 FFMpeg 中的这几个函数拆分成相应的函数。</p>

<h2 id="tta-decoder-">提取 TTA Decoder 中可能遇到的问题</h2>

<h2 id="tta-decoder--1">提取 TTA Decoder 实现</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[音频概念介绍(采样频率、帧率、通道数等)]]></title>
    <link href="http://lazybing.github.io/blog/2018/03/25/audio-basic-concept/"/>
    <updated>2018-03-25T08:54:32-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/03/25/audio-basic-concept</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">音频基础概述</a></li>
  <li><a href="#pcm-" id="markdown-toc-pcm-">PCM 数据摆放格式</a></li>
</ul>

<p>最近在给现代汽车做一个从 FFMpeg 中提取各个音频解码器的项目，很多都是音频。因为之前做的大多数都是视频项目，音频知识比较匮乏。限制记录一下。
<!--more--></p>

<h2 id="section">音频基础概述</h2>

<p>首先我们用 MediaInfo 来看下音频流的一些信息如图所示：</p>

<p><img src="http://lazybing.github.io/images/audio_basic_concept/audio_basic_format.png" /></p>

<p>逐个分析：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Format:AC-3
</span><span class="line">Format/Info:Audio Coding 3
</span><span class="line">Duration:33s 984ms
</span><span class="line">Bit rate:448 Kbps
</span><span class="line">Channel(s):6 channels
</span><span class="line">Channel positions: Front:L C R, Side:L R LFE
</span><span class="line">Sampling rate:48.0KHz
</span><span class="line">Bit depth:16bits
</span><span class="line">Frame rate:31.250 fps </span></code></pre></td></tr></table></div></figure>

<p>采样率(sampling rate)：声音信号在”模数”转换过程中单位时间内采样的次数。采样率是指每一次采样周期内声音模拟信号的数值，一般的采样率包括：8kHz/11.025kHz/22.05kHz/16kHz/37.8kHz/44.1kHz/48kHz。</p>

<p>帧率(Frame rate):每秒钟中帧数，单位是fps，如上面的 31.250 fps。</p>

<p>通道数(channels):声音的通道数，常用的有单声道和立体声之分。上面的声道数是 6 通道。</p>

<p>比特率(bit rate):每秒的传输速率(比特率)。</p>

<p>bitspersample:每个 sample 占用的 bits 数。</p>

<h2 id="pcm-">PCM 数据摆放格式</h2>

<p>在做项目的过程中，经常用到的一点是在输出 PCM 数据时，经常要了解 PCM 的摆放格式。根据不同的 bps 和 channels，数据的摆放时不同的。</p>

<p><img src="http://lazybing.github.io/images/audio_basic_concept/pcm_channels_bps.png" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ELF格式分析手册]]></title>
    <link href="http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial/"/>
    <updated>2018-03-21T07:30:48-07:00</updated>
    <id>http://lazybing.github.io/blog/2018/03/21/elf-format-tutorial</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#elf-data-type" id="markdown-toc-elf-data-type">ELF Data Type</a></li>
  <li><a href="#the-elf-header" id="markdown-toc-the-elf-header">The ELF Header</a></li>
  <li><a href="#checking-the-elf-header" id="markdown-toc-checking-the-elf-header">Checking the ELF Header</a></li>
  <li><a href="#loading-the-elf-file" id="markdown-toc-loading-the-elf-file">Loading the ELF File</a></li>
</ul>

<p>本文主要记录目标文件是<code>i386(32位架构、小端序)ELF</code>文件的加载过程。本文中的所有代码都是 C 风格，所有代码段都会使用最简单的例子。后面可能会扩展到其他类型的 ELF 文件。
<!--more--></p>

<h1 id="elf-data-type">ELF Data Type</h1>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdint.h&gt;</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">Elf32_Half</span><span class="p">;</span>    <span class="c1">//Unsigned half int</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Off</span><span class="p">;</span>     <span class="c1">//Unsigned offset</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Addr</span><span class="p">;</span>    <span class="c1">//Unsigned address</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">uint32_t</span> <span class="n">Elf32_Word</span><span class="p">;</span>    <span class="c1">//Unsigned int</span>
</span><span class="line"><span class="k">typedef</span> <span class="kt">int32_t</span>  <span class="n">Elf32_Sword</span><span class="p">;</span>   <span class="c1">//Signed int</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="the-elf-header">The ELF Header</h1>

<p>每个 ELF 格式文件都有位于文件开始的头部<code>Header</code>。</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#define ELF_NIDENT 16</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
</span><span class="line">    <span class="kt">uint8_t</span>     <span class="n">e_ident</span><span class="p">[</span><span class="n">ELF_NIDENT</span><span class="p">];</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_type</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_machine</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_version</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Addr</span>  <span class="n">e_entry</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Off</span>   <span class="n">e_phoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Off</span>   <span class="n">e_shoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_flags</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_ehsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shoff</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Word</span>  <span class="n">e_flags</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_ehsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phentsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_phnum</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shentsize</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shnum</span><span class="p">;</span>
</span><span class="line">    <span class="n">Elf32_Half</span>  <span class="n">e_shstrndx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span><span class="n">ELF32_Ehdr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">enum</span> <span class="n">Elf_Ident</span><span class="p">{</span>
</span><span class="line">    <span class="n">EI_MAG0</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//0x7F</span>
</span><span class="line">    <span class="n">EI_MAG1</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//‘E’</span>
</span><span class="line">    <span class="n">EI_MAG2</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">//‘L’</span>
</span><span class="line">    <span class="n">EI_MAG3</span>    <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">//‘F’</span>
</span><span class="line">    <span class="n">EI_CLASS</span>   <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="c1">//Architecture(32/64)</span>
</span><span class="line">    <span class="n">EI_DATA</span>    <span class="o">=</span> <span class="mi">5</span><span class="p">,</span><span class="c1">//Byte Order</span>
</span><span class="line">    <span class="n">EI_VERSION</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="c1">//ELF Version</span>
</span><span class="line">    <span class="n">EI_OSABI</span>   <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="c1">//OS Specific</span>
</span><span class="line">    <span class="n">EI_ABIVERSION</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="c1">//OS Specific</span>
</span><span class="line">    <span class="n">EI_PAD</span>        <span class="o">=</span> <span class="mi">9</span>  <span class="c1">//Padding</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define ELFMAG0    0x7F   </span><span class="c1">//e_ident[EI_MAG0]</span>
</span><span class="line"><span class="cp">#define ELFMAG1    &#39;E&#39;    </span><span class="c1">//e_ident[EI_MAG1]</span>
</span><span class="line"><span class="cp">#define ELFMAG2    &#39;L&#39;    </span><span class="c1">//e_ident[EI_MAG2]</span>
</span><span class="line"><span class="cp">#define ELFMAG3    &#39;F&#39;    </span><span class="c1">//e_ident[EI_MAG3]</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define ELFDATA2LSB (1)   </span><span class="c1">//Little Endian</span>
</span><span class="line"><span class="cp">#define ELFCLASS32  (1)   </span><span class="c1">//32-bit Architecture</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">enum</span> <span class="n">Elf_Type</span><span class="p">{</span>
</span><span class="line">    <span class="n">ET_NONE</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">//Unknown Type</span>
</span><span class="line">    <span class="n">ET_REL</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//Relocatable File</span>
</span><span class="line">    <span class="n">ET_EXEC</span>    <span class="o">=</span> <span class="mi">2</span>  <span class="c1">//Executable File</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="cp">#define EM_386     (3) </span><span class="c1">//x86 Machine Type</span>
</span><span class="line"><span class="cp">#define EV_CURRENT (1) </span><span class="c1">//ELF Current Version</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="checking-the-elf-header">Checking the ELF Header</h1>

<p>在对<code>ELF</code>文件进行加载、链接、重定向或其他操作之前，首先要确保机器是否支持上述的操作。</p>
<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">bool</span> <span class="nf">elf_check_file</span><span class="p">(</span><span class="n">Elf32_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG0</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG0 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG1</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG1 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG2</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG2 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_MAG3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFMAG3</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;ELF Header EI_MAG2 incorrect.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">bool</span> <span class="nf">elf_check_supported</span><span class="p">(</span><span class="n">ELF32_Ehdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">elf_check_file</span><span class="p">(</span><span class="n">hdr</span><span class="p">)){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Invalid ELF File.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_CLASS</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFCLASS32</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File Class.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ELFDATA2LSB</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File byte order.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">!=</span> <span class="n">EM_386</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File target.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_VERSION</span><span class="p">]</span> <span class="o">!=</span> <span class="n">EV_CURRENT</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File version.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_REL</span> <span class="o">&amp;&amp;</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span><span class="p">){</span>
</span><span class="line">        <span class="n">ERROR</span><span class="p">(</span><span class="s">&quot;Unsupported ELF File type.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<h1 id="loading-the-elf-file">Loading the ELF File</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汇编语言实现hello World]]></title>
    <link href="http://lazybing.github.io/blog/2018/01/11/assemble-hello-world/"/>
    <updated>2018-01-11T21:29:27-08:00</updated>
    <id>http://lazybing.github.io/blog/2018/01/11/assemble-hello-world</id>
    <content type="html"><![CDATA[
<p>接下来的工作可能要用到汇编语言。</p>

<!--more-->

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class=""><span class="line">.data                   # section declaration
</span><span class="line">msg:
</span><span class="line">    .ascii  "Hello, world!\n"   # our dear string
</span><span class="line">    len = . - msg               # length of our dear string
</span><span class="line">
</span><span class="line">.text                           # section declaration
</span><span class="line">
</span><span class="line">                            # we must export the entry point to the ELF linker or
</span><span class="line">    .global _start          # loader. They conventionally recognize _start as their 
</span><span class="line">                            # entry point. Use ld -e foo to override the default.
</span><span class="line">
</span><span class="line">_start:
</span><span class="line">
</span><span class="line"># write our string to stdout
</span><span class="line">    
</span><span class="line">    movl $len, %edx        # third argument:message length
</span><span class="line">    movl $msg, %ecx        # second argument:pointer to message to write
</span><span class="line">    movl $1, %ebx          # first argument:file handle(stdout) 
</span><span class="line">    movl $4, %eax          # system call number (sys_write)
</span><span class="line">    int  $0x80             # call kernel
</span><span class="line">
</span><span class="line"># and exit
</span><span class="line">
</span><span class="line">    movl $0, %ebx           # first argument:exit code
</span><span class="line">    movl $1, %eax           # system call number (sys_exit)
</span><span class="line">    int  $0x80              # call kernel</span></code></pre></td></tr></table></div></figure>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X264 源码解析之x264_macroblock_encode函数]]></title>
    <link href="http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode/"/>
    <updated>2017-12-25T19:52:38-08:00</updated>
    <id>http://lazybing.github.io/blog/2017/12/25/x264-macroblock-encode</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#x264macroblockencode-" id="markdown-toc-x264macroblockencode-">x264_macroblock_encode 概述</a>    <ul>
      <li><a href="#ipcm-" id="markdown-toc-ipcm-">I_PCM 编码模式</a></li>
      <li><a href="#pskip--bskip-" id="markdown-toc-pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</a></li>
    </ul>
  </li>
</ul>

<p>本文主要记录 X264 中对于<code>x264_macroblock_encode</code>函数的分析，该函数主要变换和量化，对应 X264 中的宏块编码模块。<br />
<!--more--></p>

<h2 id="x264macroblockencode-">x264_macroblock_encode 概述</h2>

<p>该函数主要在<code>x264_slice_write()</code>函数调用，它主要完成了编码器中的变换、量化部分，该函数主要是封装了<code>x264_macroblock_encode_internal()</code>函数，它包括如下几个步骤：</p>

<figure class="code"><figcaption><span>x264_macroblock_encode </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">x264_macroblock_encode</span><span class="p">(</span><span class="kt">x264_t</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">CHROMA444</span><span class="p">)</span>
</span><span class="line">        <span class="n">x264_macroblock_encode_internal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">        <span class="n">x264_macroblock_encode_internal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

<ol>
  <li>如果宏块类型为 PCM 类型，直接存储重建帧数据。</li>
  <li>如果宏块类型为 Skip 类型，调用<code>x264_macroblock_encode_skip()</code>编码 Skip 类型宏块，包括<code>P_SKIP</code>和<code>B_SKIP</code>类型。</li>
  <li>如果宏块类型为<code>I_16x16</code>，调用<code>x264_mb_encode_i16x16()</code>编码 Intra 16x16 类型的宏块，该函数除了进行 DCT 变换之外，还对 16 个小块的 DC 系数进行 Hadamard 变换。</li>
  <li>如果宏块类型为<code>I_4x4</code>，调用<code>x264_mb_encode_i4x4()</code>编码 Intra 4x4 类型的宏块。</li>
  <li>帧间宏块编码，该部分并没有单独的函数完成，而是写在了<code>x264_macroblock_encode_internal</code>函数内部。</li>
  <li>调用<code>x264_mb_encode_chroma()</code>函数编码色度卡。</li>
</ol>

<h3 id="ipcm-">I_PCM 编码模式</h3>

<p>I_PCM 是一种帧内编码模式，在该模式下，编码器直接传输图像的像素值，而不经过预测和变换。在一些特殊的情况下，特别是图像
内容不规则或者量化参数非常低时，该模式比常规的操作（帧内预测-变换-量化-编码）效率更高。</p>

<p>I_PCM 模式用于以下目的：</p>

<ol>
  <li>允许编码器精确地表示像素值。</li>
  <li>提供表示不规则图像内容的准确性，而不引起重大的数据量增加。</li>
  <li>严格限制宏块解码比特数，但不降低编码效率。</li>
</ol>

<p>对 I_PCM 类型的编码，实现代码如下：</p>

<figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="p">...</span>
</span><span class="line"><span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">i_type</span> <span class="o">==</span> <span class="n">I_PCM</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">//if PCM is chosen, we need to store reconstructed frame data</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">plane_count</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_16x16</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">chroma</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">&gt;&gt;</span> <span class="n">CHROMA_V_SHIFT</span><span class="p">;</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_8x8</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">        <span class="n">h</span><span class="o">-&gt;</span><span class="n">mc</span><span class="p">.</span><span class="n">copy</span><span class="p">[</span><span class="n">PIXEL_8x8</span><span class="p">](</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fdec</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">FDEC_STRIDE</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">pic</span><span class="p">.</span><span class="n">p_fenc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">FENC_STRIDE</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>

<h3 id="pskip--bskip-">P_Skip 模式和 B_Skip 模式编码</h3>

<ul>
  <li>P_Skip 类型宏块：即 COPY 宏块，无像素残差，无运动矢量残差(MVD)。直接利用预测 MV 得到的像素预测值。像素重构值= 像素预测值。</li>
  <li>B_Skip 类型宏块：无像素残差，无运动矢量残差(MVD)。解码时，通过 Direct 预测模式(时间或空间)计算出前、后向 MV 后，直接利用前、后向 MV 得到像素预测值。像素重构值 = 像素预测值。</li>
</ul>

]]></content>
  </entry>
  
</feed>
